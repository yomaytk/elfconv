/*
 * Copyright (c) 2017 Trail of Bits, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "Decode.h"

#include <remill/BC/HelperMacro.h>
#include <stdio.h>

namespace remill {
namespace aarch64 {
namespace {

const char *const kIClassName[] = {
    nullptr,     "ABS",       "ADC",       "ADCS",      "ADD",       "ADDHN",    "ADDP",
    "ADDS",      "ADDV",      "ADR",       "ADRP",      "AESD",      "AESE",     "AESIMC",
    "AESMC",     "AND",       "ANDS",      "ASRV",      "B",         "BFM",      "BIC",
    "BICS",      "BIF",       "BIT",       "BL",        "BLR",       "BR",       "BRK",
    "BSL",       "CAS",       "CASA",      "CASAB",     "CASAH",     "CASAL",    "CASALB",
    "CASALH",    "CASB",      "CASH",      "CASL",      "CASLB",     "CASLH",    "CASP",
    "CASPA",     "CASPAL",    "CASPL",     "CBNZ",      "CBZ",       "CCMN",     "CCMP",
    "CLREX",     "CLS",       "CLZ",       "CMEQ",      "CMGE",      "CMGT",     "CMHI",
    "CMHS",      "CMLE",      "CMLT",      "CMTST",     "CNT",       "CRC32B",   "CRC32CB",
    "CRC32CH",   "CRC32CW",   "CRC32CX",   "CRC32H",    "CRC32W",    "CRC32X",   "CSEL",
    "CSINC",     "CSINV",     "CSNEG",     "DCPS1",     "DCPS2",     "DCPS3",    "DMB",
    "DRPS",      "DSB",       "DUP",       "EON",       "EOR",       "ERET",     "ESB",
    "EXT",       "EXTR",      "FABD",      "FABS",      "FACGE",     "FACGT",    "FADD",
    "FADDP",     "FCCMP",     "FCCMPE",    "FCMEQ",     "FCMGE",     "FCMGT",    "FCMLE",
    "FCMLT",     "FCMP",      "FCMPE",     "FCSEL",     "FCVT",      "FCVTAS",   "FCVTAU",
    "FCVTL",     "FCVTMS",    "FCVTMU",    "FCVTN",     "FCVTNS",    "FCVTNU",   "FCVTPS",
    "FCVTPU",    "FCVTXN",    "FCVTZS",    "FCVTZU",    "FDIV",      "FMADD",    "FMAX",
    "FMAXNM",    "FMAXNMP",   "FMAXNMV",   "FMAXP",     "FMAXV",     "FMIN",     "FMINNM",
    "FMINNMP",   "FMINNMV",   "FMINP",     "FMINV",     "FMLA",      "FMLS",     "FMOV",
    "FMSUB",     "FMUL",      "FMULX",     "FNEG",      "FNMADD",    "FNMSUB",   "FNMUL",
    "FRECPE",    "FRECPS",    "FRECPX",    "FRINTA",    "FRINTI",    "FRINTM",   "FRINTN",
    "FRINTP",    "FRINTX",    "FRINTZ",    "FRSQRTE",   "FRSQRTS",   "FSQRT",    "FSUB",
    "HINT",      "HLT",       "HVC",       "INS",       "ISB",       "LD1",      "LD1R",
    "LD2",       "LD2R",      "LD3",       "LD3R",      "LD4",       "LD4R",     "LDADD",
    "LDADDA",    "LDADDAB",   "LDADDAH",   "LDADDAL",   "LDADDALB",  "LDADDALH", "LDADDB",
    "LDADDH",    "LDADDL",    "LDADDLB",   "LDADDLH",   "LDAR",      "LDARB",    "LDARH",
    "LDAXP",     "LDAXR",     "LDAXRB",    "LDAXRH",    "LDCLR",     "LDCLRA",   "LDCLRAB",
    "LDCLRAH",   "LDCLRAL",   "LDCLRALB",  "LDCLRALH",  "LDCLRB",    "LDCLRH",   "LDCLRL",
    "LDCLRLB",   "LDCLRLH",   "LDEOR",     "LDEORA",    "LDEORAB",   "LDEORAH",  "LDEORAL",
    "LDEORALB",  "LDEORALH",  "LDEORB",    "LDEORH",    "LDEORL",    "LDEORLB",  "LDEORLH",
    "LDLAR",     "LDLARB",    "LDLARH",    "LDNP",      "LDP",       "LDPSW",    "LDR",
    "LDRB",      "LDRH",      "LDRSB",     "LDRSH",     "LDRSW",     "LDSET",    "LDSETA",
    "LDSETAB",   "LDSETAH",   "LDSETAL",   "LDSETALB",  "LDSETALH",  "LDSETB",   "LDSETH",
    "LDSETL",    "LDSETLB",   "LDSETLH",   "LDSMAX",    "LDSMAXA",   "LDSMAXAB", "LDSMAXAH",
    "LDSMAXAL",  "LDSMAXALB", "LDSMAXALH", "LDSMAXB",   "LDSMAXH",   "LDSMAXL",  "LDSMAXLB",
    "LDSMAXLH",  "LDSMIN",    "LDSMINA",   "LDSMINAB",  "LDSMINAH",  "LDSMINAL", "LDSMINALB",
    "LDSMINALH", "LDSMINB",   "LDSMINH",   "LDSMINL",   "LDSMINLB",  "LDSMINLH", "LDTR",
    "LDTRB",     "LDTRH",     "LDTRSB",    "LDTRSH",    "LDTRSW",    "LDUMAX",   "LDUMAXA",
    "LDUMAXAB",  "LDUMAXAH",  "LDUMAXAL",  "LDUMAXALB", "LDUMAXALH", "LDUMAXB",  "LDUMAXH",
    "LDUMAXL",   "LDUMAXLB",  "LDUMAXLH",  "LDUMIN",    "LDUMINA",   "LDUMINAB", "LDUMINAH",
    "LDUMINAL",  "LDUMINALB", "LDUMINALH", "LDUMINB",   "LDUMINH",   "LDUMINL",  "LDUMINLB",
    "LDUMINLH",  "LDUR",      "LDURB",     "LDURH",     "LDURSB",    "LDURSH",   "LDURSW",
    "LDXP",      "LDXR",      "LDXRB",     "LDXRH",     "LSLV",      "LSRV",     "MADD",
    "MLA",       "MLS",       "MOVI",      "MOVK",      "MOVN",      "MOVZ",     "MRS",
    "MSR",       "MSUB",      "MUL",       "MVNI",      "NEG",       "NOP",      "NOT",
    "ORN",       "ORR",       "PMUL",      "PMULL",     "PRFM",      "PRFUM",    "PSB",
    "RADDHN",    "RBIT",      "RET",       "REV",       "REV16",     "REV32",    "REV64",
    "RORV",      "RSHRN",     "RSUBHN",    "SABA",      "SABAL",     "SABD",     "SABDL",
    "SADALP",    "SADDL",     "SADDLP",    "SADDLV",    "SADDW",     "SBC",      "SBCS",
    "SBFM",      "SCVTF",     "SDIV",      "SEV",       "SEVL",      "SHA1C",    "SHA1H",
    "SHA1M",     "SHA1P",     "SHA1SU0",   "SHA1SU1",   "SHA256H",   "SHA256H2", "SHA256SU0",
    "SHA256SU1", "SHADD",     "SHL",       "SHLL",      "SHRN",      "SHSUB",    "SLI",
    "SMADDL",    "SMAX",      "SMAXP",     "SMAXV",     "SMC",       "SMIN",     "SMINP",
    "SMINV",     "SMLAL",     "SMLSL",     "SMOV",      "SMSUBL",    "SMULH",    "SMULL",
    "SQABS",     "SQADD",     "SQDMLAL",   "SQDMLSL",   "SQDMULH",   "SQDMULL",  "SQNEG",
    "SQRDMLAH",  "SQRDMLSH",  "SQRDMULH",  "SQRSHL",    "SQRSHRN",   "SQRSHRUN", "SQSHL",
    "SQSHLU",    "SQSHRN",    "SQSHRUN",   "SQSUB",     "SQXTN",     "SQXTUN",   "SRHADD",
    "SRI",       "SRSHL",     "SRSHR",     "SRSRA",     "SSHL",      "SSHLL",    "SSHR",
    "SSRA",      "SSUBL",     "SSUBW",     "ST1",       "ST2",       "ST3",      "ST4",
    "STADD",     "STADDB",    "STADDH",    "STADDL",    "STADDLB",   "STADDLH",  "STCLR",
    "STCLRB",    "STCLRH",    "STCLRL",    "STCLRLB",   "STCLRLH",   "STEOR",    "STEORB",
    "STEORH",    "STEORL",    "STEORLB",   "STEORLH",   "STLLR",     "STLLRB",   "STLLRH",
    "STLR",      "STLRB",     "STLRH",     "STLXP",     "STLXR",     "STLXRB",   "STLXRH",
    "STNP",      "STP",       "STR",       "STRB",      "STRH",      "STSET",    "STSETB",
    "STSETH",    "STSETL",    "STSETLB",   "STSETLH",   "STSMAX",    "STSMAXB",  "STSMAXH",
    "STSMAXL",   "STSMAXLB",  "STSMAXLH",  "STSMIN",    "STSMINB",   "STSMINH",  "STSMINL",
    "STSMINLB",  "STSMINLH",  "STTR",      "STTRB",     "STTRH",     "STUMAX",   "STUMAXB",
    "STUMAXH",   "STUMAXL",   "STUMAXLB",  "STUMAXLH",  "STUMIN",    "STUMINB",  "STUMINH",
    "STUMINL",   "STUMINLB",  "STUMINLH",  "STUR",      "STURB",     "STURH",    "STXP",
    "STXR",      "STXRB",     "STXRH",     "SUB",       "SUBHN",     "SUBS",     "SUQADD",
    "SVC",       "SWP",       "SWPA",      "SWPAB",     "SWPAH",     "SWPAL",    "SWPALB",
    "SWPALH",    "SWPB",      "SWPH",      "SWPL",      "SWPLB",     "SWPLH",    "SYS",
    "SYSL",      "TBL",       "TBNZ",      "TBX",       "TBZ",       "TRN1",     "TRN2",
    "UABA",      "UABAL",     "UABD",      "UABDL",     "UADALP",    "UADDL",    "UADDLP",
    "UADDLV",    "UADDW",     "UBFM",      "UCVTF",     "UDIV",      "UHADD",    "UHSUB",
    "UMADDL",    "UMAX",      "UMAXP",     "UMAXV",     "UMIN",      "UMINP",    "UMINV",
    "UMLAL",     "UMLSL",     "UMOV",      "UMSUBL",    "UMULH",     "UMULL",    "UQADD",
    "UQRSHL",    "UQRSHRN",   "UQSHL",     "UQSHRN",    "UQSUB",     "UQXTN",    "URECPE",
    "URHADD",    "URSHL",     "URSHR",     "URSQRTE",   "URSRA",     "USHL",     "USHLL",
    "USHR",      "USQADD",    "USRA",      "USUBL",     "USUBW",     "UZP1",     "UZP2",
    "WFE",       "WFI",       "XTN",       "YIELD",     "ZIP1",      "ZIP2",     "CNTX",
    "WHILE",
};

const char *const kIFormName[] = {
    nullptr,
    "ABS_ASIMDMISC_R",
    "ABS_ASISDMISC_R",
    "ADCS_32_ADDSUB_CARRY",
    "ADCS_64_ADDSUB_CARRY",
    "ADC_32_ADDSUB_CARRY",
    "ADC_64_ADDSUB_CARRY",
    "ADDHN_ASIMDDIFF_N",
    "ADDP_ASIMDSAME_ONLY",
    "ADDP_ASISDPAIR_ONLY",
    "ADDS_32S_ADDSUB_EXT",
    "ADDS_32S_ADDSUB_IMM",
    "ADDS_32_ADDSUB_SHIFT",
    "ADDS_64S_ADDSUB_EXT",
    "ADDS_64S_ADDSUB_IMM",
    "ADDS_64_ADDSUB_SHIFT",
    "ADDV_ASIMDALL_ONLY",
    "ADD_32_ADDSUB_EXT",
    "ADD_32_ADDSUB_IMM",
    "ADD_32_ADDSUB_SHIFT",
    "ADD_64_ADDSUB_EXT",
    "ADD_64_ADDSUB_IMM",
    "ADD_64_ADDSUB_SHIFT",
    "ADD_ASIMDSAME_ONLY",
    "ADD_ASISDSAME_ONLY",
    "ADRP_ONLY_PCRELADDR",
    "ADR_ONLY_PCRELADDR",
    "AESD_B_CRYPTOAES",
    "AESE_B_CRYPTOAES",
    "AESIMC_B_CRYPTOAES",
    "AESMC_B_CRYPTOAES",
    "ANDS_32S_LOG_IMM",
    "ANDS_32_LOG_SHIFT",
    "ANDS_64S_LOG_IMM",
    "ANDS_64_LOG_SHIFT",
    "AND_32_LOG_IMM",
    "AND_32_LOG_SHIFT",
    "AND_64_LOG_IMM",
    "AND_64_LOG_SHIFT",
    "AND_ASIMDSAME_ONLY",
    "ASRV_32_DP_2SRC",
    "ASRV_64_DP_2SRC",
    "ASR_ASRV_32_DP_2SRC",
    "ASR_ASRV_64_DP_2SRC",
    "ASR_SBFM_32M_BITFIELD",
    "ASR_SBFM_64M_BITFIELD",
    "AT_SYS_CR_SYSTEM",
    "BFC_BFM_32M_BITFIELD",
    "BFC_BFM_64M_BITFIELD",
    "BFI_BFM_32M_BITFIELD",
    "BFI_BFM_64M_BITFIELD",
    "BFM_32M_BITFIELD",
    "BFM_64M_BITFIELD",
    "BFXIL_BFM_32M_BITFIELD",
    "BFXIL_BFM_64M_BITFIELD",
    "BICS_32_LOG_SHIFT",
    "BICS_64_LOG_SHIFT",
    "BIC_32_LOG_SHIFT",
    "BIC_64_LOG_SHIFT",
    "BIC_ASIMDIMM_L_HL",
    "BIC_ASIMDIMM_L_SL",
    "BIC_ASIMDSAME_ONLY",
    "BIF_ASIMDSAME_ONLY",
    "BIT_ASIMDSAME_ONLY",
    "BLR_64_BRANCH_REG",
    "BL_ONLY_BRANCH_IMM",
    "BRK_EX_EXCEPTION",
    "BR_64_BRANCH_REG",
    "BSL_ASIMDSAME_ONLY",
    "B_ONLY_BRANCH_IMM",
    "B_ONLY_CONDBRANCH",
    "CASAB_C32_LDSTEXCL",
    "CASAH_C32_LDSTEXCL",
    "CASALB_C32_LDSTEXCL",
    "CASALH_C32_LDSTEXCL",
    "CASAL_C32_LDSTEXCL",
    "CASAL_C64_LDSTEXCL",
    "CASA_C32_LDSTEXCL",
    "CASA_C64_LDSTEXCL",
    "CASB_C32_LDSTEXCL",
    "CASH_C32_LDSTEXCL",
    "CASLB_C32_LDSTEXCL",
    "CASLH_C32_LDSTEXCL",
    "CASL_C32_LDSTEXCL",
    "CASL_C64_LDSTEXCL",
    "CASPAL_CP32_LDSTEXCL",
    "CASPAL_CP64_LDSTEXCL",
    "CASPA_CP32_LDSTEXCL",
    "CASPA_CP64_LDSTEXCL",
    "CASPL_CP32_LDSTEXCL",
    "CASPL_CP64_LDSTEXCL",
    "CASP_CP32_LDSTEXCL",
    "CASP_CP64_LDSTEXCL",
    "CAS_C32_LDSTEXCL",
    "CAS_C64_LDSTEXCL",
    "CBNZ_32_COMPBRANCH",
    "CBNZ_64_COMPBRANCH",
    "CBZ_32_COMPBRANCH",
    "CBZ_64_COMPBRANCH",
    "CCMN_32_CONDCMP_IMM",
    "CCMN_32_CONDCMP_REG",
    "CCMN_64_CONDCMP_IMM",
    "CCMN_64_CONDCMP_REG",
    "CCMP_32_CONDCMP_IMM",
    "CCMP_32_CONDCMP_REG",
    "CCMP_64_CONDCMP_IMM",
    "CCMP_64_CONDCMP_REG",
    "CINC_CSINC_32_CONDSEL",
    "CINC_CSINC_64_CONDSEL",
    "CINV_CSINV_32_CONDSEL",
    "CINV_CSINV_64_CONDSEL",
    "CLREX_BN_SYSTEM",
    "CLS_32_DP_1SRC",
    "CLS_64_DP_1SRC",
    "CLS_ASIMDMISC_R",
    "CLZ_32_DP_1SRC",
    "CLZ_64_DP_1SRC",
    "CLZ_ASIMDMISC_R",
    "CMEQ_ASIMDMISC_Z",
    "CMEQ_ASIMDSAME_ONLY",
    "CMEQ_ASISDMISC_Z",
    "CMEQ_ASISDSAME_ONLY",
    "CMGE_ASIMDMISC_Z",
    "CMGE_ASIMDSAME_ONLY",
    "CMGE_ASISDMISC_Z",
    "CMGE_ASISDSAME_ONLY",
    "CMGT_ASIMDMISC_Z",
    "CMGT_ASIMDSAME_ONLY",
    "CMGT_ASISDMISC_Z",
    "CMGT_ASISDSAME_ONLY",
    "CMHI_ASIMDSAME_ONLY",
    "CMHI_ASISDSAME_ONLY",
    "CMHS_ASIMDSAME_ONLY",
    "CMHS_ASISDSAME_ONLY",
    "CMLE_ASIMDMISC_Z",
    "CMLE_ASISDMISC_Z",
    "CMLT_ASIMDMISC_Z",
    "CMLT_ASISDMISC_Z",
    "CMN_ADDS_32S_ADDSUB_EXT",
    "CMN_ADDS_32S_ADDSUB_IMM",
    "CMN_ADDS_32_ADDSUB_SHIFT",
    "CMN_ADDS_64S_ADDSUB_EXT",
    "CMN_ADDS_64S_ADDSUB_IMM",
    "CMN_ADDS_64_ADDSUB_SHIFT",
    "CMP_SUBS_32S_ADDSUB_EXT",
    "CMP_SUBS_32S_ADDSUB_IMM",
    "CMP_SUBS_32_ADDSUB_SHIFT",
    "CMP_SUBS_64S_ADDSUB_EXT",
    "CMP_SUBS_64S_ADDSUB_IMM",
    "CMP_SUBS_64_ADDSUB_SHIFT",
    "CMTST_ASIMDSAME_ONLY",
    "CMTST_ASISDSAME_ONLY",
    "CNEG_CSNEG_32_CONDSEL",
    "CNEG_CSNEG_64_CONDSEL",
    "CNT_ASIMDMISC_R",
    "CRC32B_32C_DP_2SRC",
    "CRC32CB_32C_DP_2SRC",
    "CRC32CH_32C_DP_2SRC",
    "CRC32CW_32C_DP_2SRC",
    "CRC32CX_64C_DP_2SRC",
    "CRC32H_32C_DP_2SRC",
    "CRC32W_32C_DP_2SRC",
    "CRC32X_64C_DP_2SRC",
    "CSEL_32_CONDSEL",
    "CSEL_64_CONDSEL",
    "CSETM_CSINV_32_CONDSEL",
    "CSETM_CSINV_64_CONDSEL",
    "CSET_CSINC_32_CONDSEL",
    "CSET_CSINC_64_CONDSEL",
    "CSINC_32_CONDSEL",
    "CSINC_64_CONDSEL",
    "CSINV_32_CONDSEL",
    "CSINV_64_CONDSEL",
    "CSNEG_32_CONDSEL",
    "CSNEG_64_CONDSEL",
    "DCPS1_DC_EXCEPTION",
    "DCPS2_DC_EXCEPTION",
    "DCPS3_DC_EXCEPTION",
    "DC_SYS_CR_SYSTEM",
    "DMB_BO_SYSTEM",
    "DRPS_64E_BRANCH_REG",
    "DSB_BO_SYSTEM",
    "DUP_ASIMDINS_DR_R",
    "DUP_ASIMDINS_DV_V",
    "DUP_ASISDONE_ONLY",
    "EON_32_LOG_SHIFT",
    "EON_64_LOG_SHIFT",
    "EOR_32_LOG_IMM",
    "EOR_32_LOG_SHIFT",
    "EOR_64_LOG_IMM",
    "EOR_64_LOG_SHIFT",
    "EOR_ASIMDSAME_ONLY",
    "ERET_64E_BRANCH_REG",
    "ESB_HI_SYSTEM",
    "EXTR_32_EXTRACT",
    "EXTR_64_EXTRACT",
    "EXT_ASIMDEXT_ONLY",
    "FABD_ASIMDSAME_ONLY",
    "FABD_ASIMDSAMEFP16_ONLY",
    "FABD_ASISDSAME_ONLY",
    "FABD_ASISDSAMEFP16_ONLY",
    "FABS_D_FLOATDP1",
    "FABS_H_FLOATDP1",
    "FABS_S_FLOATDP1",
    "FABS_ASIMDMISC_R",
    "FABS_ASIMDMISCFP16_R",
    "FACGE_ASIMDSAME_ONLY",
    "FACGE_ASIMDSAMEFP16_ONLY",
    "FACGE_ASISDSAME_ONLY",
    "FACGE_ASISDSAMEFP16_ONLY",
    "FACGT_ASIMDSAME_ONLY",
    "FACGT_ASIMDSAMEFP16_ONLY",
    "FACGT_ASISDSAME_ONLY",
    "FACGT_ASISDSAMEFP16_ONLY",
    "FADDP_ASIMDSAME_ONLY",
    "FADDP_ASIMDSAMEFP16_ONLY",
    "FADDP_ASISDPAIR_ONLY_H",
    "FADDP_ASISDPAIR_ONLY_SD",
    "FADD_D_FLOATDP2",
    "FADD_H_FLOATDP2",
    "FADD_S_FLOATDP2",
    "FADD_ASIMDSAME_ONLY",
    "FADD_ASIMDSAMEFP16_ONLY",
    "FCCMPE_D_FLOATCCMP",
    "FCCMPE_H_FLOATCCMP",
    "FCCMPE_S_FLOATCCMP",
    "FCCMP_D_FLOATCCMP",
    "FCCMP_H_FLOATCCMP",
    "FCCMP_S_FLOATCCMP",
    "FCMEQ_ASIMDMISC_FZ",
    "FCMEQ_ASIMDMISCFP16_FZ",
    "FCMEQ_ASIMDSAME_ONLY",
    "FCMEQ_ASIMDSAMEFP16_ONLY",
    "FCMEQ_ASISDMISC_FZ",
    "FCMEQ_ASISDMISCFP16_FZ",
    "FCMEQ_ASISDSAME_ONLY",
    "FCMEQ_ASISDSAMEFP16_ONLY",
    "FCMGE_ASIMDMISC_FZ",
    "FCMGE_ASIMDMISCFP16_FZ",
    "FCMGE_ASIMDSAME_ONLY",
    "FCMGE_ASIMDSAMEFP16_ONLY",
    "FCMGE_ASISDMISC_FZ",
    "FCMGE_ASISDMISCFP16_FZ",
    "FCMGE_ASISDSAME_ONLY",
    "FCMGE_ASISDSAMEFP16_ONLY",
    "FCMGT_ASIMDMISC_FZ",
    "FCMGT_ASIMDMISCFP16_FZ",
    "FCMGT_ASIMDSAME_ONLY",
    "FCMGT_ASIMDSAMEFP16_ONLY",
    "FCMGT_ASISDMISC_FZ",
    "FCMGT_ASISDMISCFP16_FZ",
    "FCMGT_ASISDSAME_ONLY",
    "FCMGT_ASISDSAMEFP16_ONLY",
    "FCMLE_ASIMDMISC_FZ",
    "FCMLE_ASIMDMISCFP16_FZ",
    "FCMLE_ASISDMISC_FZ",
    "FCMLE_ASISDMISCFP16_FZ",
    "FCMLT_ASIMDMISC_FZ",
    "FCMLT_ASIMDMISCFP16_FZ",
    "FCMLT_ASISDMISC_FZ",
    "FCMLT_ASISDMISCFP16_FZ",
    "FCMPE_DZ_FLOATCMP",
    "FCMPE_D_FLOATCMP",
    "FCMPE_HZ_FLOATCMP",
    "FCMPE_H_FLOATCMP",
    "FCMPE_SZ_FLOATCMP",
    "FCMPE_S_FLOATCMP",
    "FCMP_DZ_FLOATCMP",
    "FCMP_D_FLOATCMP",
    "FCMP_HZ_FLOATCMP",
    "FCMP_H_FLOATCMP",
    "FCMP_SZ_FLOATCMP",
    "FCMP_S_FLOATCMP",
    "FCSEL_D_FLOATSEL",
    "FCSEL_H_FLOATSEL",
    "FCSEL_S_FLOATSEL",
    "FCVTAS_32D_FLOAT2INT",
    "FCVTAS_32H_FLOAT2INT",
    "FCVTAS_32S_FLOAT2INT",
    "FCVTAS_64D_FLOAT2INT",
    "FCVTAS_64H_FLOAT2INT",
    "FCVTAS_64S_FLOAT2INT",
    "FCVTAS_ASIMDMISC_R",
    "FCVTAS_ASIMDMISCFP16_R",
    "FCVTAS_ASISDMISC_R",
    "FCVTAS_ASISDMISCFP16_R",
    "FCVTAU_32D_FLOAT2INT",
    "FCVTAU_32H_FLOAT2INT",
    "FCVTAU_32S_FLOAT2INT",
    "FCVTAU_64D_FLOAT2INT",
    "FCVTAU_64H_FLOAT2INT",
    "FCVTAU_64S_FLOAT2INT",
    "FCVTAU_ASIMDMISC_R",
    "FCVTAU_ASIMDMISCFP16_R",
    "FCVTAU_ASISDMISC_R",
    "FCVTAU_ASISDMISCFP16_R",
    "FCVTL_ASIMDMISC_L",
    "FCVTMS_32D_FLOAT2INT",
    "FCVTMS_32H_FLOAT2INT",
    "FCVTMS_32S_FLOAT2INT",
    "FCVTMS_64D_FLOAT2INT",
    "FCVTMS_64H_FLOAT2INT",
    "FCVTMS_64S_FLOAT2INT",
    "FCVTMS_ASIMDMISC_R",
    "FCVTMS_ASIMDMISCFP16_R",
    "FCVTMS_ASISDMISC_R",
    "FCVTMS_ASISDMISCFP16_R",
    "FCVTMU_32D_FLOAT2INT",
    "FCVTMU_32H_FLOAT2INT",
    "FCVTMU_32S_FLOAT2INT",
    "FCVTMU_64D_FLOAT2INT",
    "FCVTMU_64H_FLOAT2INT",
    "FCVTMU_64S_FLOAT2INT",
    "FCVTMU_ASIMDMISC_R",
    "FCVTMU_ASIMDMISCFP16_R",
    "FCVTMU_ASISDMISC_R",
    "FCVTMU_ASISDMISCFP16_R",
    "FCVTNS_32D_FLOAT2INT",
    "FCVTNS_32H_FLOAT2INT",
    "FCVTNS_32S_FLOAT2INT",
    "FCVTNS_64D_FLOAT2INT",
    "FCVTNS_64H_FLOAT2INT",
    "FCVTNS_64S_FLOAT2INT",
    "FCVTNS_ASIMDMISC_R",
    "FCVTNS_ASIMDMISCFP16_R",
    "FCVTNS_ASISDMISC_R",
    "FCVTNS_ASISDMISCFP16_R",
    "FCVTNU_32D_FLOAT2INT",
    "FCVTNU_32H_FLOAT2INT",
    "FCVTNU_32S_FLOAT2INT",
    "FCVTNU_64D_FLOAT2INT",
    "FCVTNU_64H_FLOAT2INT",
    "FCVTNU_64S_FLOAT2INT",
    "FCVTNU_ASIMDMISC_R",
    "FCVTNU_ASIMDMISCFP16_R",
    "FCVTNU_ASISDMISC_R",
    "FCVTNU_ASISDMISCFP16_R",
    "FCVTN_ASIMDMISC_N",
    "FCVTPS_32D_FLOAT2INT",
    "FCVTPS_32H_FLOAT2INT",
    "FCVTPS_32S_FLOAT2INT",
    "FCVTPS_64D_FLOAT2INT",
    "FCVTPS_64H_FLOAT2INT",
    "FCVTPS_64S_FLOAT2INT",
    "FCVTPS_ASIMDMISC_R",
    "FCVTPS_ASIMDMISCFP16_R",
    "FCVTPS_ASISDMISC_R",
    "FCVTPS_ASISDMISCFP16_R",
    "FCVTPU_32D_FLOAT2INT",
    "FCVTPU_32H_FLOAT2INT",
    "FCVTPU_32S_FLOAT2INT",
    "FCVTPU_64D_FLOAT2INT",
    "FCVTPU_64H_FLOAT2INT",
    "FCVTPU_64S_FLOAT2INT",
    "FCVTPU_ASIMDMISC_R",
    "FCVTPU_ASIMDMISCFP16_R",
    "FCVTPU_ASISDMISC_R",
    "FCVTPU_ASISDMISCFP16_R",
    "FCVTXN_ASIMDMISC_N",
    "FCVTXN_ASISDMISC_N",
    "FCVTZS_32D_FLOAT2FIX",
    "FCVTZS_32D_FLOAT2INT",
    "FCVTZS_32H_FLOAT2FIX",
    "FCVTZS_32H_FLOAT2INT",
    "FCVTZS_32S_FLOAT2FIX",
    "FCVTZS_32S_FLOAT2INT",
    "FCVTZS_64D_FLOAT2FIX",
    "FCVTZS_64D_FLOAT2INT",
    "FCVTZS_64H_FLOAT2FIX",
    "FCVTZS_64H_FLOAT2INT",
    "FCVTZS_64S_FLOAT2FIX",
    "FCVTZS_64S_FLOAT2INT",
    "FCVTZS_ASIMDMISC_R",
    "FCVTZS_ASIMDMISCFP16_R",
    "FCVTZS_ASIMDSHF_C",
    "FCVTZS_ASISDMISC_R",
    "FCVTZS_ASISDMISCFP16_R",
    "FCVTZS_ASISDSHF_C",
    "FCVTZU_32D_FLOAT2FIX",
    "FCVTZU_32D_FLOAT2INT",
    "FCVTZU_32H_FLOAT2FIX",
    "FCVTZU_32H_FLOAT2INT",
    "FCVTZU_32S_FLOAT2FIX",
    "FCVTZU_32S_FLOAT2INT",
    "FCVTZU_64D_FLOAT2FIX",
    "FCVTZU_64D_FLOAT2INT",
    "FCVTZU_64H_FLOAT2FIX",
    "FCVTZU_64H_FLOAT2INT",
    "FCVTZU_64S_FLOAT2FIX",
    "FCVTZU_64S_FLOAT2INT",
    "FCVTZU_ASIMDMISC_R",
    "FCVTZU_ASIMDMISCFP16_R",
    "FCVTZU_ASIMDSHF_C",
    "FCVTZU_ASISDMISC_R",
    "FCVTZU_ASISDMISCFP16_R",
    "FCVTZU_ASISDSHF_C",
    "FCVT_DH_FLOATDP1",
    "FCVT_DS_FLOATDP1",
    "FCVT_HD_FLOATDP1",
    "FCVT_HS_FLOATDP1",
    "FCVT_SD_FLOATDP1",
    "FCVT_SH_FLOATDP1",
    "FDIV_D_FLOATDP2",
    "FDIV_H_FLOATDP2",
    "FDIV_S_FLOATDP2",
    "FDIV_ASIMDSAME_ONLY",
    "FDIV_ASIMDSAMEFP16_ONLY",
    "FMADD_D_FLOATDP3",
    "FMADD_H_FLOATDP3",
    "FMADD_S_FLOATDP3",
    "FMAXNMP_ASIMDSAME_ONLY",
    "FMAXNMP_ASIMDSAMEFP16_ONLY",
    "FMAXNMP_ASISDPAIR_ONLY_H",
    "FMAXNMP_ASISDPAIR_ONLY_SD",
    "FMAXNMV_ASIMDALL_ONLY_H",
    "FMAXNMV_ASIMDALL_ONLY_SD",
    "FMAXNM_D_FLOATDP2",
    "FMAXNM_H_FLOATDP2",
    "FMAXNM_S_FLOATDP2",
    "FMAXNM_ASIMDSAME_ONLY",
    "FMAXNM_ASIMDSAMEFP16_ONLY",
    "FMAXP_ASIMDSAME_ONLY",
    "FMAXP_ASIMDSAMEFP16_ONLY",
    "FMAXP_ASISDPAIR_ONLY_H",
    "FMAXP_ASISDPAIR_ONLY_SD",
    "FMAXV_ASIMDALL_ONLY_H",
    "FMAXV_ASIMDALL_ONLY_SD",
    "FMAX_D_FLOATDP2",
    "FMAX_H_FLOATDP2",
    "FMAX_S_FLOATDP2",
    "FMAX_ASIMDSAME_ONLY",
    "FMAX_ASIMDSAMEFP16_ONLY",
    "FMINNMP_ASIMDSAME_ONLY",
    "FMINNMP_ASIMDSAMEFP16_ONLY",
    "FMINNMP_ASISDPAIR_ONLY_H",
    "FMINNMP_ASISDPAIR_ONLY_SD",
    "FMINNMV_ASIMDALL_ONLY_H",
    "FMINNMV_ASIMDALL_ONLY_SD",
    "FMINNM_D_FLOATDP2",
    "FMINNM_H_FLOATDP2",
    "FMINNM_S_FLOATDP2",
    "FMINNM_ASIMDSAME_ONLY",
    "FMINNM_ASIMDSAMEFP16_ONLY",
    "FMINP_ASIMDSAME_ONLY",
    "FMINP_ASIMDSAMEFP16_ONLY",
    "FMINP_ASISDPAIR_ONLY_H",
    "FMINP_ASISDPAIR_ONLY_SD",
    "FMINV_ASIMDALL_ONLY_H",
    "FMINV_ASIMDALL_ONLY_SD",
    "FMIN_D_FLOATDP2",
    "FMIN_H_FLOATDP2",
    "FMIN_S_FLOATDP2",
    "FMIN_ASIMDSAME_ONLY",
    "FMIN_ASIMDSAMEFP16_ONLY",
    "FMLA_ASIMDELEM_RH_H",
    "FMLA_ASIMDELEM_R_SD",
    "FMLA_ASIMDSAME_ONLY",
    "FMLA_ASIMDSAMEFP16_ONLY",
    "FMLA_ASISDELEM_RH_H",
    "FMLA_ASISDELEM_R_SD",
    "FMLS_ASIMDELEM_RH_H",
    "FMLS_ASIMDELEM_R_SD",
    "FMLS_ASIMDSAME_ONLY",
    "FMLS_ASIMDSAMEFP16_ONLY",
    "FMLS_ASISDELEM_RH_H",
    "FMLS_ASISDELEM_R_SD",
    "FMOV_32H_FLOAT2INT",
    "FMOV_32S_FLOAT2INT",
    "FMOV_64D_FLOAT2INT",
    "FMOV_64H_FLOAT2INT",
    "FMOV_64VX_FLOAT2INT",
    "FMOV_D64_FLOAT2INT",
    "FMOV_D_FLOATDP1",
    "FMOV_D_FLOATIMM",
    "FMOV_H32_FLOAT2INT",
    "FMOV_H64_FLOAT2INT",
    "FMOV_H_FLOATDP1",
    "FMOV_H_FLOATIMM",
    "FMOV_S32_FLOAT2INT",
    "FMOV_S_FLOATDP1",
    "FMOV_S_FLOATIMM",
    "FMOV_V64I_FLOAT2INT",
    "FMOV_ASIMDIMM_D2_D",
    "FMOV_ASIMDIMM_H_H",
    "FMOV_ASIMDIMM_S_S",
    "FMSUB_D_FLOATDP3",
    "FMSUB_H_FLOATDP3",
    "FMSUB_S_FLOATDP3",
    "FMULX_ASIMDELEM_RH_H",
    "FMULX_ASIMDELEM_R_SD",
    "FMULX_ASIMDSAME_ONLY",
    "FMULX_ASIMDSAMEFP16_ONLY",
    "FMULX_ASISDELEM_RH_H",
    "FMULX_ASISDELEM_R_SD",
    "FMULX_ASISDSAME_ONLY",
    "FMULX_ASISDSAMEFP16_ONLY",
    "FMUL_D_FLOATDP2",
    "FMUL_H_FLOATDP2",
    "FMUL_S_FLOATDP2",
    "FMUL_ASIMDELEM_RH_H",
    "FMUL_ASIMDELEM_R_SD",
    "FMUL_ASIMDSAME_ONLY",
    "FMUL_ASIMDSAMEFP16_ONLY",
    "FMUL_ASISDELEM_RH_H",
    "FMUL_ASISDELEM_R_SD",
    "FNEG_D_FLOATDP1",
    "FNEG_H_FLOATDP1",
    "FNEG_S_FLOATDP1",
    "FNEG_ASIMDMISC_R",
    "FNEG_ASIMDMISCFP16_R",
    "FNMADD_D_FLOATDP3",
    "FNMADD_H_FLOATDP3",
    "FNMADD_S_FLOATDP3",
    "FNMSUB_D_FLOATDP3",
    "FNMSUB_H_FLOATDP3",
    "FNMSUB_S_FLOATDP3",
    "FNMUL_D_FLOATDP2",
    "FNMUL_H_FLOATDP2",
    "FNMUL_S_FLOATDP2",
    "FRECPE_ASIMDMISC_R",
    "FRECPE_ASIMDMISCFP16_R",
    "FRECPE_ASISDMISC_R",
    "FRECPE_ASISDMISCFP16_R",
    "FRECPS_ASIMDSAME_ONLY",
    "FRECPS_ASIMDSAMEFP16_ONLY",
    "FRECPS_ASISDSAME_ONLY",
    "FRECPS_ASISDSAMEFP16_ONLY",
    "FRECPX_ASISDMISC_R",
    "FRECPX_ASISDMISCFP16_R",
    "FRINTA_D_FLOATDP1",
    "FRINTA_H_FLOATDP1",
    "FRINTA_S_FLOATDP1",
    "FRINTA_ASIMDMISC_R",
    "FRINTA_ASIMDMISCFP16_R",
    "FRINTI_D_FLOATDP1",
    "FRINTI_H_FLOATDP1",
    "FRINTI_S_FLOATDP1",
    "FRINTI_ASIMDMISC_R",
    "FRINTI_ASIMDMISCFP16_R",
    "FRINTM_D_FLOATDP1",
    "FRINTM_H_FLOATDP1",
    "FRINTM_S_FLOATDP1",
    "FRINTM_ASIMDMISC_R",
    "FRINTM_ASIMDMISCFP16_R",
    "FRINTN_D_FLOATDP1",
    "FRINTN_H_FLOATDP1",
    "FRINTN_S_FLOATDP1",
    "FRINTN_ASIMDMISC_R",
    "FRINTN_ASIMDMISCFP16_R",
    "FRINTP_D_FLOATDP1",
    "FRINTP_H_FLOATDP1",
    "FRINTP_S_FLOATDP1",
    "FRINTP_ASIMDMISC_R",
    "FRINTP_ASIMDMISCFP16_R",
    "FRINTX_D_FLOATDP1",
    "FRINTX_H_FLOATDP1",
    "FRINTX_S_FLOATDP1",
    "FRINTX_ASIMDMISC_R",
    "FRINTX_ASIMDMISCFP16_R",
    "FRINTZ_D_FLOATDP1",
    "FRINTZ_H_FLOATDP1",
    "FRINTZ_S_FLOATDP1",
    "FRINTZ_ASIMDMISC_R",
    "FRINTZ_ASIMDMISCFP16_R",
    "FRSQRTE_ASIMDMISC_R",
    "FRSQRTE_ASIMDMISCFP16_R",
    "FRSQRTE_ASISDMISC_R",
    "FRSQRTE_ASISDMISCFP16_R",
    "FRSQRTS_ASIMDSAME_ONLY",
    "FRSQRTS_ASIMDSAMEFP16_ONLY",
    "FRSQRTS_ASISDSAME_ONLY",
    "FRSQRTS_ASISDSAMEFP16_ONLY",
    "FSQRT_D_FLOATDP1",
    "FSQRT_H_FLOATDP1",
    "FSQRT_S_FLOATDP1",
    "FSQRT_ASIMDMISC_R",
    "FSQRT_ASIMDMISCFP16_R",
    "FSUB_D_FLOATDP2",
    "FSUB_H_FLOATDP2",
    "FSUB_S_FLOATDP2",
    "FSUB_ASIMDSAME_ONLY",
    "FSUB_ASIMDSAMEFP16_ONLY",
    "HINT_1",
    "HINT_2",
    "HINT_3",
    "HLT_EX_EXCEPTION",
    "HVC_EX_EXCEPTION",
    "IC_SYS_CR_SYSTEM",
    "INS_ASIMDINS_IR_R",
    "INS_ASIMDINS_IV_V",
    "ISB_BI_SYSTEM",
    "LD1R_ASISDLSO_R1",
    "LD1R_ASISDLSOP_R1_I",
    "LD1R_ASISDLSOP_RX1_R",
    "LD1_ASISDLSE_R1_1V",
    "LD1_ASISDLSE_R2_2V",
    "LD1_ASISDLSE_R3_3V",
    "LD1_ASISDLSE_R4_4V",
    "LD1_ASISDLSEP_I1_I1",
    "LD1_ASISDLSEP_I2_I2",
    "LD1_ASISDLSEP_I3_I3",
    "LD1_ASISDLSEP_I4_I4",
    "LD1_ASISDLSEP_R1_R1",
    "LD1_ASISDLSEP_R2_R2",
    "LD1_ASISDLSEP_R3_R3",
    "LD1_ASISDLSEP_R4_R4",
    "LD1_ASISDLSO_B1_1B",
    "LD1_ASISDLSO_D1_1D",
    "LD1_ASISDLSO_H1_1H",
    "LD1_ASISDLSO_S1_1S",
    "LD1_ASISDLSOP_B1_I1B",
    "LD1_ASISDLSOP_BX1_R1B",
    "LD1_ASISDLSOP_D1_I1D",
    "LD1_ASISDLSOP_DX1_R1D",
    "LD1_ASISDLSOP_H1_I1H",
    "LD1_ASISDLSOP_HX1_R1H",
    "LD1_ASISDLSOP_S1_I1S",
    "LD1_ASISDLSOP_SX1_R1S",
    "LD2R_ASISDLSO_R2",
    "LD2R_ASISDLSOP_R2_I",
    "LD2R_ASISDLSOP_RX2_R",
    "LD2_ASISDLSE_R2",
    "LD2_ASISDLSEP_I2_I",
    "LD2_ASISDLSEP_R2_R",
    "LD2_ASISDLSO_B2_2B",
    "LD2_ASISDLSO_D2_2D",
    "LD2_ASISDLSO_H2_2H",
    "LD2_ASISDLSO_S2_2S",
    "LD2_ASISDLSOP_B2_I2B",
    "LD2_ASISDLSOP_BX2_R2B",
    "LD2_ASISDLSOP_D2_I2D",
    "LD2_ASISDLSOP_DX2_R2D",
    "LD2_ASISDLSOP_H2_I2H",
    "LD2_ASISDLSOP_HX2_R2H",
    "LD2_ASISDLSOP_S2_I2S",
    "LD2_ASISDLSOP_SX2_R2S",
    "LD3R_ASISDLSO_R3",
    "LD3R_ASISDLSOP_R3_I",
    "LD3R_ASISDLSOP_RX3_R",
    "LD3_ASISDLSE_R3",
    "LD3_ASISDLSEP_I3_I",
    "LD3_ASISDLSEP_R3_R",
    "LD3_ASISDLSO_B3_3B",
    "LD3_ASISDLSO_D3_3D",
    "LD3_ASISDLSO_H3_3H",
    "LD3_ASISDLSO_S3_3S",
    "LD3_ASISDLSOP_B3_I3B",
    "LD3_ASISDLSOP_BX3_R3B",
    "LD3_ASISDLSOP_D3_I3D",
    "LD3_ASISDLSOP_DX3_R3D",
    "LD3_ASISDLSOP_H3_I3H",
    "LD3_ASISDLSOP_HX3_R3H",
    "LD3_ASISDLSOP_S3_I3S",
    "LD3_ASISDLSOP_SX3_R3S",
    "LD4R_ASISDLSO_R4",
    "LD4R_ASISDLSOP_R4_I",
    "LD4R_ASISDLSOP_RX4_R",
    "LD4_ASISDLSE_R4",
    "LD4_ASISDLSEP_I4_I",
    "LD4_ASISDLSEP_R4_R",
    "LD4_ASISDLSO_B4_4B",
    "LD4_ASISDLSO_D4_4D",
    "LD4_ASISDLSO_H4_4H",
    "LD4_ASISDLSO_S4_4S",
    "LD4_ASISDLSOP_B4_I4B",
    "LD4_ASISDLSOP_BX4_R4B",
    "LD4_ASISDLSOP_D4_I4D",
    "LD4_ASISDLSOP_DX4_R4D",
    "LD4_ASISDLSOP_H4_I4H",
    "LD4_ASISDLSOP_HX4_R4H",
    "LD4_ASISDLSOP_S4_I4S",
    "LD4_ASISDLSOP_SX4_R4S",
    "LDADDAB_32_MEMOP",
    "LDADDAH_32_MEMOP",
    "LDADDALB_32_MEMOP",
    "LDADDALH_32_MEMOP",
    "LDADDAL_32_MEMOP",
    "LDADDAL_64_MEMOP",
    "LDADDA_32_MEMOP",
    "LDADDA_64_MEMOP",
    "LDADDB_32_MEMOP",
    "LDADDH_32_MEMOP",
    "LDADDLB_32_MEMOP",
    "LDADDLH_32_MEMOP",
    "LDADDL_32_MEMOP",
    "LDADDL_64_MEMOP",
    "LDADD_32_MEMOP",
    "LDADD_64_MEMOP",
    "LDARB_LR32_LDSTEXCL",
    "LDARH_LR32_LDSTEXCL",
    "LDAR_LR32_LDSTEXCL",
    "LDAR_LR64_LDSTEXCL",
    "LDAXP_LP32_LDSTEXCL",
    "LDAXP_LP64_LDSTEXCL",
    "LDAXRB_LR32_LDSTEXCL",
    "LDAXRH_LR32_LDSTEXCL",
    "LDAXR_LR32_LDSTEXCL",
    "LDAXR_LR64_LDSTEXCL",
    "LDCLRAB_32_MEMOP",
    "LDCLRAH_32_MEMOP",
    "LDCLRALB_32_MEMOP",
    "LDCLRALH_32_MEMOP",
    "LDCLRAL_32_MEMOP",
    "LDCLRAL_64_MEMOP",
    "LDCLRA_32_MEMOP",
    "LDCLRA_64_MEMOP",
    "LDCLRB_32_MEMOP",
    "LDCLRH_32_MEMOP",
    "LDCLRLB_32_MEMOP",
    "LDCLRLH_32_MEMOP",
    "LDCLRL_32_MEMOP",
    "LDCLRL_64_MEMOP",
    "LDCLR_32_MEMOP",
    "LDCLR_64_MEMOP",
    "LDEORAB_32_MEMOP",
    "LDEORAH_32_MEMOP",
    "LDEORALB_32_MEMOP",
    "LDEORALH_32_MEMOP",
    "LDEORAL_32_MEMOP",
    "LDEORAL_64_MEMOP",
    "LDEORA_32_MEMOP",
    "LDEORA_64_MEMOP",
    "LDEORB_32_MEMOP",
    "LDEORH_32_MEMOP",
    "LDEORLB_32_MEMOP",
    "LDEORLH_32_MEMOP",
    "LDEORL_32_MEMOP",
    "LDEORL_64_MEMOP",
    "LDEOR_32_MEMOP",
    "LDEOR_64_MEMOP",
    "LDLARB_LR32_LDSTEXCL",
    "LDLARH_LR32_LDSTEXCL",
    "LDLAR_LR32_LDSTEXCL",
    "LDLAR_LR64_LDSTEXCL",
    "LDNP_32_LDSTNAPAIR_OFFS",
    "LDNP_64_LDSTNAPAIR_OFFS",
    "LDNP_D_LDSTNAPAIR_OFFS",
    "LDNP_Q_LDSTNAPAIR_OFFS",
    "LDNP_S_LDSTNAPAIR_OFFS",
    "LDPSW_64_LDSTPAIR_OFF",
    "LDPSW_64_LDSTPAIR_POST",
    "LDPSW_64_LDSTPAIR_PRE",
    "LDP_32_LDSTPAIR_OFF",
    "LDP_32_LDSTPAIR_POST",
    "LDP_32_LDSTPAIR_PRE",
    "LDP_64_LDSTPAIR_OFF",
    "LDP_64_LDSTPAIR_POST",
    "LDP_64_LDSTPAIR_PRE",
    "LDP_D_LDSTPAIR_OFF",
    "LDP_D_LDSTPAIR_POST",
    "LDP_D_LDSTPAIR_PRE",
    "LDP_Q_LDSTPAIR_OFF",
    "LDP_Q_LDSTPAIR_POST",
    "LDP_Q_LDSTPAIR_PRE",
    "LDP_S_LDSTPAIR_OFF",
    "LDP_S_LDSTPAIR_POST",
    "LDP_S_LDSTPAIR_PRE",
    "LDRB_32BL_LDST_REGOFF",
    "LDRB_32B_LDST_REGOFF",
    "LDRB_32_LDST_IMMPOST",
    "LDRB_32_LDST_IMMPRE",
    "LDRB_32_LDST_POS",
    "LDRH_32_LDST_IMMPOST",
    "LDRH_32_LDST_IMMPRE",
    "LDRH_32_LDST_POS",
    "LDRH_32_LDST_REGOFF",
    "LDRSB_32BL_LDST_REGOFF",
    "LDRSB_32B_LDST_REGOFF",
    "LDRSB_32_LDST_IMMPOST",
    "LDRSB_32_LDST_IMMPRE",
    "LDRSB_32_LDST_POS",
    "LDRSB_64BL_LDST_REGOFF",
    "LDRSB_64B_LDST_REGOFF",
    "LDRSB_64_LDST_IMMPOST",
    "LDRSB_64_LDST_IMMPRE",
    "LDRSB_64_LDST_POS",
    "LDRSH_32_LDST_IMMPOST",
    "LDRSH_32_LDST_IMMPRE",
    "LDRSH_32_LDST_POS",
    "LDRSH_32_LDST_REGOFF",
    "LDRSH_64_LDST_IMMPOST",
    "LDRSH_64_LDST_IMMPRE",
    "LDRSH_64_LDST_POS",
    "LDRSH_64_LDST_REGOFF",
    "LDRSW_64_LDST_IMMPOST",
    "LDRSW_64_LDST_IMMPRE",
    "LDRSW_64_LDST_POS",
    "LDRSW_64_LDST_REGOFF",
    "LDRSW_64_LOADLIT",
    "LDR_32_LDST_IMMPOST",
    "LDR_32_LDST_IMMPRE",
    "LDR_32_LDST_POS",
    "LDR_32_LDST_REGOFF",
    "LDR_32_LOADLIT",
    "LDR_64_LDST_IMMPOST",
    "LDR_64_LDST_IMMPRE",
    "LDR_64_LDST_POS",
    "LDR_64_LDST_REGOFF",
    "LDR_64_LOADLIT",
    "LDR_BL_LDST_REGOFF",
    "LDR_B_LDST_IMMPOST",
    "LDR_B_LDST_IMMPRE",
    "LDR_B_LDST_POS",
    "LDR_B_LDST_REGOFF",
    "LDR_D_LDST_IMMPOST",
    "LDR_D_LDST_IMMPRE",
    "LDR_D_LDST_POS",
    "LDR_D_LDST_REGOFF",
    "LDR_D_LOADLIT",
    "LDR_H_LDST_IMMPOST",
    "LDR_H_LDST_IMMPRE",
    "LDR_H_LDST_POS",
    "LDR_H_LDST_REGOFF",
    "LDR_Q_LDST_IMMPOST",
    "LDR_Q_LDST_IMMPRE",
    "LDR_Q_LDST_POS",
    "LDR_Q_LDST_REGOFF",
    "LDR_Q_LOADLIT",
    "LDR_S_LDST_IMMPOST",
    "LDR_S_LDST_IMMPRE",
    "LDR_S_LDST_POS",
    "LDR_S_LDST_REGOFF",
    "LDR_S_LOADLIT",
    "LDSETAB_32_MEMOP",
    "LDSETAH_32_MEMOP",
    "LDSETALB_32_MEMOP",
    "LDSETALH_32_MEMOP",
    "LDSETAL_32_MEMOP",
    "LDSETAL_64_MEMOP",
    "LDSETA_32_MEMOP",
    "LDSETA_64_MEMOP",
    "LDSETB_32_MEMOP",
    "LDSETH_32_MEMOP",
    "LDSETLB_32_MEMOP",
    "LDSETLH_32_MEMOP",
    "LDSETL_32_MEMOP",
    "LDSETL_64_MEMOP",
    "LDSET_32_MEMOP",
    "LDSET_64_MEMOP",
    "LDSMAXAB_32_MEMOP",
    "LDSMAXAH_32_MEMOP",
    "LDSMAXALB_32_MEMOP",
    "LDSMAXALH_32_MEMOP",
    "LDSMAXAL_32_MEMOP",
    "LDSMAXAL_64_MEMOP",
    "LDSMAXA_32_MEMOP",
    "LDSMAXA_64_MEMOP",
    "LDSMAXB_32_MEMOP",
    "LDSMAXH_32_MEMOP",
    "LDSMAXLB_32_MEMOP",
    "LDSMAXLH_32_MEMOP",
    "LDSMAXL_32_MEMOP",
    "LDSMAXL_64_MEMOP",
    "LDSMAX_32_MEMOP",
    "LDSMAX_64_MEMOP",
    "LDSMINAB_32_MEMOP",
    "LDSMINAH_32_MEMOP",
    "LDSMINALB_32_MEMOP",
    "LDSMINALH_32_MEMOP",
    "LDSMINAL_32_MEMOP",
    "LDSMINAL_64_MEMOP",
    "LDSMINA_32_MEMOP",
    "LDSMINA_64_MEMOP",
    "LDSMINB_32_MEMOP",
    "LDSMINH_32_MEMOP",
    "LDSMINLB_32_MEMOP",
    "LDSMINLH_32_MEMOP",
    "LDSMINL_32_MEMOP",
    "LDSMINL_64_MEMOP",
    "LDSMIN_32_MEMOP",
    "LDSMIN_64_MEMOP",
    "LDTRB_32_LDST_UNPRIV",
    "LDTRH_32_LDST_UNPRIV",
    "LDTRSB_32_LDST_UNPRIV",
    "LDTRSB_64_LDST_UNPRIV",
    "LDTRSH_32_LDST_UNPRIV",
    "LDTRSH_64_LDST_UNPRIV",
    "LDTRSW_64_LDST_UNPRIV",
    "LDTR_32_LDST_UNPRIV",
    "LDTR_64_LDST_UNPRIV",
    "LDUMAXAB_32_MEMOP",
    "LDUMAXAH_32_MEMOP",
    "LDUMAXALB_32_MEMOP",
    "LDUMAXALH_32_MEMOP",
    "LDUMAXAL_32_MEMOP",
    "LDUMAXAL_64_MEMOP",
    "LDUMAXA_32_MEMOP",
    "LDUMAXA_64_MEMOP",
    "LDUMAXB_32_MEMOP",
    "LDUMAXH_32_MEMOP",
    "LDUMAXLB_32_MEMOP",
    "LDUMAXLH_32_MEMOP",
    "LDUMAXL_32_MEMOP",
    "LDUMAXL_64_MEMOP",
    "LDUMAX_32_MEMOP",
    "LDUMAX_64_MEMOP",
    "LDUMINAB_32_MEMOP",
    "LDUMINAH_32_MEMOP",
    "LDUMINALB_32_MEMOP",
    "LDUMINALH_32_MEMOP",
    "LDUMINAL_32_MEMOP",
    "LDUMINAL_64_MEMOP",
    "LDUMINA_32_MEMOP",
    "LDUMINA_64_MEMOP",
    "LDUMINB_32_MEMOP",
    "LDUMINH_32_MEMOP",
    "LDUMINLB_32_MEMOP",
    "LDUMINLH_32_MEMOP",
    "LDUMINL_32_MEMOP",
    "LDUMINL_64_MEMOP",
    "LDUMIN_32_MEMOP",
    "LDUMIN_64_MEMOP",
    "LDURB_32_LDST_UNSCALED",
    "LDURH_32_LDST_UNSCALED",
    "LDURSB_32_LDST_UNSCALED",
    "LDURSB_64_LDST_UNSCALED",
    "LDURSH_32_LDST_UNSCALED",
    "LDURSH_64_LDST_UNSCALED",
    "LDURSW_64_LDST_UNSCALED",
    "LDUR_32_LDST_UNSCALED",
    "LDUR_64_LDST_UNSCALED",
    "LDUR_B_LDST_UNSCALED",
    "LDUR_D_LDST_UNSCALED",
    "LDUR_H_LDST_UNSCALED",
    "LDUR_Q_LDST_UNSCALED",
    "LDUR_S_LDST_UNSCALED",
    "LDXP_LP32_LDSTEXCL",
    "LDXP_LP64_LDSTEXCL",
    "LDXRB_LR32_LDSTEXCL",
    "LDXRH_LR32_LDSTEXCL",
    "LDXR_LR32_LDSTEXCL",
    "LDXR_LR64_LDSTEXCL",
    "LSLV_32_DP_2SRC",
    "LSLV_64_DP_2SRC",
    "LSL_LSLV_32_DP_2SRC",
    "LSL_LSLV_64_DP_2SRC",
    "LSL_UBFM_32M_BITFIELD",
    "LSL_UBFM_64M_BITFIELD",
    "LSRV_32_DP_2SRC",
    "LSRV_64_DP_2SRC",
    "LSR_LSRV_32_DP_2SRC",
    "LSR_LSRV_64_DP_2SRC",
    "LSR_UBFM_32M_BITFIELD",
    "LSR_UBFM_64M_BITFIELD",
    "MADD_32A_DP_3SRC",
    "MADD_64A_DP_3SRC",
    "MLA_ASIMDELEM_R",
    "MLA_ASIMDSAME_ONLY",
    "MLS_ASIMDELEM_R",
    "MLS_ASIMDSAME_ONLY",
    "MNEG_MSUB_32A_DP_3SRC",
    "MNEG_MSUB_64A_DP_3SRC",
    "MOVI_ASIMDIMM_D2_D",
    "MOVI_ASIMDIMM_D_DS",
    "MOVI_ASIMDIMM_L_HL",
    "MOVI_ASIMDIMM_L_SL",
    "MOVI_ASIMDIMM_M_SM",
    "MOVI_ASIMDIMM_N_B",
    "MOVK_32_MOVEWIDE",
    "MOVK_64_MOVEWIDE",
    "MOVN_32_MOVEWIDE",
    "MOVN_64_MOVEWIDE",
    "MOVZ_32_MOVEWIDE",
    "MOVZ_64_MOVEWIDE",
    "MOV_ADD_32_ADDSUB_IMM",
    "MOV_ADD_64_ADDSUB_IMM",
    "MOV_DUP_ASISDONE_ONLY",
    "MOV_INS_ASIMDINS_IR_R",
    "MOV_INS_ASIMDINS_IV_V",
    "MOV_MOVN_32_MOVEWIDE",
    "MOV_MOVN_64_MOVEWIDE",
    "MOV_MOVZ_32_MOVEWIDE",
    "MOV_MOVZ_64_MOVEWIDE",
    "MOV_ORR_32_LOG_IMM",
    "MOV_ORR_32_LOG_SHIFT",
    "MOV_ORR_64_LOG_IMM",
    "MOV_ORR_64_LOG_SHIFT",
    "MOV_ORR_ASIMDSAME_ONLY",
    "MOV_UMOV_ASIMDINS_W_W",
    "MOV_UMOV_ASIMDINS_X_X",
    "MRS_RS_SYSTEM",
    "MSR_SI_SYSTEM",
    "MSR_SR_SYSTEM",
    "MSUB_32A_DP_3SRC",
    "MSUB_64A_DP_3SRC",
    "MUL_MADD_32A_DP_3SRC",
    "MUL_MADD_64A_DP_3SRC",
    "MUL_ASIMDELEM_R",
    "MUL_ASIMDSAME_ONLY",
    "MVNI_ASIMDIMM_L_HL",
    "MVNI_ASIMDIMM_L_SL",
    "MVNI_ASIMDIMM_M_SM",
    "MVN_NOT_ASIMDMISC_R",
    "MVN_ORN_32_LOG_SHIFT",
    "MVN_ORN_64_LOG_SHIFT",
    "NEGS_SUBS_32_ADDSUB_SHIFT",
    "NEGS_SUBS_64_ADDSUB_SHIFT",
    "NEG_SUB_32_ADDSUB_SHIFT",
    "NEG_SUB_64_ADDSUB_SHIFT",
    "NEG_ASIMDMISC_R",
    "NEG_ASISDMISC_R",
    "NGCS_SBCS_32_ADDSUB_CARRY",
    "NGCS_SBCS_64_ADDSUB_CARRY",
    "NGC_SBC_32_ADDSUB_CARRY",
    "NGC_SBC_64_ADDSUB_CARRY",
    "NOP_HI_SYSTEM",
    "NOT_ASIMDMISC_R",
    "ORN_32_LOG_SHIFT",
    "ORN_64_LOG_SHIFT",
    "ORN_ASIMDSAME_ONLY",
    "ORR_32_LOG_IMM",
    "ORR_32_LOG_SHIFT",
    "ORR_64_LOG_IMM",
    "ORR_64_LOG_SHIFT",
    "ORR_ASIMDIMM_L_HL",
    "ORR_ASIMDIMM_L_SL",
    "ORR_ASIMDSAME_ONLY",
    "PMULL_ASIMDDIFF_L",
    "PMUL_ASIMDSAME_ONLY",
    "PRFM_P_LDST_POS",
    "PRFM_P_LDST_REGOFF",
    "PRFM_P_LOADLIT",
    "PRFUM_P_LDST_UNSCALED",
    "PSB_HC_SYSTEM",
    "RADDHN_ASIMDDIFF_N",
    "RBIT_32_DP_1SRC",
    "RBIT_64_DP_1SRC",
    "RBIT_ASIMDMISC_R",
    "RET_64R_BRANCH_REG",
    "REV16_32_DP_1SRC",
    "REV16_64_DP_1SRC",
    "REV16_ASIMDMISC_R",
    "REV32_64_DP_1SRC",
    "REV32_ASIMDMISC_R",
    "REV64_REV_64_DP_1SRC",
    "REV64_ASIMDMISC_R",
    "REV_32_DP_1SRC",
    "REV_64_DP_1SRC",
    "RORV_32_DP_2SRC",
    "RORV_64_DP_2SRC",
    "ROR_EXTR_32_EXTRACT",
    "ROR_EXTR_64_EXTRACT",
    "ROR_RORV_32_DP_2SRC",
    "ROR_RORV_64_DP_2SRC",
    "RSHRN_ASIMDSHF_N",
    "RSUBHN_ASIMDDIFF_N",
    "SABAL_ASIMDDIFF_L",
    "SABA_ASIMDSAME_ONLY",
    "SABDL_ASIMDDIFF_L",
    "SABD_ASIMDSAME_ONLY",
    "SADALP_ASIMDMISC_P",
    "SADDLP_ASIMDMISC_P",
    "SADDLV_ASIMDALL_ONLY",
    "SADDL_ASIMDDIFF_L",
    "SADDW_ASIMDDIFF_W",
    "SBCS_32_ADDSUB_CARRY",
    "SBCS_64_ADDSUB_CARRY",
    "SBC_32_ADDSUB_CARRY",
    "SBC_64_ADDSUB_CARRY",
    "SBFIZ_SBFM_32M_BITFIELD",
    "SBFIZ_SBFM_64M_BITFIELD",
    "SBFM_32M_BITFIELD",
    "SBFM_64M_BITFIELD",
    "SBFX_SBFM_32M_BITFIELD",
    "SBFX_SBFM_64M_BITFIELD",
    "SCVTF_D32_FLOAT2FIX",
    "SCVTF_D32_FLOAT2INT",
    "SCVTF_D64_FLOAT2FIX",
    "SCVTF_D64_FLOAT2INT",
    "SCVTF_H32_FLOAT2FIX",
    "SCVTF_H32_FLOAT2INT",
    "SCVTF_H64_FLOAT2FIX",
    "SCVTF_H64_FLOAT2INT",
    "SCVTF_S32_FLOAT2FIX",
    "SCVTF_S32_FLOAT2INT",
    "SCVTF_S64_FLOAT2FIX",
    "SCVTF_S64_FLOAT2INT",
    "SCVTF_ASIMDMISC_R",
    "SCVTF_ASIMDMISCFP16_R",
    "SCVTF_ASIMDSHF_C",
    "SCVTF_ASISDMISC_R",
    "SCVTF_ASISDMISCFP16_R",
    "SCVTF_ASISDSHF_C",
    "SDIV_32_DP_2SRC",
    "SDIV_64_DP_2SRC",
    "SEVL_HI_SYSTEM",
    "SEV_HI_SYSTEM",
    "SHA1C_QSV_CRYPTOSHA3",
    "SHA1H_SS_CRYPTOSHA2",
    "SHA1M_QSV_CRYPTOSHA3",
    "SHA1P_QSV_CRYPTOSHA3",
    "SHA1SU0_VVV_CRYPTOSHA3",
    "SHA1SU1_VV_CRYPTOSHA2",
    "SHA256H2_QQV_CRYPTOSHA3",
    "SHA256H_QQV_CRYPTOSHA3",
    "SHA256SU0_VV_CRYPTOSHA2",
    "SHA256SU1_VVV_CRYPTOSHA3",
    "SHADD_ASIMDSAME_ONLY",
    "SHLL_ASIMDMISC_S",
    "SHL_ASIMDSHF_R",
    "SHL_ASISDSHF_R",
    "SHRN_ASIMDSHF_N",
    "SHSUB_ASIMDSAME_ONLY",
    "SLI_ASIMDSHF_R",
    "SLI_ASISDSHF_R",
    "SMADDL_64WA_DP_3SRC",
    "SMAXP_ASIMDSAME_ONLY",
    "SMAXV_ASIMDALL_ONLY",
    "SMAX_ASIMDSAME_ONLY",
    "SMC_EX_EXCEPTION",
    "SMINP_ASIMDSAME_ONLY",
    "SMINV_ASIMDALL_ONLY",
    "SMIN_ASIMDSAME_ONLY",
    "SMLAL_ASIMDDIFF_L",
    "SMLAL_ASIMDELEM_L",
    "SMLSL_ASIMDDIFF_L",
    "SMLSL_ASIMDELEM_L",
    "SMNEGL_SMSUBL_64WA_DP_3SRC",
    "SMOV_ASIMDINS_W_W",
    "SMOV_ASIMDINS_X_X",
    "SMSUBL_64WA_DP_3SRC",
    "SMULH_64_DP_3SRC",
    "SMULL_SMADDL_64WA_DP_3SRC",
    "SMULL_ASIMDDIFF_L",
    "SMULL_ASIMDELEM_L",
    "SQABS_ASIMDMISC_R",
    "SQABS_ASISDMISC_R",
    "SQADD_ASIMDSAME_ONLY",
    "SQADD_ASISDSAME_ONLY",
    "SQDMLAL_ASIMDDIFF_L",
    "SQDMLAL_ASIMDELEM_L",
    "SQDMLAL_ASISDDIFF_ONLY",
    "SQDMLAL_ASISDELEM_L",
    "SQDMLSL_ASIMDDIFF_L",
    "SQDMLSL_ASIMDELEM_L",
    "SQDMLSL_ASISDDIFF_ONLY",
    "SQDMLSL_ASISDELEM_L",
    "SQDMULH_ASIMDELEM_R",
    "SQDMULH_ASIMDSAME_ONLY",
    "SQDMULH_ASISDELEM_R",
    "SQDMULH_ASISDSAME_ONLY",
    "SQDMULL_ASIMDDIFF_L",
    "SQDMULL_ASIMDELEM_L",
    "SQDMULL_ASISDDIFF_ONLY",
    "SQDMULL_ASISDELEM_L",
    "SQNEG_ASIMDMISC_R",
    "SQNEG_ASISDMISC_R",
    "SQRDMLAH_ASIMDELEM_R",
    "SQRDMLAH_ASIMDSAME2_ONLY",
    "SQRDMLAH_ASISDELEM_R",
    "SQRDMLAH_ASISDSAME2_ONLY",
    "SQRDMLSH_ASIMDELEM_R",
    "SQRDMLSH_ASIMDSAME2_ONLY",
    "SQRDMLSH_ASISDELEM_R",
    "SQRDMLSH_ASISDSAME2_ONLY",
    "SQRDMULH_ASIMDELEM_R",
    "SQRDMULH_ASIMDSAME_ONLY",
    "SQRDMULH_ASISDELEM_R",
    "SQRDMULH_ASISDSAME_ONLY",
    "SQRSHL_ASIMDSAME_ONLY",
    "SQRSHL_ASISDSAME_ONLY",
    "SQRSHRN_ASIMDSHF_N",
    "SQRSHRN_ASISDSHF_N",
    "SQRSHRUN_ASIMDSHF_N",
    "SQRSHRUN_ASISDSHF_N",
    "SQSHLU_ASIMDSHF_R",
    "SQSHLU_ASISDSHF_R",
    "SQSHL_ASIMDSAME_ONLY",
    "SQSHL_ASIMDSHF_R",
    "SQSHL_ASISDSAME_ONLY",
    "SQSHL_ASISDSHF_R",
    "SQSHRN_ASIMDSHF_N",
    "SQSHRN_ASISDSHF_N",
    "SQSHRUN_ASIMDSHF_N",
    "SQSHRUN_ASISDSHF_N",
    "SQSUB_ASIMDSAME_ONLY",
    "SQSUB_ASISDSAME_ONLY",
    "SQXTN_ASIMDMISC_N",
    "SQXTN_ASISDMISC_N",
    "SQXTUN_ASIMDMISC_N",
    "SQXTUN_ASISDMISC_N",
    "SRHADD_ASIMDSAME_ONLY",
    "SRI_ASIMDSHF_R",
    "SRI_ASISDSHF_R",
    "SRSHL_ASIMDSAME_ONLY",
    "SRSHL_ASISDSAME_ONLY",
    "SRSHR_ASIMDSHF_R",
    "SRSHR_ASISDSHF_R",
    "SRSRA_ASIMDSHF_R",
    "SRSRA_ASISDSHF_R",
    "SSHLL_ASIMDSHF_L",
    "SSHL_ASIMDSAME_ONLY",
    "SSHL_ASISDSAME_ONLY",
    "SSHR_ASIMDSHF_R",
    "SSHR_ASISDSHF_R",
    "SSRA_ASIMDSHF_R",
    "SSRA_ASISDSHF_R",
    "SSUBL_ASIMDDIFF_L",
    "SSUBW_ASIMDDIFF_W",
    "ST1_ASISDLSE_R1_1V",
    "ST1_ASISDLSE_R2_2V",
    "ST1_ASISDLSE_R3_3V",
    "ST1_ASISDLSE_R4_4V",
    "ST1_ASISDLSEP_I1_I1",
    "ST1_ASISDLSEP_I2_I2",
    "ST1_ASISDLSEP_I3_I3",
    "ST1_ASISDLSEP_I4_I4",
    "ST1_ASISDLSEP_R1_R1",
    "ST1_ASISDLSEP_R2_R2",
    "ST1_ASISDLSEP_R3_R3",
    "ST1_ASISDLSEP_R4_R4",
    "ST1_ASISDLSO_B1_1B",
    "ST1_ASISDLSO_D1_1D",
    "ST1_ASISDLSO_H1_1H",
    "ST1_ASISDLSO_S1_1S",
    "ST1_ASISDLSOP_B1_I1B",
    "ST1_ASISDLSOP_BX1_R1B",
    "ST1_ASISDLSOP_D1_I1D",
    "ST1_ASISDLSOP_DX1_R1D",
    "ST1_ASISDLSOP_H1_I1H",
    "ST1_ASISDLSOP_HX1_R1H",
    "ST1_ASISDLSOP_S1_I1S",
    "ST1_ASISDLSOP_SX1_R1S",
    "ST2_ASISDLSE_R2",
    "ST2_ASISDLSEP_I2_I",
    "ST2_ASISDLSEP_R2_R",
    "ST2_ASISDLSO_B2_2B",
    "ST2_ASISDLSO_D2_2D",
    "ST2_ASISDLSO_H2_2H",
    "ST2_ASISDLSO_S2_2S",
    "ST2_ASISDLSOP_B2_I2B",
    "ST2_ASISDLSOP_BX2_R2B",
    "ST2_ASISDLSOP_D2_I2D",
    "ST2_ASISDLSOP_DX2_R2D",
    "ST2_ASISDLSOP_H2_I2H",
    "ST2_ASISDLSOP_HX2_R2H",
    "ST2_ASISDLSOP_S2_I2S",
    "ST2_ASISDLSOP_SX2_R2S",
    "ST3_ASISDLSE_R3",
    "ST3_ASISDLSEP_I3_I",
    "ST3_ASISDLSEP_R3_R",
    "ST3_ASISDLSO_B3_3B",
    "ST3_ASISDLSO_D3_3D",
    "ST3_ASISDLSO_H3_3H",
    "ST3_ASISDLSO_S3_3S",
    "ST3_ASISDLSOP_B3_I3B",
    "ST3_ASISDLSOP_BX3_R3B",
    "ST3_ASISDLSOP_D3_I3D",
    "ST3_ASISDLSOP_DX3_R3D",
    "ST3_ASISDLSOP_H3_I3H",
    "ST3_ASISDLSOP_HX3_R3H",
    "ST3_ASISDLSOP_S3_I3S",
    "ST3_ASISDLSOP_SX3_R3S",
    "ST4_ASISDLSE_R4",
    "ST4_ASISDLSEP_I4_I",
    "ST4_ASISDLSEP_R4_R",
    "ST4_ASISDLSO_B4_4B",
    "ST4_ASISDLSO_D4_4D",
    "ST4_ASISDLSO_H4_4H",
    "ST4_ASISDLSO_S4_4S",
    "ST4_ASISDLSOP_B4_I4B",
    "ST4_ASISDLSOP_BX4_R4B",
    "ST4_ASISDLSOP_D4_I4D",
    "ST4_ASISDLSOP_DX4_R4D",
    "ST4_ASISDLSOP_H4_I4H",
    "ST4_ASISDLSOP_HX4_R4H",
    "ST4_ASISDLSOP_S4_I4S",
    "ST4_ASISDLSOP_SX4_R4S",
    "STADDB_32S_MEMOP",
    "STADDH_32S_MEMOP",
    "STADDLB_32S_MEMOP",
    "STADDLH_32S_MEMOP",
    "STADDL_32S_MEMOP",
    "STADDL_64S_MEMOP",
    "STADD_32S_MEMOP",
    "STADD_64S_MEMOP",
    "STCLRB_32S_MEMOP",
    "STCLRH_32S_MEMOP",
    "STCLRLB_32S_MEMOP",
    "STCLRLH_32S_MEMOP",
    "STCLRL_32S_MEMOP",
    "STCLRL_64S_MEMOP",
    "STCLR_32S_MEMOP",
    "STCLR_64S_MEMOP",
    "STEORB_32S_MEMOP",
    "STEORH_32S_MEMOP",
    "STEORLB_32S_MEMOP",
    "STEORLH_32S_MEMOP",
    "STEORL_32S_MEMOP",
    "STEORL_64S_MEMOP",
    "STEOR_32S_MEMOP",
    "STEOR_64S_MEMOP",
    "STLLRB_SL32_LDSTEXCL",
    "STLLRH_SL32_LDSTEXCL",
    "STLLR_SL32_LDSTEXCL",
    "STLLR_SL64_LDSTEXCL",
    "STLRB_SL32_LDSTEXCL",
    "STLRH_SL32_LDSTEXCL",
    "STLR_SL32_LDSTEXCL",
    "STLR_SL64_LDSTEXCL",
    "STLXP_SP32_LDSTEXCL",
    "STLXP_SP64_LDSTEXCL",
    "STLXRB_SR32_LDSTEXCL",
    "STLXRH_SR32_LDSTEXCL",
    "STLXR_SR32_LDSTEXCL",
    "STLXR_SR64_LDSTEXCL",
    "STNP_32_LDSTNAPAIR_OFFS",
    "STNP_64_LDSTNAPAIR_OFFS",
    "STNP_D_LDSTNAPAIR_OFFS",
    "STNP_Q_LDSTNAPAIR_OFFS",
    "STNP_S_LDSTNAPAIR_OFFS",
    "STP_32_LDSTPAIR_OFF",
    "STP_32_LDSTPAIR_POST",
    "STP_32_LDSTPAIR_PRE",
    "STP_64_LDSTPAIR_OFF",
    "STP_64_LDSTPAIR_POST",
    "STP_64_LDSTPAIR_PRE",
    "STP_D_LDSTPAIR_OFF",
    "STP_D_LDSTPAIR_POST",
    "STP_D_LDSTPAIR_PRE",
    "STP_Q_LDSTPAIR_OFF",
    "STP_Q_LDSTPAIR_POST",
    "STP_Q_LDSTPAIR_PRE",
    "STP_S_LDSTPAIR_OFF",
    "STP_S_LDSTPAIR_POST",
    "STP_S_LDSTPAIR_PRE",
    "STRB_32BL_LDST_REGOFF",
    "STRB_32B_LDST_REGOFF",
    "STRB_32_LDST_IMMPOST",
    "STRB_32_LDST_IMMPRE",
    "STRB_32_LDST_POS",
    "STRH_32_LDST_IMMPOST",
    "STRH_32_LDST_IMMPRE",
    "STRH_32_LDST_POS",
    "STRH_32_LDST_REGOFF",
    "STR_32_LDST_IMMPOST",
    "STR_32_LDST_IMMPRE",
    "STR_32_LDST_POS",
    "STR_32_LDST_REGOFF",
    "STR_64_LDST_IMMPOST",
    "STR_64_LDST_IMMPRE",
    "STR_64_LDST_POS",
    "STR_64_LDST_REGOFF",
    "STR_BL_LDST_REGOFF",
    "STR_B_LDST_IMMPOST",
    "STR_B_LDST_IMMPRE",
    "STR_B_LDST_POS",
    "STR_B_LDST_REGOFF",
    "STR_D_LDST_IMMPOST",
    "STR_D_LDST_IMMPRE",
    "STR_D_LDST_POS",
    "STR_D_LDST_REGOFF",
    "STR_H_LDST_IMMPOST",
    "STR_H_LDST_IMMPRE",
    "STR_H_LDST_POS",
    "STR_H_LDST_REGOFF",
    "STR_Q_LDST_IMMPOST",
    "STR_Q_LDST_IMMPRE",
    "STR_Q_LDST_POS",
    "STR_Q_LDST_REGOFF",
    "STR_S_LDST_IMMPOST",
    "STR_S_LDST_IMMPRE",
    "STR_S_LDST_POS",
    "STR_S_LDST_REGOFF",
    "STSETB_32S_MEMOP",
    "STSETH_32S_MEMOP",
    "STSETLB_32S_MEMOP",
    "STSETLH_32S_MEMOP",
    "STSETL_32S_MEMOP",
    "STSETL_64S_MEMOP",
    "STSET_32S_MEMOP",
    "STSET_64S_MEMOP",
    "STSMAXB_32S_MEMOP",
    "STSMAXH_32S_MEMOP",
    "STSMAXLB_32S_MEMOP",
    "STSMAXLH_32S_MEMOP",
    "STSMAXL_32S_MEMOP",
    "STSMAXL_64S_MEMOP",
    "STSMAX_32S_MEMOP",
    "STSMAX_64S_MEMOP",
    "STSMINB_32S_MEMOP",
    "STSMINH_32S_MEMOP",
    "STSMINLB_32S_MEMOP",
    "STSMINLH_32S_MEMOP",
    "STSMINL_32S_MEMOP",
    "STSMINL_64S_MEMOP",
    "STSMIN_32S_MEMOP",
    "STSMIN_64S_MEMOP",
    "STTRB_32_LDST_UNPRIV",
    "STTRH_32_LDST_UNPRIV",
    "STTR_32_LDST_UNPRIV",
    "STTR_64_LDST_UNPRIV",
    "STUMAXB_32S_MEMOP",
    "STUMAXH_32S_MEMOP",
    "STUMAXLB_32S_MEMOP",
    "STUMAXLH_32S_MEMOP",
    "STUMAXL_32S_MEMOP",
    "STUMAXL_64S_MEMOP",
    "STUMAX_32S_MEMOP",
    "STUMAX_64S_MEMOP",
    "STUMINB_32S_MEMOP",
    "STUMINH_32S_MEMOP",
    "STUMINLB_32S_MEMOP",
    "STUMINLH_32S_MEMOP",
    "STUMINL_32S_MEMOP",
    "STUMINL_64S_MEMOP",
    "STUMIN_32S_MEMOP",
    "STUMIN_64S_MEMOP",
    "STURB_32_LDST_UNSCALED",
    "STURH_32_LDST_UNSCALED",
    "STUR_32_LDST_UNSCALED",
    "STUR_64_LDST_UNSCALED",
    "STUR_B_LDST_UNSCALED",
    "STUR_D_LDST_UNSCALED",
    "STUR_H_LDST_UNSCALED",
    "STUR_Q_LDST_UNSCALED",
    "STUR_S_LDST_UNSCALED",
    "STXP_SP32_LDSTEXCL",
    "STXP_SP64_LDSTEXCL",
    "STXRB_SR32_LDSTEXCL",
    "STXRH_SR32_LDSTEXCL",
    "STXR_SR32_LDSTEXCL",
    "STXR_SR64_LDSTEXCL",
    "SUBHN_ASIMDDIFF_N",
    "SUBS_32S_ADDSUB_EXT",
    "SUBS_32S_ADDSUB_IMM",
    "SUBS_32_ADDSUB_SHIFT",
    "SUBS_64S_ADDSUB_EXT",
    "SUBS_64S_ADDSUB_IMM",
    "SUBS_64_ADDSUB_SHIFT",
    "SUB_32_ADDSUB_EXT",
    "SUB_32_ADDSUB_IMM",
    "SUB_32_ADDSUB_SHIFT",
    "SUB_64_ADDSUB_EXT",
    "SUB_64_ADDSUB_IMM",
    "SUB_64_ADDSUB_SHIFT",
    "SUB_ASIMDSAME_ONLY",
    "SUB_ASISDSAME_ONLY",
    "SUQADD_ASIMDMISC_R",
    "SUQADD_ASISDMISC_R",
    "SVC_EX_EXCEPTION",
    "SWPAB_32_MEMOP",
    "SWPAH_32_MEMOP",
    "SWPALB_32_MEMOP",
    "SWPALH_32_MEMOP",
    "SWPAL_32_MEMOP",
    "SWPAL_64_MEMOP",
    "SWPA_32_MEMOP",
    "SWPA_64_MEMOP",
    "SWPB_32_MEMOP",
    "SWPH_32_MEMOP",
    "SWPLB_32_MEMOP",
    "SWPLH_32_MEMOP",
    "SWPL_32_MEMOP",
    "SWPL_64_MEMOP",
    "SWP_32_MEMOP",
    "SWP_64_MEMOP",
    "SXTB_SBFM_32M_BITFIELD",
    "SXTB_SBFM_64M_BITFIELD",
    "SXTH_SBFM_32M_BITFIELD",
    "SXTH_SBFM_64M_BITFIELD",
    "SXTL_SSHLL_ASIMDSHF_L",
    "SXTW_SBFM_64M_BITFIELD",
    "SYSL_RC_SYSTEM",
    "SYS_CR_SYSTEM",
    "TBL_ASIMDTBL_L1_1",
    "TBL_ASIMDTBL_L2_2",
    "TBL_ASIMDTBL_L3_3",
    "TBL_ASIMDTBL_L4_4",
    "TBNZ_ONLY_TESTBRANCH",
    "TBX_ASIMDTBL_L1_1",
    "TBX_ASIMDTBL_L2_2",
    "TBX_ASIMDTBL_L3_3",
    "TBX_ASIMDTBL_L4_4",
    "TBZ_ONLY_TESTBRANCH",
    "TLBI_SYS_CR_SYSTEM",
    "TRN1_ASIMDPERM_ONLY",
    "TRN2_ASIMDPERM_ONLY",
    "TST_ANDS_32S_LOG_IMM",
    "TST_ANDS_32_LOG_SHIFT",
    "TST_ANDS_64S_LOG_IMM",
    "TST_ANDS_64_LOG_SHIFT",
    "UABAL_ASIMDDIFF_L",
    "UABA_ASIMDSAME_ONLY",
    "UABDL_ASIMDDIFF_L",
    "UABD_ASIMDSAME_ONLY",
    "UADALP_ASIMDMISC_P",
    "UADDLP_ASIMDMISC_P",
    "UADDLV_ASIMDALL_ONLY",
    "UADDL_ASIMDDIFF_L",
    "UADDW_ASIMDDIFF_W",
    "UBFIZ_UBFM_32M_BITFIELD",
    "UBFIZ_UBFM_64M_BITFIELD",
    "UBFM_32M_BITFIELD",
    "UBFM_64M_BITFIELD",
    "UBFX_UBFM_32M_BITFIELD",
    "UBFX_UBFM_64M_BITFIELD",
    "UCVTF_D32_FLOAT2FIX",
    "UCVTF_D32_FLOAT2INT",
    "UCVTF_D64_FLOAT2FIX",
    "UCVTF_D64_FLOAT2INT",
    "UCVTF_H32_FLOAT2FIX",
    "UCVTF_H32_FLOAT2INT",
    "UCVTF_H64_FLOAT2FIX",
    "UCVTF_H64_FLOAT2INT",
    "UCVTF_S32_FLOAT2FIX",
    "UCVTF_S32_FLOAT2INT",
    "UCVTF_S64_FLOAT2FIX",
    "UCVTF_S64_FLOAT2INT",
    "UCVTF_ASIMDMISC_R",
    "UCVTF_ASIMDMISCFP16_R",
    "UCVTF_ASIMDSHF_C",
    "UCVTF_ASISDMISC_R",
    "UCVTF_ASISDMISCFP16_R",
    "UCVTF_ASISDSHF_C",
    "UDIV_32_DP_2SRC",
    "UDIV_64_DP_2SRC",
    "UHADD_ASIMDSAME_ONLY",
    "UHSUB_ASIMDSAME_ONLY",
    "UMADDL_64WA_DP_3SRC",
    "UMAXP_ASIMDSAME_ONLY",
    "UMAXV_ASIMDALL_ONLY",
    "UMAX_ASIMDSAME_ONLY",
    "UMINP_ASIMDSAME_ONLY",
    "UMINV_ASIMDALL_ONLY",
    "UMIN_ASIMDSAME_ONLY",
    "UMLAL_ASIMDDIFF_L",
    "UMLAL_ASIMDELEM_L",
    "UMLSL_ASIMDDIFF_L",
    "UMLSL_ASIMDELEM_L",
    "UMNEGL_UMSUBL_64WA_DP_3SRC",
    "UMOV_ASIMDINS_W_W",
    "UMOV_ASIMDINS_X_X",
    "UMSUBL_64WA_DP_3SRC",
    "UMULH_64_DP_3SRC",
    "UMULL_UMADDL_64WA_DP_3SRC",
    "UMULL_ASIMDDIFF_L",
    "UMULL_ASIMDELEM_L",
    "UQADD_ASIMDSAME_ONLY",
    "UQADD_ASISDSAME_ONLY",
    "UQRSHL_ASIMDSAME_ONLY",
    "UQRSHL_ASISDSAME_ONLY",
    "UQRSHRN_ASIMDSHF_N",
    "UQRSHRN_ASISDSHF_N",
    "UQSHL_ASIMDSAME_ONLY",
    "UQSHL_ASIMDSHF_R",
    "UQSHL_ASISDSAME_ONLY",
    "UQSHL_ASISDSHF_R",
    "UQSHRN_ASIMDSHF_N",
    "UQSHRN_ASISDSHF_N",
    "UQSUB_ASIMDSAME_ONLY",
    "UQSUB_ASISDSAME_ONLY",
    "UQXTN_ASIMDMISC_N",
    "UQXTN_ASISDMISC_N",
    "URECPE_ASIMDMISC_R",
    "URHADD_ASIMDSAME_ONLY",
    "URSHL_ASIMDSAME_ONLY",
    "URSHL_ASISDSAME_ONLY",
    "URSHR_ASIMDSHF_R",
    "URSHR_ASISDSHF_R",
    "URSQRTE_ASIMDMISC_R",
    "URSRA_ASIMDSHF_R",
    "URSRA_ASISDSHF_R",
    "USHLL_ASIMDSHF_L",
    "USHL_ASIMDSAME_ONLY",
    "USHL_ASISDSAME_ONLY",
    "USHR_ASIMDSHF_R",
    "USHR_ASISDSHF_R",
    "USQADD_ASIMDMISC_R",
    "USQADD_ASISDMISC_R",
    "USRA_ASIMDSHF_R",
    "USRA_ASISDSHF_R",
    "USUBL_ASIMDDIFF_L",
    "USUBW_ASIMDDIFF_W",
    "UXTB_UBFM_32M_BITFIELD",
    "UXTH_UBFM_32M_BITFIELD",
    "UXTL_USHLL_ASIMDSHF_L",
    "UZP1_ASIMDPERM_ONLY",
    "UZP2_ASIMDPERM_ONLY",
    "WFE_HI_SYSTEM",
    "WFI_HI_SYSTEM",
    "XTN_ASIMDMISC_N",
    "YIELD_HI_SYSTEM",
    "ZIP1_ASIMDPERM_ONLY",
    "ZIP2_ASIMDPERM_ONLY",
    "CNTB_X64_BITCOUNT",
    "CNTD_X64_BITCOUNT",
    "CNTH_X64_BITCOUNT",
    "CNTW_X64_BITCOUNT",
    "WHILELO_PREDICATE",
};

static bool TryExtractFRECPX_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRECPX_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractLDP_32_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractLDP_64_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractLDP_32_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractLDP_64_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractLDP_32_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractLDP_64_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractSTSMAXH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMAXLH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractREV_32_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractREV_64_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractUBFX_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractUBFX_UBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractUMINV_ASIMDALL_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFADDP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFADDP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFABS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFABS_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractMADD_32A_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractMADD_64A_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_ASISDSHF_C(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_ASIMDSHF_C(InstData &inst, uint32_t bits);
static bool TryExtractCLZ_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVT_SH_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFCVT_DH_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFCVT_HS_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFCVT_DS_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFCVT_HD_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFCVT_SD_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractLDLARH_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDUR_B_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractLDUR_H_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractLDUR_S_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractLDUR_D_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractLDUR_Q_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractCLZ_32_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractCLZ_64_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractLSR_LSRV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractLSR_LSRV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractFCVTN_ASIMDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractCNEG_CSNEG_32_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCNEG_CSNEG_64_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractLDRSH_32_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDRSH_64_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDRSH_32_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDRSH_64_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDRSH_32_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractLDRSH_64_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractABS_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractABS_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractCMP_SUBS_32S_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractCMP_SUBS_64S_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractHINT_1(InstData &inst, uint32_t bits);
static bool TryExtractHINT_2(InstData &inst, uint32_t bits);
static bool TryExtractHINT_3(InstData &inst, uint32_t bits);
static bool TryExtractFMAX_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMAX_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMIN_H_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMIN_S_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMIN_D_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractUMLSL_ASIMDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNM_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNM_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMINNM_H_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMINNM_S_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMINNM_D_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractLDTRSW_64_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractFSQRT_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFSQRT_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFSQRT_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractLDEORA_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORAL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEOR_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORA_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORAL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEOR_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractFRINTM_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTM_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTM_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINAB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINALB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINLB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSHA256SU0_VV_CRYPTOSHA2(InstData &inst, uint32_t bits);
static bool TryExtractFMINP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMINP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractLDR_B_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDR_BL_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDR_H_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDR_S_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDR_D_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDR_Q_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMLSH_ASISDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMLSH_ASIMDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractANDS_32S_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractANDS_64S_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRA_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRAL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLR_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRA_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRAL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLR_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractUABD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSTURB_32_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractORR_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFRINTA_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRINTA_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSUBS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSUBS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSTXP_SP32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTXP_SP64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSBFX_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractSBFX_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractLDXP_LP32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDXP_LP64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractORR_32_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractORR_64_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSQDMULH_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQDMULH_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCVTL_ASIMDMISC_L(InstData &inst, uint32_t bits);
static bool TryExtractCCMN_32_CONDCMP_IMM(InstData &inst, uint32_t bits);
static bool TryExtractCCMN_64_CONDCMP_IMM(InstData &inst, uint32_t bits);
static bool TryExtractDMB_BO_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractYIELD_HI_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractUXTH_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractSTADD_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTADDL_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTADD_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTADDL_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractUSRA_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractUSRA_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractMOV_MOVZ_32_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractMOV_MOVZ_64_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractMLS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSE_R1_1V(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSE_R2_2V(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSE_R3_3V(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSE_R4_4V(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSEP_I1_I1(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSEP_R1_R1(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSEP_I2_I2(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSEP_R2_R2(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSEP_I3_I3(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSEP_R3_R3(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSEP_I4_I4(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSEP_R4_R4(InstData &inst, uint32_t bits);
static bool TryExtractAESIMC_B_CRYPTOAES(InstData &inst, uint32_t bits);
static bool TryExtractUMULH_64_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractUADDW_ASIMDDIFF_W(InstData &inst, uint32_t bits);
static bool TryExtractSTRH_32_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractSTRH_32_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractSTRH_32_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_H32_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_S32_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_D32_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_H64_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_S64_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_D64_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractSTUMAXB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMAXLB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractCMHI_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMHI_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQDMLAL_ASISDDIFF_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQDMLAL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractCBNZ_32_COMPBRANCH(InstData &inst, uint32_t bits);
static bool TryExtractCBNZ_64_COMPBRANCH(InstData &inst, uint32_t bits);
static bool TryExtractSEVL_HI_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractFRINTX_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTX_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTX_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractCMN_ADDS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractCMN_ADDS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSMIN_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXAB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXALB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXLB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractAESE_B_CRYPTOAES(InstData &inst, uint32_t bits);
static bool TryExtractSMAXP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSTXR_SR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTXR_SR64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSUB_32_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractSUB_64_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractCMLT_ASISDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractCMLT_ASIMDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractFCMEQ_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMEQ_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMEQ_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMEQ_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCLREX_BN_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractFSUB_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSHLL_ASIMDMISC_S(InstData &inst, uint32_t bits);
static bool TryExtractSQADD_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractBIC_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSUB_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSWPA_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPAL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWP_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPA_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPAL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWP_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSMC_EX_EXCEPTION(InstData &inst, uint32_t bits);
static bool TryExtractLDUR_32_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractLDUR_64_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractCMGE_ASISDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractCMGE_ASIMDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_ASISDSHF_C(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_ASIMDSHF_C(InstData &inst, uint32_t bits);
static bool TryExtractSTLLR_SL32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTLLR_SL64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSSUBL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractSMLSL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractMOV_ADD_32_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractMOV_ADD_64_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractSTTRB_32_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractBIC_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractBIC_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractTST_ANDS_32S_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractTST_ANDS_64S_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractAND_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSTLXP_SP32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTLXP_SP64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSQRSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQRSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUABAL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractMVNI_ASIMDIMM_L_HL(InstData &inst, uint32_t bits);
static bool TryExtractMVNI_ASIMDIMM_L_SL(InstData &inst, uint32_t bits);
static bool TryExtractMVNI_ASIMDIMM_M_SM(InstData &inst, uint32_t bits);
static bool TryExtractMOV_INS_ASIMDINS_IV_V(InstData &inst, uint32_t bits);
static bool TryExtractSRSHR_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSRSHR_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractLSL_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractLSL_UBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractCLS_32_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractCLS_64_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractSEV_HI_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractUMIN_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMULX_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMULX_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMULX_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMULX_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractADDS_32S_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractADDS_64S_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractUQSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUQSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSTEORB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTEORLB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDPSW_64_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractLDPSW_64_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractLDPSW_64_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractSTUMAXH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMAXLH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSMOV_ASIMDINS_W_W(InstData &inst, uint32_t bits);
static bool TryExtractSMOV_ASIMDINS_X_X(InstData &inst, uint32_t bits);
static bool TryExtractUABA_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSTSMINB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMINLB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFCMGE_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMGE_ASISDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMGE_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMGE_ASIMDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractSTLLRB_SL32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractFRINTZ_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRINTZ_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSTXRH_SR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTEORH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTEORLH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFMINNMP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMINNMP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractLDLAR_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDLAR_LR64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractADD_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractADD_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSSHLL_ASIMDSHF_L(InstData &inst, uint32_t bits);
static bool TryExtractRORV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractRORV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractSTCLRB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTCLRLB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDARH_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTSMAX_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMAXL_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMAX_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMAXL_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractBLR_64_BRANCH_REG(InstData &inst, uint32_t bits);
static bool TryExtractCMN_ADDS_32S_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractCMN_ADDS_64S_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractSQDMULL_ASISDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractSQDMULL_ASIMDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractCSET_CSINC_32_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCSET_CSINC_64_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSO_B1_1B(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSO_H1_1H(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSO_S1_1S(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSO_D1_1D(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSOP_B1_I1B(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSOP_BX1_R1B(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSOP_H1_I1H(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSOP_HX1_R1H(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSOP_S1_I1S(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSOP_SX1_R1S(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSOP_D1_I1D(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSOP_DX1_R1D(InstData &inst, uint32_t bits);
static bool TryExtractCCMN_32_CONDCMP_REG(InstData &inst, uint32_t bits);
static bool TryExtractCCMN_64_CONDCMP_REG(InstData &inst, uint32_t bits);
static bool TryExtractSTNP_S_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractSTNP_D_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractSTNP_Q_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractFSUB_H_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFSUB_S_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFSUB_D_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractCSNEG_32_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCSNEG_64_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractASR_ASRV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractASR_ASRV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractUMULL_UMADDL_64WA_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractFCMGT_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMGT_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMGT_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMGT_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUSUBW_ASIMDDIFF_W(InstData &inst, uint32_t bits);
static bool TryExtractREV32_64_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractFSQRT_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFSQRT_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractLSL_LSLV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractLSL_LSLV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractEXTR_32_EXTRACT(InstData &inst, uint32_t bits);
static bool TryExtractEXTR_64_EXTRACT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractBFXIL_BFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractBFXIL_BFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractZIP1_ASIMDPERM_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractLDSETAH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETALH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETLH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDR_32_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDR_64_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDADDAH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDALH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDLH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractANDS_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractANDS_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSE_R3(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSEP_I3_I(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSEP_R3_R(InstData &inst, uint32_t bits);
static bool TryExtractFMUL_H_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMUL_S_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMUL_D_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractLDAXR_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDAXR_LR64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDRB_32B_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDRB_32BL_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractUADALP_ASIMDMISC_P(InstData &inst, uint32_t bits);
static bool TryExtractFRINTX_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRINTX_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractHLT_EX_EXCEPTION(InstData &inst, uint32_t bits);
static bool TryExtractSABA_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMAX_H_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMAX_S_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMAX_D_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractAESD_B_CRYPTOAES(InstData &inst, uint32_t bits);
static bool TryExtractAESMC_B_CRYPTOAES(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSO_B2_2B(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSO_H2_2H(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSO_S2_2S(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSO_D2_2D(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSOP_B2_I2B(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSOP_BX2_R2B(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSOP_H2_I2H(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSOP_HX2_R2H(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSOP_S2_I2S(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSOP_SX2_R2S(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSOP_D2_I2D(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSOP_DX2_R2D(InstData &inst, uint32_t bits);
static bool TryExtractBR_64_BRANCH_REG(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractMVN_ORN_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractMVN_ORN_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSTEOR_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTEORL_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTEOR_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTEORL_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractTBX_ASIMDTBL_L2_2(InstData &inst, uint32_t bits);
static bool TryExtractTBX_ASIMDTBL_L3_3(InstData &inst, uint32_t bits);
static bool TryExtractTBX_ASIMDTBL_L4_4(InstData &inst, uint32_t bits);
static bool TryExtractTBX_ASIMDTBL_L1_1(InstData &inst, uint32_t bits);
static bool TryExtractUMLAL_ASIMDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractUMINP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMLE_ASISDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractCMLE_ASIMDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractEOR_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMEQ_ASISDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractCMEQ_ASIMDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXAH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXALH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXLH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSO_B3_3B(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSO_H3_3H(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSO_S3_3S(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSO_D3_3D(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSOP_B3_I3B(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSOP_BX3_R3B(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSOP_H3_I3H(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSOP_HX3_R3H(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSOP_S3_I3S(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSOP_SX3_R3S(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSOP_D3_I3D(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSOP_DX3_R3D(InstData &inst, uint32_t bits);
static bool TryExtractASR_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractASR_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractLDRSW_64_LOADLIT(InstData &inst, uint32_t bits);
static bool TryExtractLDADDA_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDAL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADD_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDA_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDAL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADD_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_ASISDSHF_C(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_ASIMDSHF_C(InstData &inst, uint32_t bits);
static bool TryExtractLSR_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractLSR_UBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSO_B2_2B(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSO_H2_2H(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSO_S2_2S(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSO_D2_2D(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSOP_B2_I2B(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSOP_BX2_R2B(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSOP_H2_I2H(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSOP_HX2_R2H(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSOP_S2_I2S(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSOP_SX2_R2S(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSOP_D2_I2D(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSOP_DX2_R2D(InstData &inst, uint32_t bits);
static bool TryExtractRADDHN_ASIMDDIFF_N(InstData &inst, uint32_t bits);
static bool TryExtractSTUR_32_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractSTUR_64_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractCLS_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSADDL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractADDP_ASISDPAIR_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMP_SUBS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractCMP_SUBS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSTR_B_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractSTR_H_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractSTR_S_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractSTR_D_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractSTR_Q_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractSTR_B_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractSTR_H_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractSTR_S_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractSTR_D_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractSTR_Q_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractSTR_B_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractSTR_H_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractSTR_S_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractSTR_D_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractSTR_Q_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractLDSETAB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETALB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETLB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractMOV_ORR_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractMOV_ORR_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractFRINTP_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTP_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTP_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractCASA_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASAL_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCAS_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASL_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASA_C64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASAL_C64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCAS_C64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASL_C64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractWFE_HI_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINA_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINAL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMIN_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINA_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINAL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMIN_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTXRB_SR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTLXRH_SR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTLLRH_SL32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINAH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINALH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMINLH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLSLV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractLSLV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractINS_ASIMDINS_IR_R(InstData &inst, uint32_t bits);
static bool TryExtractCMGT_ASISDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractCMGT_ASIMDMISC_Z(InstData &inst, uint32_t bits);
static bool TryExtractSMLAL_ASIMDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractSTCLR_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTCLRL_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTCLR_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTCLRL_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractBIT_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMEQ_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMEQ_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCRC32CB_32C_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractCRC32CH_32C_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractCRC32CW_32C_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractCRC32CX_64C_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractSTRH_32_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractBRK_EX_EXCEPTION(InstData &inst, uint32_t bits);
static bool TryExtractUADDLP_ASIMDMISC_P(InstData &inst, uint32_t bits);
static bool TryExtractUMAXV_ASIMDALL_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractLDEORAH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORALH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORLH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSMAXV_ASIMDALL_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractXTN_ASIMDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractSTRB_32_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractSTRB_32_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractSTRB_32_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractUSQADD_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractUSQADD_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_32H_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_64H_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_32S_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_64S_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_32D_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_64D_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractUQADD_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUQADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractLDR_32_LOADLIT(InstData &inst, uint32_t bits);
static bool TryExtractLDR_64_LOADLIT(InstData &inst, uint32_t bits);
static bool TryExtractFNMSUB_H_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractFNMSUB_S_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractFNMSUB_D_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractADDP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSHA1M_QSV_CRYPTOSHA3(InstData &inst, uint32_t bits);
static bool TryExtractLDAXP_LP32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDAXP_LP64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASPA_CP32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASPAL_CP32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASP_CP32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASPL_CP32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASPA_CP64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASPAL_CP64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASP_CP64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASPL_CP64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_32H_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_64H_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_32S_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_64S_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_32D_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_64D_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractSHA1P_QSV_CRYPTOSHA3(InstData &inst, uint32_t bits);
static bool TryExtractSADDLV_ASIMDALL_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractTBL_ASIMDTBL_L2_2(InstData &inst, uint32_t bits);
static bool TryExtractTBL_ASIMDTBL_L3_3(InstData &inst, uint32_t bits);
static bool TryExtractTBL_ASIMDTBL_L4_4(InstData &inst, uint32_t bits);
static bool TryExtractTBL_ASIMDTBL_L1_1(InstData &inst, uint32_t bits);
static bool TryExtractADD_32_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractADD_64_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNMP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNMP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits);
static bool TryExtractBICS_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractBICS_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractFNMUL_H_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFNMUL_S_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFNMUL_D_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractSQSUB_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQXTN_ASISDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractSQXTN_ASIMDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractMOV_ORR_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractREV64_REV_64_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractSTLXRB_SR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTTRH_32_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractSMINP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSHA256SU1_VVV_CRYPTOSHA3(InstData &inst, uint32_t bits);
static bool TryExtractFMSUB_H_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractFMSUB_S_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractFMSUB_D_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractNGCS_SBCS_32_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractNGCS_SBCS_64_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractSTR_32_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractSTR_64_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractSTR_32_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractSTR_64_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractSTR_32_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractSTR_64_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractINS_ASIMDINS_IV_V(InstData &inst, uint32_t bits);
static bool TryExtractDCPS2_DC_EXCEPTION(InstData &inst, uint32_t bits);
static bool TryExtractTST_ANDS_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractTST_ANDS_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractDCPS1_DC_EXCEPTION(InstData &inst, uint32_t bits);
static bool TryExtractFMLA_ASISDELEM_RH_H(InstData &inst, uint32_t bits);
static bool TryExtractFMLA_ASISDELEM_R_SD(InstData &inst, uint32_t bits);
static bool TryExtractFMLA_ASIMDELEM_RH_H(InstData &inst, uint32_t bits);
static bool TryExtractFMLA_ASIMDELEM_R_SD(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractUMULL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractFMUL_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMUL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMLA_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMLA_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSDIV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractSDIV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractADD_32_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractADD_64_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractRBIT_32_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractRBIT_64_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractSMNEGL_SMSUBL_64WA_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractMOV_DUP_ASISDONE_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSMULL_SMADDL_64WA_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractZIP2_ASIMDPERM_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractLDAXRB_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractMNEG_MSUB_32A_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractMNEG_MSUB_64A_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractHVC_EX_EXCEPTION(InstData &inst, uint32_t bits);
static bool TryExtractDCPS3_DC_EXCEPTION(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSTUMINB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMINLB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractTBNZ_ONLY_TESTBRANCH(InstData &inst, uint32_t bits);
static bool TryExtractSTCLRH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTCLRLH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractBL_ONLY_BRANCH_IMM(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNMP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNMP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_H32_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_S32_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_H64_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_D64_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_V64I_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_64VX_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRAH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRALH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRLH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSABAL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractLDSETA_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETAL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSET_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETA_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETAL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSET_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSETL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFRECPS_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFRECPS_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFRECPS_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFRECPS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSMLAL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINAH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINALH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINLH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFRINTI_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTI_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTI_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractSMULH_64_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractFMADD_H_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractFMADD_S_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractFMADD_D_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractCCMP_32_CONDCMP_REG(InstData &inst, uint32_t bits);
static bool TryExtractCCMP_64_CONDCMP_REG(InstData &inst, uint32_t bits);
static bool TryExtractSRSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSRSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFADD_H_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFADD_S_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFADD_D_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMULX_ASISDELEM_RH_H(InstData &inst, uint32_t bits);
static bool TryExtractFMULX_ASISDELEM_R_SD(InstData &inst, uint32_t bits);
static bool TryExtractFMULX_ASIMDELEM_RH_H(InstData &inst, uint32_t bits);
static bool TryExtractFMULX_ASIMDELEM_R_SD(InstData &inst, uint32_t bits);
static bool TryExtractBIC_ASIMDIMM_L_HL(InstData &inst, uint32_t bits);
static bool TryExtractBIC_ASIMDIMM_L_SL(InstData &inst, uint32_t bits);
static bool TryExtractDC_SYS_CR_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractPRFM_P_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSTUMINH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMINLH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractORR_ASIMDIMM_L_HL(InstData &inst, uint32_t bits);
static bool TryExtractORR_ASIMDIMM_L_SL(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAU_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractLDXR_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDXR_LR64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractTLBI_SYS_CR_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractSVC_EX_EXCEPTION(InstData &inst, uint32_t bits);
static bool TryExtractFCMPE_H_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMPE_HZ_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMPE_S_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMPE_SZ_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMPE_D_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMPE_DZ_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFRSQRTS_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFRSQRTS_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFRSQRTS_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFRSQRTS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFRINTN_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTN_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTN_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_H_FLOATIMM(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_S_FLOATIMM(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_D_FLOATIMM(InstData &inst, uint32_t bits);
static bool TryExtractEOR_32_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractEOR_64_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractMRS_RS_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractESB_HI_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractFCMLT_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMLT_ASISDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMLT_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMLT_ASIMDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMULH_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMULH_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSWPAH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPALH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPLH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractDUP_ASISDONE_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractDUP_ASIMDINS_DV_V(InstData &inst, uint32_t bits);
static bool TryExtractSTLRH_SL32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXA_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXAL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAX_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXA_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXAL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAX_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDUMAXL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSQNEG_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSQNEG_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractUHADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMP_SUBS_32S_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractCMP_SUBS_64S_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractCASAH_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASALH_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASH_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASLH_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractADCS_32_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractADCS_64_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractFRINTZ_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTZ_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTZ_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_H32_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_S32_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_D32_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_H64_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_S64_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractSCVTF_D64_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractCSETM_CSINV_32_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCSETM_CSINV_64_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractSQDMLAL_ASISDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractSQDMLAL_ASIMDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractSHL_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSHL_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSE_R2(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSEP_I2_I(InstData &inst, uint32_t bits);
static bool TryExtractLD2_ASISDLSEP_R2_R(InstData &inst, uint32_t bits);
static bool TryExtractSBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractSBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractFMAXV_ASIMDALL_ONLY_H(InstData &inst, uint32_t bits);
static bool TryExtractFMAXV_ASIMDALL_ONLY_SD(InstData &inst, uint32_t bits);
static bool TryExtractSTADDB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTADDLB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMAX_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMAXL_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMAX_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMAXL_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSQDMULH_ASISDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractSQDMULH_ASIMDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractFRSQRTE_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRSQRTE_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFRSQRTE_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRSQRTE_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractADD_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSABDL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractROR_RORV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractROR_RORV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_H32_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_S32_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_D32_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_H64_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_S64_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_D64_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_H32_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_S32_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_D32_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_H64_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_S64_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractUCVTF_D64_FLOAT2FIX(InstData &inst, uint32_t bits);
static bool TryExtractMOVI_ASIMDIMM_N_B(InstData &inst, uint32_t bits);
static bool TryExtractMOVI_ASIMDIMM_L_HL(InstData &inst, uint32_t bits);
static bool TryExtractMOVI_ASIMDIMM_L_SL(InstData &inst, uint32_t bits);
static bool TryExtractMOVI_ASIMDIMM_M_SM(InstData &inst, uint32_t bits);
static bool TryExtractMOVI_ASIMDIMM_D_DS(InstData &inst, uint32_t bits);
static bool TryExtractMOVI_ASIMDIMM_D2_D(InstData &inst, uint32_t bits);
static bool TryExtractREV16_32_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractREV16_64_DP_1SRC(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMLAH_ASISDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMLAH_ASIMDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractFMAXP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits);
static bool TryExtractFMAXP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits);
static bool TryExtractBIF_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMLE_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMLE_ASISDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMLE_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMLE_ASIMDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractDRPS_64E_BRANCH_REG(InstData &inst, uint32_t bits);
static bool TryExtractSLI_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSLI_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractLDAXRH_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractBFI_BFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractBFI_BFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractLDADDAB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDALB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDADDLB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDRH_32_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDRH_32_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDRH_32_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractSXTB_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractSXTB_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractERET_64E_BRANCH_REG(InstData &inst, uint32_t bits);
static bool TryExtractSTUMIN_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMINL_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMIN_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTUMINL_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSHA1SU1_VV_CRYPTOSHA2(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSE_R1_1V(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSE_R2_2V(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSE_R3_3V(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSE_R4_4V(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSEP_I1_I1(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSEP_R1_R1(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSEP_I2_I2(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSEP_R2_R2(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSEP_I3_I3(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSEP_R3_R3(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSEP_I4_I4(InstData &inst, uint32_t bits);
static bool TryExtractLD1_ASISDLSEP_R4_R4(InstData &inst, uint32_t bits);
static bool TryExtractSHA1H_SS_CRYPTOSHA2(InstData &inst, uint32_t bits);
static bool TryExtractFRINTM_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRINTM_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSTURH_32_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractSQSHLU_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSQSHLU_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractUMULL_ASIMDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractNOT_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractLDR_B_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDR_H_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDR_S_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDR_D_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDR_Q_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDR_B_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDR_H_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDR_S_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDR_D_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDR_Q_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDR_B_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractLDR_H_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractLDR_S_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractLDR_D_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractLDR_Q_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractSWPAB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPALB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSWPLB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_ASIMDIMM_H_H(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_ASIMDIMM_S_S(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_ASIMDIMM_D2_D(InstData &inst, uint32_t bits);
static bool TryExtractFMIN_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMIN_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQXTUN_ASISDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractSQXTUN_ASIMDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractLDEORAB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORALB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDEORLB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPS_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractLDR_S_LOADLIT(InstData &inst, uint32_t bits);
static bool TryExtractLDR_D_LOADLIT(InstData &inst, uint32_t bits);
static bool TryExtractLDR_Q_LOADLIT(InstData &inst, uint32_t bits);
static bool TryExtractFRINTP_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRINTP_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractLDLARB_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractFNEG_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFNEG_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractADDHN_ASIMDDIFF_N(InstData &inst, uint32_t bits);
static bool TryExtractLDNP_32_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractLDNP_64_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractSQRSHRN_ASISDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractSQRSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractCMGT_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMGT_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSE_R4(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSEP_I4_I(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSEP_R4_R(InstData &inst, uint32_t bits);
static bool TryExtractASRV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractASRV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractUHSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMHS_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMHS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractMOVZ_32_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractMOVZ_64_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractSADDW_ASIMDDIFF_W(InstData &inst, uint32_t bits);
static bool TryExtractSADDLP_ASIMDMISC_P(InstData &inst, uint32_t bits);
static bool TryExtractUMNEGL_UMSUBL_64WA_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSE_R2(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSEP_I2_I(InstData &inst, uint32_t bits);
static bool TryExtractST2_ASISDLSEP_R2_R(InstData &inst, uint32_t bits);
static bool TryExtractUXTL_USHLL_ASIMDSHF_L(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINA_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINAL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMIN_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINA_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINAL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMIN_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractPSB_HC_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractFMUL_ASISDELEM_RH_H(InstData &inst, uint32_t bits);
static bool TryExtractFMUL_ASISDELEM_R_SD(InstData &inst, uint32_t bits);
static bool TryExtractFMUL_ASIMDELEM_RH_H(InstData &inst, uint32_t bits);
static bool TryExtractFMUL_ASIMDELEM_R_SD(InstData &inst, uint32_t bits);
static bool TryExtractSHADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMINP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits);
static bool TryExtractFMINP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits);
static bool TryExtractREV64_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSSUBW_ASIMDDIFF_W(InstData &inst, uint32_t bits);
static bool TryExtractMOV_UMOV_ASIMDINS_W_W(InstData &inst, uint32_t bits);
static bool TryExtractMOV_UMOV_ASIMDINS_X_X(InstData &inst, uint32_t bits);
static bool TryExtractMLS_ASIMDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractSQDMLSL_ASISDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractSQDMLSL_ASIMDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractCINC_CSINC_32_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCINC_CSINC_64_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCSINV_32_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCSINV_64_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_ASISDSHF_C(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_ASIMDSHF_C(InstData &inst, uint32_t bits);
static bool TryExtractSSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUXTB_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractSSRA_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSSRA_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractLDRSW_64_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSQSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractADDV_ASIMDALL_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractPMUL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSMLSL_ASIMDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractNEG_SUB_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractNEG_SUB_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractFCMP_H_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMP_HZ_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMP_S_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMP_SZ_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMP_D_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCMP_DZ_FLOATCMP(InstData &inst, uint32_t bits);
static bool TryExtractORR_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractORR_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSHA1SU0_VVV_CRYPTOSHA3(InstData &inst, uint32_t bits);
static bool TryExtractSTSET_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSETL_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSET_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSETL_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractMLA_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractADDS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractADDS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractLD3R_ASISDLSO_R3(InstData &inst, uint32_t bits);
static bool TryExtractLD3R_ASISDLSOP_R3_I(InstData &inst, uint32_t bits);
static bool TryExtractLD3R_ASISDLSOP_RX3_R(InstData &inst, uint32_t bits);
static bool TryExtractPRFM_P_LOADLIT(InstData &inst, uint32_t bits);
static bool TryExtractCASAB_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASALB_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASB_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractCASLB_C32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractNEGS_SUBS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractNEGS_SUBS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXAH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXALH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXLH_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractMSUB_32A_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractMSUB_64A_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSE_R4(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSEP_I4_I(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSEP_R4_R(InstData &inst, uint32_t bits);
static bool TryExtractUQXTN_ASISDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractUQXTN_ASIMDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractTBZ_ONLY_TESTBRANCH(InstData &inst, uint32_t bits);
static bool TryExtractFMINNMV_ASIMDALL_ONLY_H(InstData &inst, uint32_t bits);
static bool TryExtractFMINNMV_ASIMDALL_ONLY_SD(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNM_H_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNM_S_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNM_D_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractLDR_32_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDR_64_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDR_32_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDR_64_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDR_32_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractLDR_64_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractCNT_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSQSHL_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSQSHL_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractLDTR_32_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractLDTR_64_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractCCMP_32_CONDCMP_IMM(InstData &inst, uint32_t bits);
static bool TryExtractCCMP_64_CONDCMP_IMM(InstData &inst, uint32_t bits);
static bool TryExtractUZP2_ASIMDPERM_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractLDURB_32_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMLSH_ASISDSAME2_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMLSH_ASIMDSAME2_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractMOV_INS_ASIMDINS_IR_R(InstData &inst, uint32_t bits);
static bool TryExtractLDTRSB_32_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractLDTRSB_64_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractSMINV_ASIMDALL_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractURHADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractAND_32_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractAND_64_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractSABD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMGE_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMGE_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMGE_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCMGE_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractMVN_NOT_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSTSMIN_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMINL_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMIN_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMINL_64S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractTRN1_ASIMDPERM_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSBCS_32_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractSBCS_64_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractSMULL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractLSRV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractLSRV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractURSQRTE_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCCMPE_H_FLOATCCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCCMPE_S_FLOATCCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCCMPE_D_FLOATCCMP(InstData &inst, uint32_t bits);
static bool TryExtractFMAXP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMAXP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractMUL_MADD_32A_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractMUL_MADD_64A_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractSTTR_32_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractSTTR_64_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractFCMGT_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMGT_ASISDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMGT_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMGT_ASIMDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractBSL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUQSUB_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUQSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractWFI_HI_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractLDXRH_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNMV_ASIMDALL_ONLY_H(InstData &inst, uint32_t bits);
static bool TryExtractFMAXNMV_ASIMDALL_ONLY_SD(InstData &inst, uint32_t bits);
static bool TryExtractSTLXR_SR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTLXR_SR64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTLRB_SL32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSE_R3(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSEP_I3_I(InstData &inst, uint32_t bits);
static bool TryExtractST3_ASISDLSEP_R3_R(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMULH_ASISDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMULH_ASIMDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractSXTW_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractUSHR_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractUSHR_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractB_ONLY_BRANCH_IMM(InstData &inst, uint32_t bits);
static bool TryExtractFCMEQ_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMEQ_ASISDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMEQ_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFCMEQ_ASIMDMISC_FZ(InstData &inst, uint32_t bits);
static bool TryExtractFACGE_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFACGE_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFACGE_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFACGE_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCSEL_32_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCSEL_64_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractLDURSH_32_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractLDURSH_64_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractLDURSW_64_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractMOVN_32_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractMOVN_64_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractSXTL_SSHLL_ASIMDSHF_L(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSO_B1_1B(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSO_H1_1H(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSO_S1_1S(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSO_D1_1D(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSOP_B1_I1B(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSOP_BX1_R1B(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSOP_H1_I1H(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSOP_HX1_R1H(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSOP_S1_I1S(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSOP_SX1_R1S(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSOP_D1_I1D(InstData &inst, uint32_t bits);
static bool TryExtractST1_ASISDLSOP_DX1_R1D(InstData &inst, uint32_t bits);
static bool TryExtractUZP1_ASIMDPERM_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSTUR_B_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractSTUR_H_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractSTUR_S_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractSTUR_D_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractSTUR_Q_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractMLA_ASIMDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractSTSETH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSETLH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFMINV_ASIMDALL_ONLY_H(InstData &inst, uint32_t bits);
static bool TryExtractFMINV_ASIMDALL_ONLY_SD(InstData &inst, uint32_t bits);
static bool TryExtractMOV_ORR_32_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractMOV_ORR_64_LOG_IMM(InstData &inst, uint32_t bits);
static bool TryExtractDSB_BO_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractSTSMINH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMINLH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSO_B4_4B(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSO_H4_4H(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSO_S4_4S(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSO_D4_4D(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSOP_B4_I4B(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSOP_BX4_R4B(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSOP_H4_I4H(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSOP_HX4_R4H(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSOP_S4_I4S(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSOP_SX4_R4S(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSOP_D4_I4D(InstData &inst, uint32_t bits);
static bool TryExtractST4_ASISDLSOP_DX4_R4D(InstData &inst, uint32_t bits);
static bool TryExtractLDNP_S_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractLDNP_D_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractLDNP_Q_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractADDS_32S_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractADDS_64S_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractCBZ_32_COMPBRANCH(InstData &inst, uint32_t bits);
static bool TryExtractCBZ_64_COMPBRANCH(InstData &inst, uint32_t bits);
static bool TryExtractURSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractURSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQRSHRUN_ASISDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractSQRSHRUN_ASIMDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractROR_EXTR_32_EXTRACT(InstData &inst, uint32_t bits);
static bool TryExtractROR_EXTR_64_EXTRACT(InstData &inst, uint32_t bits);
static bool TryExtractFRINTI_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRINTI_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractLDXRB_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTP_S_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractSTP_D_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractSTP_Q_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractSTP_S_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractSTP_D_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractSTP_Q_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractSTP_S_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractSTP_D_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractSTP_Q_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractADR_ONLY_PCRELADDR(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINAB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINALB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMINLB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractUBFIZ_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractUBFIZ_UBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSO_B4_4B(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSO_H4_4H(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSO_S4_4S(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSO_D4_4D(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSOP_B4_I4B(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSOP_BX4_R4B(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSOP_H4_I4H(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSOP_HX4_R4H(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSOP_S4_I4S(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSOP_SX4_R4S(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSOP_D4_I4D(InstData &inst, uint32_t bits);
static bool TryExtractLD4_ASISDLSOP_DX4_R4D(InstData &inst, uint32_t bits);
static bool TryExtractSTRB_32B_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSTRB_32BL_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractUMAX_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCRC32B_32C_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractCRC32H_32C_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractCRC32W_32C_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractCRC32X_64C_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractURSHR_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractURSHR_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractPRFM_P_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractSUBS_32S_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractSUBS_64S_ADDSUB_IMM(InstData &inst, uint32_t bits);
static bool TryExtractSUBS_32S_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractSUBS_64S_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractSYSL_RC_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractSMSUBL_64WA_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractURSRA_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractURSRA_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractLDURH_32_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractSUB_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSUB_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSRI_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSRI_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractUMAXP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractIC_SYS_CR_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractLDTRSH_32_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractLDTRSH_64_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractSADALP_ASIMDMISC_P(InstData &inst, uint32_t bits);
static bool TryExtractLDTRH_32_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractSMAX_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTPU_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractRET_64R_BRANCH_REG(InstData &inst, uint32_t bits);
static bool TryExtractUQRSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUQRSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractLDRB_32_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDRB_32_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDRB_32_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractFCVTXN_ASISDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractFCVTXN_ASIMDMISC_N(InstData &inst, uint32_t bits);
static bool TryExtractMSR_SI_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractUABDL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractMSR_SR_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractLDRH_32_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractUQSHL_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractUQSHL_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractFMINNMP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits);
static bool TryExtractFMINNMP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits);
static bool TryExtractUMADDL_64WA_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFMOV_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractSRHADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractNGC_SBC_32_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractNGC_SBC_64_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractSBFIZ_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractSBFIZ_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractUMSUBL_64WA_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMU_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractLDP_S_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractLDP_D_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractLDP_Q_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractLDP_S_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractLDP_D_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractLDP_Q_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractLDP_S_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractLDP_D_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractLDP_Q_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractSBC_32_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractSBC_64_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZU_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractCINV_CSINV_32_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCINV_CSINV_64_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractSTR_32_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSTR_64_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractFDIV_H_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFDIV_S_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractFDIV_D_FLOATDP2(InstData &inst, uint32_t bits);
static bool TryExtractURECPE_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractISB_BI_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractRSUBHN_ASIMDDIFF_N(InstData &inst, uint32_t bits);
static bool TryExtractSMULL_ASIMDELEM_L(InstData &inst, uint32_t bits);
static bool TryExtractSUQADD_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSUQADD_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractLDRSH_32_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDRSH_64_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractADRP_ONLY_PCRELADDR(InstData &inst, uint32_t bits);
static bool TryExtractDUP_ASIMDINS_DR_R(InstData &inst, uint32_t bits);
static bool TryExtractFABS_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFABS_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFABS_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractREV32_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractAT_SYS_CR_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractUQRSHRN_ASISDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractUQRSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractUBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractUBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractSTNP_32_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractSTNP_64_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits);
static bool TryExtractLDARB_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSRSRA_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSRSRA_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractCMGE_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMGE_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFADD_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMLAH_ASISDSAME2_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQRDMLAH_ASIMDSAME2_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractORN_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSTSETB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSETLB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractADC_32_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractADC_64_ADDSUB_CARRY(InstData &inst, uint32_t bits);
static bool TryExtractBFC_BFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractBFC_BFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractLD2R_ASISDLSO_R2(InstData &inst, uint32_t bits);
static bool TryExtractLD2R_ASISDLSOP_R2_I(InstData &inst, uint32_t bits);
static bool TryExtractLD2R_ASISDLSOP_RX2_R(InstData &inst, uint32_t bits);
static bool TryExtractCSINC_32_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractCSINC_64_CONDSEL(InstData &inst, uint32_t bits);
static bool TryExtractFMLS_ASISDELEM_RH_H(InstData &inst, uint32_t bits);
static bool TryExtractFMLS_ASISDELEM_R_SD(InstData &inst, uint32_t bits);
static bool TryExtractFMLS_ASIMDELEM_RH_H(InstData &inst, uint32_t bits);
static bool TryExtractFMLS_ASIMDELEM_R_SD(InstData &inst, uint32_t bits);
static bool TryExtractSHA256H2_QQV_CRYPTOSHA3(InstData &inst, uint32_t bits);
static bool TryExtractRBIT_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractRSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractUMOV_ASIMDINS_W_W(InstData &inst, uint32_t bits);
static bool TryExtractUMOV_ASIMDINS_X_X(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTZS_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractNOP_HI_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTMS_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFRINTA_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTA_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFRINTA_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFCSEL_H_FLOATSEL(InstData &inst, uint32_t bits);
static bool TryExtractFCSEL_S_FLOATSEL(InstData &inst, uint32_t bits);
static bool TryExtractFCSEL_D_FLOATSEL(InstData &inst, uint32_t bits);
static bool TryExtractSUBHN_ASIMDDIFF_N(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_32_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_64_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_32_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_64_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_32_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_64_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractFACGT_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFACGT_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFACGT_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFACGT_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractNEG_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractNEG_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractUMLAL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractREV16_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractPMULL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractFMLS_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMLS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractEOR_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractEOR_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXA_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXAL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAX_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXL_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXA_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXAL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAX_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXL_64_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSYS_CR_SYSTEM(InstData &inst, uint32_t bits);
static bool TryExtractSQABS_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSQABS_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractLDAR_LR32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractLDAR_LR64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTADDH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTADDLH_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDRSW_64_LDST_IMMPOST(InstData &inst, uint32_t bits);
static bool TryExtractLDRSW_64_LDST_IMMPRE(InstData &inst, uint32_t bits);
static bool TryExtractLDRSW_64_LDST_POS(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTAS_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractUQSHRN_ASISDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractUQSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractEXT_ASIMDEXT_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFADDP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits);
static bool TryExtractFADDP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits);
static bool TryExtractSSHR_ASISDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSSHR_ASIMDSHF_R(InstData &inst, uint32_t bits);
static bool TryExtractSHSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMN_ADDS_32S_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractCMN_ADDS_64S_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractFMINNM_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFMINNM_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUMLSL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractUSHLL_ASIMDSHF_L(InstData &inst, uint32_t bits);
static bool TryExtractSTLR_SL32_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractSTLR_SL64_LDSTEXCL(InstData &inst, uint32_t bits);
static bool TryExtractEON_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractEON_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSTSMAXB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractSTSMAXLB_32S_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractSQSHRN_ASISDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractSQSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractLDTRB_32_LDST_UNPRIV(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_32B_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_32BL_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_64B_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractLDRSB_64BL_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSXTH_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractSXTH_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits);
static bool TryExtractLDURSB_32_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractLDURSB_64_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractSHA256H_QQV_CRYPTOSHA3(InstData &inst, uint32_t bits);
static bool TryExtractLD4R_ASISDLSO_R4(InstData &inst, uint32_t bits);
static bool TryExtractLD4R_ASISDLSOP_R4_I(InstData &inst, uint32_t bits);
static bool TryExtractLD4R_ASISDLSOP_RX4_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNS_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFDIV_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFDIV_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFRECPE_ASISDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRECPE_ASISDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractFRECPE_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRECPE_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractLD1R_ASISDLSO_R1(InstData &inst, uint32_t bits);
static bool TryExtractLD1R_ASISDLSOP_R1_I(InstData &inst, uint32_t bits);
static bool TryExtractLD1R_ASISDLSOP_RX1_R(InstData &inst, uint32_t bits);
static bool TryExtractMUL_ASIMDELEM_R(InstData &inst, uint32_t bits);
static bool TryExtractUADDLV_ASIMDALL_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFNEG_H_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFNEG_S_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractFNEG_D_FLOATDP1(InstData &inst, uint32_t bits);
static bool TryExtractUSUBL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractSHA1C_QSV_CRYPTOSHA3(InstData &inst, uint32_t bits);
static bool TryExtractSQDMLSL_ASISDDIFF_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQDMLSL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractPRFUM_P_LDST_UNSCALED(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXAB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXALB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDSMAXLB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractFABD_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFABD_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFABD_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractFABD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractB_ONLY_CONDBRANCH(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_32H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_64H_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_32S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_64S_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_32D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractFCVTNU_64D_FLOAT2INT(InstData &inst, uint32_t bits);
static bool TryExtractMUL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUDIV_32_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractUDIV_64_DP_2SRC(InstData &inst, uint32_t bits);
static bool TryExtractCMTST_ASISDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractCMTST_ASIMDSAME_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractUADDL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractMOV_MOVN_32_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractMOV_MOVN_64_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractTRN2_ASIMDPERM_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractMOVK_32_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractMOVK_64_MOVEWIDE(InstData &inst, uint32_t bits);
static bool TryExtractSMADDL_64WA_DP_3SRC(InstData &inst, uint32_t bits);
static bool TryExtractAND_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractAND_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractSQSHRUN_ASISDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractSQSHRUN_ASIMDSHF_N(InstData &inst, uint32_t bits);
static bool TryExtractSQDMULL_ASISDDIFF_ONLY(InstData &inst, uint32_t bits);
static bool TryExtractSQDMULL_ASIMDDIFF_L(InstData &inst, uint32_t bits);
static bool TryExtractFNMADD_H_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractFNMADD_S_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractFNMADD_D_FLOATDP3(InstData &inst, uint32_t bits);
static bool TryExtractFCCMP_H_FLOATCCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCCMP_S_FLOATCCMP(InstData &inst, uint32_t bits);
static bool TryExtractFCCMP_D_FLOATCCMP(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSO_B3_3B(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSO_H3_3H(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSO_S3_3S(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSO_D3_3D(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSOP_B3_I3B(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSOP_BX3_R3B(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSOP_H3_I3H(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSOP_HX3_R3H(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSOP_S3_I3S(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSOP_SX3_R3S(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSOP_D3_I3D(InstData &inst, uint32_t bits);
static bool TryExtractLD3_ASISDLSOP_DX3_R3D(InstData &inst, uint32_t bits);
static bool TryExtractFRINTN_ASIMDMISCFP16_R(InstData &inst, uint32_t bits);
static bool TryExtractFRINTN_ASIMDMISC_R(InstData &inst, uint32_t bits);
static bool TryExtractSUB_32_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractSUB_64_ADDSUB_EXT(InstData &inst, uint32_t bits);
static bool TryExtractSTR_B_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSTR_BL_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSTR_H_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSTR_S_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSTR_D_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSTR_Q_LDST_REGOFF(InstData &inst, uint32_t bits);
static bool TryExtractSTP_32_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractSTP_64_LDSTPAIR_POST(InstData &inst, uint32_t bits);
static bool TryExtractSTP_32_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractSTP_64_LDSTPAIR_PRE(InstData &inst, uint32_t bits);
static bool TryExtractSTP_32_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractSTP_64_LDSTPAIR_OFF(InstData &inst, uint32_t bits);
static bool TryExtractORN_32_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractORN_64_LOG_SHIFT(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRAB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRALB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractLDCLRLB_32_MEMOP(InstData &inst, uint32_t bits);
static bool TryExtractCNTB_X64_BITCOUNT(InstData &inst, uint32_t bits);
static bool TryExtractCNTD_X64_BITCOUNT(InstData &inst, uint32_t bits);
static bool TryExtractCNTH_X64_BITCOUNT(InstData &inst, uint32_t bits);
static bool TryExtractCNTW_X64_BITCOUNT(InstData &inst, uint32_t bits);
static bool TryExtractWHILELO_PREDICATE(InstData &inst, uint32_t bits);

static bool TryExtractFRECPX_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110111110011111100000000000
  if ((bits & 0xfffffc00U) != 0x5ef9f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRECPX_ASISDMISCFP16_R;
  inst.iclass = InstName::FRECPX;
  return true;
}

static bool TryExtractFRECPX_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110101000011111100000000000
  if ((bits & 0xffbffc00U) != 0x5ea1f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRECPX_ASISDMISC_R;
  inst.iclass = InstName::FRECPX;
  return true;
}

static bool TryExtractLDP_32_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101000110000000000000000000000
  if ((bits & 0xffc00000U) != 0x28c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_32_LDSTPAIR_POST;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_64_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101000110000000000000000000000
  if ((bits & 0xffc00000U) != 0xa8c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_64_LDSTPAIR_POST;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_32_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101001110000000000000000000000
  if ((bits & 0xffc00000U) != 0x29c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_32_LDSTPAIR_PRE;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_64_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101001110000000000000000000000
  if ((bits & 0xffc00000U) != 0xa9c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_64_LDSTPAIR_PRE;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_32_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101001010000000000000000000000
  if ((bits & 0xffc00000U) != 0x29400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_32_LDSTPAIR_OFF;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_64_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101001010000000000000000000000
  if ((bits & 0xffc00000U) != 0xa9400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_64_LDSTPAIR_OFF;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractSTSMAXH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000001000000100000000011111
  if ((bits & 0xffe0fc1fU) != 0x7820401fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMAXH_32S_MEMOP;
  inst.iclass = InstName::STSMAXH;
  return true;
}

static bool TryExtractSTSMAXLH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000011000000100000000011111
  if ((bits & 0xffe0fc1fU) != 0x7860401fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMAXLH_32S_MEMOP;
  inst.iclass = InstName::STSMAXLH;
  return true;
}

static bool TryExtractREV_32_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011010110000000000100000000000
  if ((bits & 0xfffffc00U) != 0x5ac00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opc : 2;
      uint32_t opcode : 4;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.iform = InstForm::REV_32_DP_1SRC;
  inst.iclass = InstName::REV;
  return true;
}

static bool TryExtractREV_64_DP_1SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractREV64_REV_64_DP_1SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11011010110000000000110000000000
  if ((bits & 0xfffffc00U) != 0xdac00c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opc : 2;
      uint32_t opcode : 4;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.iform = InstForm::REV_64_DP_1SRC;
  inst.iclass = InstName::REV;
  return true;
}

static bool TryExtractUBFX_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01010011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x53000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::UBFX_UBFM_32M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractUBFX_UBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   11010011010000000000000000000000
  if ((bits & 0xffc00000U) != 0xd3400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::UBFX_UBFM_64M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractUMINV_ASIMDALL_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001100011010100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e31a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t op : 1;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMINV_ASIMDALL_ONLY;
  inst.iclass = InstName::UMINV;
  return true;
}

static bool TryExtractFADDP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110010000000001010000000000
  if ((bits & 0xbfe0fc00U) != 0x2e401400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FADDP_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FADDP;
  return true;
}

static bool TryExtractFADDP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110001000001101010000000000
  if ((bits & 0xbfa0fc00U) != 0x2e20d400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FADDP_ASIMDSAME_ONLY;
  inst.iclass = InstName::FADDP;
  return true;
}

static bool TryExtractFABS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110111110001111100000000000
  if ((bits & 0xbffffc00U) != 0xef8f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FABS_ASIMDMISCFP16_R;
  inst.iclass = InstName::FABS;
  return true;
}

static bool TryExtractFABS_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000001111100000000000
  if ((bits & 0xbfbffc00U) != 0xea0f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FABS_ASIMDMISC_R;
  inst.iclass = InstName::FABS;
  return true;
}

static bool TryExtractMADD_32A_DP_3SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractMUL_MADD_32A_DP_3SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011011000000000000000000000000
  if ((bits & 0xffe08000U) != 0x1b000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t op31 : 3;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.op31 = static_cast<uint8_t>(enc.op31);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MADD_32A_DP_3SRC;
  inst.iclass = InstName::MADD;
  return true;
}

static bool TryExtractMADD_64A_DP_3SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractMUL_MADD_64A_DP_3SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   10011011000000000000000000000000
  if ((bits & 0xffe08000U) != 0x9b000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t op31 : 3;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.op31 = static_cast<uint8_t>(enc.op31);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MADD_64A_DP_3SRC;
  inst.iclass = InstName::MADD;
  return true;
}

static bool TryExtractSCVTF_ASISDSHF_C(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000001110010000000000
  if ((bits & 0xff80fc00U) != 0x5f00e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SCVTF_ASISDSHF_C;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_ASIMDSHF_C(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000001110010000000000
  if ((bits & 0xbf80fc00U) != 0xf00e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SCVTF_ASIMDSHF_C;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractCLZ_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000000100100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e204800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CLZ_ASIMDMISC_R;
  inst.iclass = InstName::CLZ;
  return true;
}

static bool TryExtractFCVT_SH_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000100100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee24000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 1
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FCVT_SH_FLOATDP1;
  inst.iclass = InstName::FCVT;
  return true;
}

static bool TryExtractFCVT_DH_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000101100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee2c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 1
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FCVT_DH_FLOATDP1;
  inst.iclass = InstName::FCVT;
  return true;
}

static bool TryExtractFCVT_HS_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000111100000000000000
  if ((bits & 0xfffffc00U) != 0x1e23c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 1
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FCVT_HS_FLOATDP1;
  inst.iclass = InstName::FCVT;
  return true;
}

static bool TryExtractFCVT_DS_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000101100000000000000
  if ((bits & 0xfffffc00U) != 0x1e22c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 1
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FCVT_DS_FLOATDP1;
  inst.iclass = InstName::FCVT;
  return true;
}

static bool TryExtractFCVT_HD_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000111100000000000000
  if ((bits & 0xfffffc00U) != 0x1e63c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 1
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FCVT_HD_FLOATDP1;
  inst.iclass = InstName::FCVT;
  return true;
}

static bool TryExtractFCVT_SD_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000100100000000000000
  if ((bits & 0xfffffc00U) != 0x1e624000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 1
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FCVT_SD_FLOATDP1;
  inst.iclass = InstName::FCVT;
  return true;
}

static bool TryExtractLDLARH_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001000110111110111110000000000
  if ((bits & 0xfffffc00U) != 0x48df7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDLARH_LR32_LDSTEXCL;
  inst.iclass = InstName::LDLARH;
  return true;
}

static bool TryExtractLDUR_B_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100010000000000000000000000
  if ((bits & 0xffe00c00U) != 0x3c400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUR_B_LDST_UNSCALED;
  inst.iclass = InstName::LDUR;
  return true;
}

static bool TryExtractLDUR_H_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111100010000000000000000000000
  if ((bits & 0xffe00c00U) != 0x7c400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUR_H_LDST_UNSCALED;
  inst.iclass = InstName::LDUR;
  return true;
}

static bool TryExtractLDUR_S_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111100010000000000000000000000
  if ((bits & 0xffe00c00U) != 0xbc400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUR_S_LDST_UNSCALED;
  inst.iclass = InstName::LDUR;
  return true;
}

static bool TryExtractLDUR_D_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111100010000000000000000000000
  if ((bits & 0xffe00c00U) != 0xfc400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUR_D_LDST_UNSCALED;
  inst.iclass = InstName::LDUR;
  return true;
}

static bool TryExtractLDUR_Q_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100110000000000000000000000
  if ((bits & 0xffe00c00U) != 0x3cc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUR_Q_LDST_UNSCALED;
  inst.iclass = InstName::LDUR;
  return true;
}

static bool TryExtractCLZ_32_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011010110000000001000000000000
  if ((bits & 0xfffffc00U) != 0x5ac01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op : 1;
      uint32_t opcode : 5;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CLZ_32_DP_1SRC;
  inst.iclass = InstName::CLZ;
  return true;
}

static bool TryExtractCLZ_64_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11011010110000000001000000000000
  if ((bits & 0xfffffc00U) != 0xdac01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op : 1;
      uint32_t opcode : 5;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CLZ_64_DP_1SRC;
  inst.iclass = InstName::CLZ;
  return true;
}

static bool TryExtractLSR_LSRV_32_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000010010000000000
  if ((bits & 0xffe0fc00U) != 0x1ac02400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::LSR_LSRV_32_DP_2SRC;
  inst.iclass = InstName::LSRV;
  return true;
}

static bool TryExtractLSR_LSRV_64_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000010010000000000
  if ((bits & 0xffe0fc00U) != 0x9ac02400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::LSR_LSRV_64_DP_2SRC;
  inst.iclass = InstName::LSRV;
  return true;
}

static bool TryExtractFCVTN_ASIMDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110001000010110100000000000
  if ((bits & 0xbfbffc00U) != 0xe216800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCVTN_ASIMDMISC_N;
  inst.iclass = InstName::FCVTN;
  return true;
}

static bool TryExtractCNEG_CSNEG_32_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01011010100000000000010000000000
  if ((bits & 0xffe00c00U) != 0x5a800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CNEG_CSNEG_32_CONDSEL;
  inst.iclass = InstName::CSNEG;
  return true;
}

static bool TryExtractCNEG_CSNEG_64_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11011010100000000000010000000000
  if ((bits & 0xffe00c00U) != 0xda800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CNEG_CSNEG_64_CONDSEL;
  inst.iclass = InstName::CSNEG;
  return true;
}

static bool TryExtractLDRSH_32_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000110000000000010000000000
  if ((bits & 0xffe00c00U) != 0x78c00400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSH_32_LDST_IMMPOST;
  inst.iclass = InstName::LDRSH;
  return true;
}

static bool TryExtractLDRSH_64_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000100000000000010000000000
  if ((bits & 0xffe00c00U) != 0x78800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSH_64_LDST_IMMPOST;
  inst.iclass = InstName::LDRSH;
  return true;
}

static bool TryExtractLDRSH_32_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000110000000000110000000000
  if ((bits & 0xffe00c00U) != 0x78c00c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSH_32_LDST_IMMPRE;
  inst.iclass = InstName::LDRSH;
  return true;
}

static bool TryExtractLDRSH_64_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000100000000000110000000000
  if ((bits & 0xffe00c00U) != 0x78800c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSH_64_LDST_IMMPRE;
  inst.iclass = InstName::LDRSH;
  return true;
}

static bool TryExtractLDRSH_32_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01111001110000000000000000000000
  if ((bits & 0xffc00000U) != 0x79c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSH_32_LDST_POS;
  inst.iclass = InstName::LDRSH;
  return true;
}

static bool TryExtractLDRSH_64_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01111001100000000000000000000000
  if ((bits & 0xffc00000U) != 0x79800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSH_64_LDST_POS;
  inst.iclass = InstName::LDRSH;
  return true;
}

static bool TryExtractABS_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01011110001000001011100000000000
  if ((bits & 0xff3ffc00U) != 0x5e20b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ABS_ASISDMISC_R;
  inst.iclass = InstName::ABS;
  return true;
}

static bool TryExtractABS_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000001011100000000000
  if ((bits & 0xbf3ffc00U) != 0xe20b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ABS_ASIMDMISC_R;
  inst.iclass = InstName::ABS;
  return true;
}

static bool TryExtractCMP_SUBS_32S_ADDSUB_EXT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   01101011001000000000000000011111
  if ((bits & 0xffe0001fU) != 0x6b20001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMP_SUBS_32S_ADDSUB_EXT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractCMP_SUBS_64S_ADDSUB_EXT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   11101011001000000000000000011111
  if ((bits & 0xffe0001fU) != 0xeb20001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMP_SUBS_64S_ADDSUB_EXT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractHINT_1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111011111
  //   --------------------------------
  //   11010101000000110010000011011111
  if ((bits & 0xffffffdfU) != 0xd50320dfU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::HINT_1;
  inst.iclass = InstName::HINT;
  return true;
}

static bool TryExtractHINT_2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111000000011111
  //   --------------------------------
  //   11010101000000110010000000011111
  if ((bits & 0xfffff01fU) != 0xd503201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::HINT_2;
  inst.iclass = InstName::HINT;
  return true;
}

static bool TryExtractHINT_3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111100011111
  //   --------------------------------
  //   11010101000000110010001000011111
  if ((bits & 0xffffff1fU) != 0xd503221fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::HINT_3;
  inst.iclass = InstName::HINT;
  return true;
}

static bool TryExtractFMAX_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110010000000011010000000000
  if ((bits & 0xbfe0fc00U) != 0xe403400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAX_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMAX;
  return true;
}

static bool TryExtractFMAX_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110001000001111010000000000
  if ((bits & 0xbfa0fc00U) != 0xe20f400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAX_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMAX;
  return true;
}

static bool TryExtractFMIN_H_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110111000000101100000000000
  if ((bits & 0xffe0fc00U) != 0x1ee05800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMIN_H_FLOATDP2;
  inst.iclass = InstName::FMIN;
  return true;
}

static bool TryExtractFMIN_S_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110001000000101100000000000
  if ((bits & 0xffe0fc00U) != 0x1e205800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMIN_S_FLOATDP2;
  inst.iclass = InstName::FMIN;
  return true;
}

static bool TryExtractFMIN_D_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110011000000101100000000000
  if ((bits & 0xffe0fc00U) != 0x1e605800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMIN_D_FLOATDP2;
  inst.iclass = InstName::FMIN;
  return true;
}

static bool TryExtractUMLSL_ASIMDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00101111000000000110000000000000
  if ((bits & 0xbf00f400U) != 0x2f006000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMLSL_ASIMDELEM_L;
  inst.iclass = InstName::UMLSL;
  return true;
}

static bool TryExtractFMAXNM_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110010000000000010000000000
  if ((bits & 0xbfe0fc00U) != 0xe400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t Op3 : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Op3 = static_cast<uint8_t>(enc.Op3);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FMAXNM_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMAXNM;
  return true;
}

static bool TryExtractFMAXNM_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110001000001100010000000000
  if ((bits & 0xbfa0fc00U) != 0xe20c400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXNM_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMAXNM;
  return true;
}

static bool TryExtractFCVTPS_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111010000000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee80000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPS_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractFCVTPS_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111010000000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee80000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPS_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractFCVTPS_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001010000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e280000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPS_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractFCVTPS_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001010000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e280000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPS_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractFCVTPS_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011010000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e680000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPS_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractFCVTPS_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011010000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e680000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPS_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractFMINNM_H_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110111000000111100000000000
  if ((bits & 0xffe0fc00U) != 0x1ee07800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMINNM_H_FLOATDP2;
  inst.iclass = InstName::FMINNM;
  return true;
}

static bool TryExtractFMINNM_S_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110001000000111100000000000
  if ((bits & 0xffe0fc00U) != 0x1e207800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMINNM_S_FLOATDP2;
  inst.iclass = InstName::FMINNM;
  return true;
}

static bool TryExtractFMINNM_D_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110011000000111100000000000
  if ((bits & 0xffe0fc00U) != 0x1e607800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMINNM_D_FLOATDP2;
  inst.iclass = InstName::FMINNM;
  return true;
}

static bool TryExtractLDTRSW_64_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000100000000000100000000000
  if ((bits & 0xffe00c00U) != 0xb8800800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDTRSW_64_LDST_UNPRIV;
  inst.iclass = InstName::LDTRSW;
  return true;
}

static bool TryExtractFSQRT_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000011100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee1c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FSQRT_H_FLOATDP1;
  inst.iclass = InstName::FSQRT;
  return true;
}

static bool TryExtractFSQRT_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000011100000000000000
  if ((bits & 0xfffffc00U) != 0x1e21c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FSQRT_S_FLOATDP1;
  inst.iclass = InstName::FSQRT;
  return true;
}

static bool TryExtractFSQRT_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000011100000000000000
  if ((bits & 0xfffffc00U) != 0x1e61c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FSQRT_D_FLOATDP1;
  inst.iclass = InstName::FSQRT;
  return true;
}

static bool TryExtractLDEORA_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000101000000010000000000000
  if ((bits & 0xffe0fc00U) != 0xb8a02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORA_32_MEMOP;
  inst.iclass = InstName::LDEORA;
  return true;
}

static bool TryExtractLDEORAL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000111000000010000000000000
  if ((bits & 0xffe0fc00U) != 0xb8e02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORAL_32_MEMOP;
  inst.iclass = InstName::LDEORAL;
  return true;
}

static bool TryExtractLDEOR_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000001000000010000000000000
  if ((bits & 0xffe0fc00U) != 0xb8202000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEOR_32_MEMOP;
  inst.iclass = InstName::LDEOR;
  return true;
}

static bool TryExtractLDEORL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000011000000010000000000000
  if ((bits & 0xffe0fc00U) != 0xb8602000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORL_32_MEMOP;
  inst.iclass = InstName::LDEORL;
  return true;
}

static bool TryExtractLDEORA_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000101000000010000000000000
  if ((bits & 0xffe0fc00U) != 0xf8a02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORA_64_MEMOP;
  inst.iclass = InstName::LDEORA;
  return true;
}

static bool TryExtractLDEORAL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000111000000010000000000000
  if ((bits & 0xffe0fc00U) != 0xf8e02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORAL_64_MEMOP;
  inst.iclass = InstName::LDEORAL;
  return true;
}

static bool TryExtractLDEOR_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000001000000010000000000000
  if ((bits & 0xffe0fc00U) != 0xf8202000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEOR_64_MEMOP;
  inst.iclass = InstName::LDEOR;
  return true;
}

static bool TryExtractLDEORL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000011000000010000000000000
  if ((bits & 0xffe0fc00U) != 0xf8602000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORL_64_MEMOP;
  inst.iclass = InstName::LDEORL;
  return true;
}

static bool TryExtractSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000001000010000000000
  if ((bits & 0xbf80fc00U) != 0xf008400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SHRN_ASIMDSHF_N;
  inst.iclass = InstName::SHRN;
  return true;
}

static bool TryExtractFRINTM_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001010100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee54000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTM_H_FLOATDP1;
  inst.iclass = InstName::FRINTM;
  return true;
}

static bool TryExtractFRINTM_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001010100000000000000
  if ((bits & 0xfffffc00U) != 0x1e254000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTM_S_FLOATDP1;
  inst.iclass = InstName::FRINTM;
  return true;
}

static bool TryExtractFRINTM_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011001010100000000000000
  if ((bits & 0xfffffc00U) != 0x1e654000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTM_D_FLOATDP1;
  inst.iclass = InstName::FRINTM;
  return true;
}

static bool TryExtractLDUMINAB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000101000000111000000000000
  if ((bits & 0xffe0fc00U) != 0x38a07000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINAB_32_MEMOP;
  inst.iclass = InstName::LDUMINAB;
  return true;
}

static bool TryExtractLDUMINALB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000111000000111000000000000
  if ((bits & 0xffe0fc00U) != 0x38e07000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINALB_32_MEMOP;
  inst.iclass = InstName::LDUMINALB;
  return true;
}

static bool TryExtractLDUMINB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000001000000111000000000000
  if ((bits & 0xffe0fc00U) != 0x38207000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINB_32_MEMOP;
  inst.iclass = InstName::LDUMINB;
  return true;
}

static bool TryExtractLDUMINLB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000011000000111000000000000
  if ((bits & 0xffe0fc00U) != 0x38607000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINLB_32_MEMOP;
  inst.iclass = InstName::LDUMINLB;
  return true;
}

static bool TryExtractSHA256SU0_VV_CRYPTOSHA2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110001010000010100000000000
  if ((bits & 0xfffffc00U) != 0x5e282800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHA256SU0_VV_CRYPTOSHA2;
  inst.iclass = InstName::SHA256SU0;
  return true;
}

static bool TryExtractFMINP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110110000000011010000000000
  if ((bits & 0xbfe0fc00U) != 0x2ec03400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINP_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMINP;
  return true;
}

static bool TryExtractFMINP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110101000001111010000000000
  if ((bits & 0xbfa0fc00U) != 0x2ea0f400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINP_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMINP;
  return true;
}

static bool TryExtractBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {
  if (false && TryExtractBFC_BFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractBFXIL_BFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractBFI_BFM_32M_BITFIELD(inst, bits))
    return true;

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00110011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x33000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::BFM_32M_BITFIELD;
  inst.iclass = InstName::BFM;
  return true;
}

static bool TryExtractBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {
  if (false && TryExtractBFC_BFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractBFXIL_BFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractBFI_BFM_64M_BITFIELD(inst, bits))
    return true;

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10110011010000000000000000000000
  if ((bits & 0xffc00000U) != 0xb3400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::BFM_64M_BITFIELD;
  inst.iclass = InstName::BFM;
  return true;
}

static bool TryExtractLDR_B_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100011000000000100000000000
  if ((bits & 0xffe00c00U) != 0x3c600800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_B_LDST_REGOFF;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_BL_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001110110000000000
  //   --------------------------------
  //   00111100011000000110100000000000
  if ((bits & 0xffe0ec00U) != 0x3c606800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_BL_LDST_REGOFF;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_H_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111100011000000000100000000000
  if ((bits & 0xffe00c00U) != 0x7c600800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_H_LDST_REGOFF;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_S_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111100011000000000100000000000
  if ((bits & 0xffe00c00U) != 0xbc600800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_S_LDST_REGOFF;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_D_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111100011000000000100000000000
  if ((bits & 0xffe00c00U) != 0xfc600800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_D_LDST_REGOFF;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_Q_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100111000000000100000000000
  if ((bits & 0xffe00c00U) != 0x3ce00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_Q_LDST_REGOFF;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractSQRDMLSH_ASISDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000001111010000000000
  //   --------------------------------
  //   01111111000000001111000000000000
  if ((bits & 0xff00f400U) != 0x7f00f000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t S : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMLSH_ASISDELEM_R;
  inst.iclass = InstName::SQRDMLSH;
  return true;
}

static bool TryExtractSQRDMLSH_ASIMDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00101111000000001111000000000000
  if ((bits & 0xbf00f400U) != 0x2f00f000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t S : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMLSH_ASIMDELEM_R;
  inst.iclass = InstName::SQRDMLSH;
  return true;
}

static bool TryExtractANDS_32S_LOG_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractTST_ANDS_32S_LOG_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01110010000000000000000000000000
  if ((bits & 0xffc00000U) != 0x72000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::ANDS_32S_LOG_IMM;
  inst.iclass = InstName::ANDS;
  return true;
}

static bool TryExtractANDS_64S_LOG_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractTST_ANDS_64S_LOG_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   11110010000000000000000000000000
  if ((bits & 0xff800000U) != 0xf2000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::ANDS_64S_LOG_IMM;
  inst.iclass = InstName::ANDS;
  return true;
}

static bool TryExtractLDCLRA_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000101000000001000000000000
  if ((bits & 0xffe0fc00U) != 0xb8a01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRA_32_MEMOP;
  inst.iclass = InstName::LDCLRA;
  return true;
}

static bool TryExtractLDCLRAL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000111000000001000000000000
  if ((bits & 0xffe0fc00U) != 0xb8e01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRAL_32_MEMOP;
  inst.iclass = InstName::LDCLRAL;
  return true;
}

static bool TryExtractLDCLR_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000001000000001000000000000
  if ((bits & 0xffe0fc00U) != 0xb8201000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLR_32_MEMOP;
  inst.iclass = InstName::LDCLR;
  return true;
}

static bool TryExtractLDCLRL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000011000000001000000000000
  if ((bits & 0xffe0fc00U) != 0xb8601000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRL_32_MEMOP;
  inst.iclass = InstName::LDCLRL;
  return true;
}

static bool TryExtractLDCLRA_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000101000000001000000000000
  if ((bits & 0xffe0fc00U) != 0xf8a01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRA_64_MEMOP;
  inst.iclass = InstName::LDCLRA;
  return true;
}

static bool TryExtractLDCLRAL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000111000000001000000000000
  if ((bits & 0xffe0fc00U) != 0xf8e01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRAL_64_MEMOP;
  inst.iclass = InstName::LDCLRAL;
  return true;
}

static bool TryExtractLDCLR_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000001000000001000000000000
  if ((bits & 0xffe0fc00U) != 0xf8201000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLR_64_MEMOP;
  inst.iclass = InstName::LDCLR;
  return true;
}

static bool TryExtractLDCLRL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000011000000001000000000000
  if ((bits & 0xffe0fc00U) != 0xf8601000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRL_64_MEMOP;
  inst.iclass = InstName::LDCLRL;
  return true;
}

static bool TryExtractUABD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000111010000000000
  if ((bits & 0xbf20fc00U) != 0x2e207400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UABD_ASIMDSAME_ONLY;
  inst.iclass = InstName::UABD;
  return true;
}

static bool TryExtractSTURB_32_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000000000000000000000000000
  if ((bits & 0xffe00c00U) != 0x38000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STURB_32_LDST_UNSCALED;
  inst.iclass = InstName::STURB;
  return true;
}

static bool TryExtractORR_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_ORR_ASIMDSAME_ONLY(inst, bits))
    return true;

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110101000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0xea01c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ORR_ASIMDSAME_ONLY;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractFRINTA_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110011110011000100000000000
  if ((bits & 0xbffffc00U) != 0x2e798800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTA_ASIMDMISCFP16_R;
  inst.iclass = InstName::FRINTA;
  return true;
}

static bool TryExtractFRINTA_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110001000011000100000000000
  if ((bits & 0xbfbffc00U) != 0x2e218800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTA_ASIMDMISC_R;
  inst.iclass = InstName::FRINTA;
  return true;
}

static bool TryExtractSUBS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMP_SUBS_32_ADDSUB_SHIFT(inst, bits))
    return true;
  if (false && TryExtractNEGS_SUBS_32_ADDSUB_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   01101011000000000000000000000000
  if ((bits & 0xff200000U) != 0x6b000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::SUBS_32_ADDSUB_SHIFT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractSUBS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractNEGS_SUBS_64_ADDSUB_SHIFT(inst, bits))
    return true;
  if (false && TryExtractCMP_SUBS_64_ADDSUB_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   11101011000000000000000000000000
  if ((bits & 0xff200000U) != 0xeb000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::SUBS_64_ADDSUB_SHIFT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractSTXP_SP32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   10001000001000000000000000000000
  if ((bits & 0xffe08000U) != 0x88200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STXP_SP32_LDSTEXCL;
  inst.iclass = InstName::STXP;
  return true;
}

static bool TryExtractSTXP_SP64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   11001000001000000000000000000000
  if ((bits & 0xffe08000U) != 0xc8200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STXP_SP64_LDSTEXCL;
  inst.iclass = InstName::STXP;
  return true;
}

static bool TryExtractSBFX_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00010011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x13000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SBFX_SBFM_32M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractSBFX_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10010011010000000000000000000000
  if ((bits & 0xffc00000U) != 0x93400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SBFX_SBFM_64M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractLDXP_LP32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111000000000000000
  //   --------------------------------
  //   10001000011111110000000000000000
  if ((bits & 0xffff8000U) != 0x887f0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDXP_LP32_LDSTEXCL;
  inst.iclass = InstName::LDXP;
  return true;
}

static bool TryExtractLDXP_LP64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111000000000000000
  //   --------------------------------
  //   11001000011111110000000000000000
  if ((bits & 0xffff8000U) != 0xc87f0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDXP_LP64_LDSTEXCL;
  inst.iclass = InstName::LDXP;
  return true;
}

static bool TryExtractORR_32_LOG_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_ORR_32_LOG_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00110010000000000000000000000000
  if ((bits & 0xffc00000U) != 0x32000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::ORR_32_LOG_IMM;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractORR_64_LOG_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_ORR_64_LOG_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   10110010000000000000000000000000
  if ((bits & 0xff800000U) != 0xb2000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::ORR_64_LOG_IMM;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractUCVTF_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01111110011110011101100000000000
  if ((bits & 0xfffffc00U) != 0x7e79d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::UCVTF_ASISDMISCFP16_R;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110001000011101100000000000
  if ((bits & 0xffbffc00U) != 0x7e21d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::UCVTF_ASISDMISC_R;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110011110011101100000000000
  if ((bits & 0xbffffc00U) != 0x2e79d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::UCVTF_ASIMDMISCFP16_R;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110001000011101100000000000
  if ((bits & 0xbfbffc00U) != 0x2e21d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::UCVTF_ASIMDMISC_R;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractSQDMULH_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000001011010000000000
  if ((bits & 0xff20fc00U) != 0x5e20b400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMULH_ASISDSAME_ONLY;
  inst.iclass = InstName::SQDMULH;
  return true;
}

static bool TryExtractSQDMULH_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001011010000000000
  if ((bits & 0xbf20fc00U) != 0xe20b400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMULH_ASIMDSAME_ONLY;
  inst.iclass = InstName::SQDMULH;
  return true;
}

static bool TryExtractFCVTL_ASIMDMISC_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110001000010111100000000000
  if ((bits & 0xbfbffc00U) != 0xe217800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCVTL_ASIMDMISC_L;
  inst.iclass = InstName::FCVTL;
  return true;
}

static bool TryExtractCCMN_32_CONDCMP_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   00111010010000000000100000000000
  if ((bits & 0xffe00c10U) != 0x3a400800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t o3 : 1;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 1
      uint32_t cond : 4;
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CCMN_32_CONDCMP_IMM;
  inst.iclass = InstName::CCMN;
  return true;
}

static bool TryExtractCCMN_64_CONDCMP_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   10111010010000000000100000000000
  if ((bits & 0xffe00c10U) != 0xba400800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t o3 : 1;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 1
      uint32_t cond : 4;
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CCMN_64_CONDCMP_IMM;
  inst.iclass = InstName::CCMN;
  return true;
}

static bool TryExtractDMB_BO_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111000011111111
  //   --------------------------------
  //   11010101000000110011000010111111
  if ((bits & 0xfffff0ffU) != 0xd50330bfU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t opc : 2;
      uint32_t _7 : 1;  // 1
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::DMB_BO_SYSTEM;
  inst.iclass = InstName::DMB;
  return true;
}

static bool TryExtractYIELD_HI_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010101000000110010000000111111
  if ((bits & 0xffffffffU) != 0xd503203fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::YIELD_HI_SYSTEM;
  inst.iclass = InstName::YIELD;
  return true;
}

static bool TryExtractUXTH_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01010011000000000011110000000000
  if ((bits & 0xfffffc00U) != 0x53003c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::UXTH_UBFM_32M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractSTADD_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000001000000000000000011111
  if ((bits & 0xffe0fc1fU) != 0xb820001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STADD_32S_MEMOP;
  inst.iclass = InstName::STADD;
  return true;
}

static bool TryExtractSTADDL_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000011000000000000000011111
  if ((bits & 0xffe0fc1fU) != 0xb860001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STADDL_32S_MEMOP;
  inst.iclass = InstName::STADDL;
  return true;
}

static bool TryExtractSTADD_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000001000000000000000011111
  if ((bits & 0xffe0fc1fU) != 0xf820001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STADD_64S_MEMOP;
  inst.iclass = InstName::STADD;
  return true;
}

static bool TryExtractSTADDL_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000011000000000000000011111
  if ((bits & 0xffe0fc1fU) != 0xf860001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STADDL_64S_MEMOP;
  inst.iclass = InstName::STADDL;
  return true;
}

static bool TryExtractUSRA_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000000001010000000000
  if ((bits & 0xff80fc00U) != 0x7f001400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::USRA_ASISDSHF_R;
  inst.iclass = InstName::USRA;
  return true;
}

static bool TryExtractUSRA_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000000001010000000000
  if ((bits & 0xbf80fc00U) != 0x2f001400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::USRA_ASIMDSHF_R;
  inst.iclass = InstName::USRA;
  return true;
}

static bool TryExtractMOV_MOVZ_32_MOVEWIDE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   01010010100000000000000000000000
  if ((bits & 0xff800000U) != 0x52800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOV_MOVZ_32_MOVEWIDE;
  inst.iclass = InstName::MOVZ;
  return true;
}

static bool TryExtractMOV_MOVZ_64_MOVEWIDE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   11010010100000000000000000000000
  if ((bits & 0xff800000U) != 0xd2800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOV_MOVZ_64_MOVEWIDE;
  inst.iclass = InstName::MOVZ;
  return true;
}

static bool TryExtractMLS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001001010000000000
  if ((bits & 0xbf20fc00U) != 0x2e209400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::MLS_ASIMDSAME_ONLY;
  inst.iclass = InstName::MLS;
  return true;
}

static bool TryExtractST1_ASISDLSE_R1_1V(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100000000000111000000000000
  if ((bits & 0xbffff000U) != 0xc007000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSE_R1_1V;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSE_R2_2V(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100000000001010000000000000
  if ((bits & 0xbffff000U) != 0xc00a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSE_R2_2V;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSE_R3_3V(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100000000000110000000000000
  if ((bits & 0xbffff000U) != 0xc006000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSE_R3_3V;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSE_R4_4V(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100000000000010000000000000
  if ((bits & 0xbffff000U) != 0xc002000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSE_R4_4V;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSEP_I1_I1(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100100111110111000000000000
  if ((bits & 0xbffff000U) != 0xc9f7000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSEP_I1_I1;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSEP_R1_R1(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100100000000111000000000000
  if ((bits & 0xbfe0f000U) != 0xc807000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSEP_R1_R1;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSEP_I2_I2(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100100111111010000000000000
  if ((bits & 0xbffff000U) != 0xc9fa000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSEP_I2_I2;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSEP_R2_R2(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100100000001010000000000000
  if ((bits & 0xbfe0f000U) != 0xc80a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSEP_R2_R2;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSEP_I3_I3(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100100111110110000000000000
  if ((bits & 0xbffff000U) != 0xc9f6000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSEP_I3_I3;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSEP_R3_R3(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100100000000110000000000000
  if ((bits & 0xbfe0f000U) != 0xc806000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSEP_R3_R3;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSEP_I4_I4(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100100111110010000000000000
  if ((bits & 0xbffff000U) != 0xc9f2000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSEP_I4_I4;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSEP_R4_R4(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100100000000010000000000000
  if ((bits & 0xbfe0f000U) != 0xc802000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSEP_R4_R4;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractAESIMC_B_CRYPTOAES(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001110001010000111100000000000
  if ((bits & 0xfffffc00U) != 0x4e287800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t D : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.D = static_cast<uint8_t>(enc.D);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::AESIMC_B_CRYPTOAES;
  inst.iclass = InstName::AESIMC;
  return true;
}

static bool TryExtractUMULH_64_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011011110000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x9bc07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::UMULH_64_DP_3SRC;
  inst.iclass = InstName::UMULH;
  return true;
}

static bool TryExtractUADDW_ASIMDDIFF_W(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000001000000000000
  if ((bits & 0xbf20fc00U) != 0x2e201000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UADDW_ASIMDDIFF_W;
  inst.iclass = InstName::UADDW;
  return true;
}

static bool TryExtractSTRH_32_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000000000000000010000000000
  if ((bits & 0xffe00c00U) != 0x78000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STRH_32_LDST_IMMPOST;
  inst.iclass = InstName::STRH;
  return true;
}

static bool TryExtractSTRH_32_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000000000000000110000000000
  if ((bits & 0xffe00c00U) != 0x78000c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STRH_32_LDST_IMMPRE;
  inst.iclass = InstName::STRH;
  return true;
}

static bool TryExtractSTRH_32_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01111001000000000000000000000000
  if ((bits & 0xffc00000U) != 0x79000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STRH_32_LDST_POS;
  inst.iclass = InstName::STRH;
  return true;
}

static bool TryExtractSCVTF_H32_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000100000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee20000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_H32_FLOAT2INT;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_S32_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000100000000000000000
  if ((bits & 0xfffffc00U) != 0x1e220000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_S32_FLOAT2INT;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_D32_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000100000000000000000
  if ((bits & 0xfffffc00U) != 0x1e620000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_D32_FLOAT2INT;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_H64_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111000100000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee20000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_H64_FLOAT2INT;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_S64_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001000100000000000000000
  if ((bits & 0xfffffc00U) != 0x9e220000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_S64_FLOAT2INT;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_D64_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011000100000000000000000
  if ((bits & 0xfffffc00U) != 0x9e620000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_D64_FLOAT2INT;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSTUMAXB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000001000000110000000011111
  if ((bits & 0xffe0fc1fU) != 0x3820601fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMAXB_32S_MEMOP;
  inst.iclass = InstName::STUMAXB;
  return true;
}

static bool TryExtractSTUMAXLB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000011000000110000000011111
  if ((bits & 0xffe0fc1fU) != 0x3860601fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMAXLB_32S_MEMOP;
  inst.iclass = InstName::STUMAXLB;
  return true;
}

static bool TryExtractCMHI_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000000011010000000000
  if ((bits & 0xff20fc00U) != 0x7e203400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t eq : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.eq = static_cast<uint8_t>(enc.eq);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMHI_ASISDSAME_ONLY;
  inst.iclass = InstName::CMHI;
  return true;
}

static bool TryExtractCMHI_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000011010000000000
  if ((bits & 0xbf20fc00U) != 0x2e203400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t eq : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.eq = static_cast<uint8_t>(enc.eq);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMHI_ASIMDSAME_ONLY;
  inst.iclass = InstName::CMHI;
  return true;
}

static bool TryExtractSQDMLAL_ASISDDIFF_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000001001000000000000
  if ((bits & 0xff20fc00U) != 0x5e209000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMLAL_ASISDDIFF_ONLY;
  inst.iclass = InstName::SQDMLAL;
  return true;
}

static bool TryExtractSQDMLAL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001001000000000000
  if ((bits & 0xbf20fc00U) != 0xe209000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMLAL_ASIMDDIFF_L;
  inst.iclass = InstName::SQDMLAL;
  return true;
}

static bool TryExtractCBNZ_32_COMPBRANCH(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   00110101000000000000000000000000
  if ((bits & 0xff000000U) != 0x35000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t op : 1;
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CBNZ_32_COMPBRANCH;
  inst.iclass = InstName::CBNZ;
  return true;
}

static bool TryExtractCBNZ_64_COMPBRANCH(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   10110101000000000000000000000000
  if ((bits & 0xff000000U) != 0xb5000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t op : 1;
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CBNZ_64_COMPBRANCH;
  inst.iclass = InstName::CBNZ;
  return true;
}

static bool TryExtractSEVL_HI_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010101000000110010000010111111
  if ((bits & 0xffffffffU) != 0xd50320bfU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::SEVL_HI_SYSTEM;
  inst.iclass = InstName::SEVL;
  return true;
}

static bool TryExtractFRINTX_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001110100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee74000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTX_H_FLOATDP1;
  inst.iclass = InstName::FRINTX;
  return true;
}

static bool TryExtractFRINTX_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001110100000000000000
  if ((bits & 0xfffffc00U) != 0x1e274000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTX_S_FLOATDP1;
  inst.iclass = InstName::FRINTX;
  return true;
}

static bool TryExtractFRINTX_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011001110100000000000000
  if ((bits & 0xfffffc00U) != 0x1e674000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTX_D_FLOATDP1;
  inst.iclass = InstName::FRINTX;
  return true;
}

static bool TryExtractCMN_ADDS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000011111
  //   --------------------------------
  //   00101011000000000000000000011111
  if ((bits & 0xff20001fU) != 0x2b00001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::CMN_ADDS_32_ADDSUB_SHIFT;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractCMN_ADDS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000011111
  //   --------------------------------
  //   10101011000000000000000000011111
  if ((bits & 0xff20001fU) != 0xab00001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::CMN_ADDS_64_ADDSUB_SHIFT;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractSMIN_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000110110000000000
  if ((bits & 0xbf20fc00U) != 0xe206c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMIN_ASIMDSAME_ONLY;
  inst.iclass = InstName::SMIN;
  return true;
}

static bool TryExtractLDUMAXAB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000101000000110000000000000
  if ((bits & 0xffe0fc00U) != 0x38a06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXAB_32_MEMOP;
  inst.iclass = InstName::LDUMAXAB;
  return true;
}

static bool TryExtractLDUMAXALB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000111000000110000000000000
  if ((bits & 0xffe0fc00U) != 0x38e06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXALB_32_MEMOP;
  inst.iclass = InstName::LDUMAXALB;
  return true;
}

static bool TryExtractLDUMAXB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000001000000110000000000000
  if ((bits & 0xffe0fc00U) != 0x38206000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXB_32_MEMOP;
  inst.iclass = InstName::LDUMAXB;
  return true;
}

static bool TryExtractLDUMAXLB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000011000000110000000000000
  if ((bits & 0xffe0fc00U) != 0x38606000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXLB_32_MEMOP;
  inst.iclass = InstName::LDUMAXLB;
  return true;
}

static bool TryExtractAESE_B_CRYPTOAES(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001110001010000100100000000000
  if ((bits & 0xfffffc00U) != 0x4e284800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t D : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.D = static_cast<uint8_t>(enc.D);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::AESE_B_CRYPTOAES;
  inst.iclass = InstName::AESE;
  return true;
}

static bool TryExtractSMAXP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001010010000000000
  if ((bits & 0xbf20fc00U) != 0xe20a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMAXP_ASIMDSAME_ONLY;
  inst.iclass = InstName::SMAXP;
  return true;
}

static bool TryExtractSTXR_SR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10001000000000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x88007c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STXR_SR32_LDSTEXCL;
  inst.iclass = InstName::STXR;
  return true;
}

static bool TryExtractSTXR_SR64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11001000000000000111110000000000
  if ((bits & 0xffe0fc00U) != 0xc8007c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STXR_SR64_LDSTEXCL;
  inst.iclass = InstName::STXR;
  return true;
}

static bool TryExtractSUB_32_ADDSUB_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   01010001000000000000000000000000
  if ((bits & 0xff000000U) != 0x51000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SUB_32_ADDSUB_IMM;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractSUB_64_ADDSUB_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   11010001000000000000000000000000
  if ((bits & 0xff000000U) != 0xd1000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SUB_64_ADDSUB_IMM;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractCMLT_ASISDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01011110001000001010100000000000
  if ((bits & 0xff3ffc00U) != 0x5e20a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMLT_ASISDMISC_Z;
  inst.iclass = InstName::CMLT;
  return true;
}

static bool TryExtractCMLT_ASIMDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000001010100000000000
  if ((bits & 0xbf3ffc00U) != 0xe20a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMLT_ASIMDMISC_Z;
  inst.iclass = InstName::CMLT;
  return true;
}

static bool TryExtractFCMEQ_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110010000000010010000000000
  if ((bits & 0xffe0fc00U) != 0x5e402400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMEQ_ASISDSAMEFP16_ONLY;
  inst.iclass = InstName::FCMEQ;
  return true;
}

static bool TryExtractFCMEQ_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101000001111110000000000
  //   --------------------------------
  //   01011110001000001110010000000000
  if ((bits & 0xffa0fc00U) != 0x5e20e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMEQ_ASISDSAME_ONLY;
  inst.iclass = InstName::FCMEQ;
  return true;
}

static bool TryExtractFCMEQ_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110010000000010010000000000
  if ((bits & 0xbfe0fc00U) != 0xe402400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMEQ_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FCMEQ;
  return true;
}

static bool TryExtractFCMEQ_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110001000001110010000000000
  if ((bits & 0xbfa0fc00U) != 0xe20e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMEQ_ASIMDSAME_ONLY;
  inst.iclass = InstName::FCMEQ;
  return true;
}

static bool TryExtractCLREX_BN_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111000011111111
  //   --------------------------------
  //   11010101000000110011000001011111
  if ((bits & 0xfffff0ffU) != 0xd503305fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::CLREX_BN_SYSTEM;
  inst.iclass = InstName::CLREX;
  return true;
}

static bool TryExtractFSUB_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110110000000001010000000000
  if ((bits & 0xbfe0fc00U) != 0xec01400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FSUB_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FSUB;
  return true;
}

static bool TryExtractFSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110101000001101010000000000
  if ((bits & 0xbfa0fc00U) != 0xea0d400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FSUB_ASIMDSAME_ONLY;
  inst.iclass = InstName::FSUB;
  return true;
}

static bool TryExtractSHLL_ASIMDMISC_S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000010011100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e213800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHLL_ASIMDMISC_S;
  inst.iclass = InstName::SHLL;
  return true;
}

static bool TryExtractSQADD_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000000000110000000000
  if ((bits & 0xff20fc00U) != 0x5e200c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQADD_ASISDSAME_ONLY;
  inst.iclass = InstName::SQADD;
  return true;
}

static bool TryExtractSQADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000000110000000000
  if ((bits & 0xbf20fc00U) != 0xe200c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQADD_ASIMDSAME_ONLY;
  inst.iclass = InstName::SQADD;
  return true;
}

static bool TryExtractBIC_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110011000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0xe601c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::BIC_ASIMDSAME_ONLY;
  inst.iclass = InstName::BIC;
  return true;
}

static bool TryExtractSUB_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000001000010000000000
  if ((bits & 0xff20fc00U) != 0x7e208400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SUB_ASISDSAME_ONLY;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001000010000000000
  if ((bits & 0xbf20fc00U) != 0x2e208400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SUB_ASIMDSAME_ONLY;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractSWPA_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000101000001000000000000000
  if ((bits & 0xffe0fc00U) != 0xb8a08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPA_32_MEMOP;
  inst.iclass = InstName::SWPA;
  return true;
}

static bool TryExtractSWPAL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000111000001000000000000000
  if ((bits & 0xffe0fc00U) != 0xb8e08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPAL_32_MEMOP;
  inst.iclass = InstName::SWPAL;
  return true;
}

static bool TryExtractSWP_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000001000001000000000000000
  if ((bits & 0xffe0fc00U) != 0xb8208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWP_32_MEMOP;
  inst.iclass = InstName::SWP;
  return true;
}

static bool TryExtractSWPL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000011000001000000000000000
  if ((bits & 0xffe0fc00U) != 0xb8608000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPL_32_MEMOP;
  inst.iclass = InstName::SWPL;
  return true;
}

static bool TryExtractSWPA_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000101000001000000000000000
  if ((bits & 0xffe0fc00U) != 0xf8a08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPA_64_MEMOP;
  inst.iclass = InstName::SWPA;
  return true;
}

static bool TryExtractSWPAL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000111000001000000000000000
  if ((bits & 0xffe0fc00U) != 0xf8e08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPAL_64_MEMOP;
  inst.iclass = InstName::SWPAL;
  return true;
}

static bool TryExtractSWP_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000001000001000000000000000
  if ((bits & 0xffe0fc00U) != 0xf8208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWP_64_MEMOP;
  inst.iclass = InstName::SWP;
  return true;
}

static bool TryExtractSWPL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000011000001000000000000000
  if ((bits & 0xffe0fc00U) != 0xf8608000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPL_64_MEMOP;
  inst.iclass = InstName::SWPL;
  return true;
}

static bool TryExtractSMC_EX_EXCEPTION(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   11010100000000000000000000000011
  if ((bits & 0xffe0001fU) != 0xd4000003U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t LL : 2;
      uint32_t op2 : 3;
      uint32_t imm16 : 16;
      uint32_t opc : 3;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.LL = static_cast<uint8_t>(enc.LL);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::SMC_EX_EXCEPTION;
  inst.iclass = InstName::SMC;
  return true;
}

static bool TryExtractLDUR_32_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000010000000000000000000000
  if ((bits & 0xffe00c00U) != 0xb8400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUR_32_LDST_UNSCALED;
  inst.iclass = InstName::LDUR;
  return true;
}

static bool TryExtractLDUR_64_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000010000000000000000000000
  if ((bits & 0xffe00c00U) != 0xf8400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUR_64_LDST_UNSCALED;
  inst.iclass = InstName::LDUR;
  return true;
}

static bool TryExtractCMGE_ASISDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01111110001000001000100000000000
  if ((bits & 0xff3ffc00U) != 0x7e208800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMGE_ASISDMISC_Z;
  inst.iclass = InstName::CMGE;
  return true;
}

static bool TryExtractCMGE_ASIMDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000001000100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e208800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMGE_ASIMDMISC_Z;
  inst.iclass = InstName::CMGE;
  return true;
}

static bool TryExtractUCVTF_ASISDSHF_C(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000001110010000000000
  if ((bits & 0xff80fc00U) != 0x7f00e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::UCVTF_ASISDSHF_C;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_ASIMDSHF_C(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000001110010000000000
  if ((bits & 0xbf80fc00U) != 0x2f00e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::UCVTF_ASIMDSHF_C;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractSTLLR_SL32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10001000100111110111110000000000
  if ((bits & 0xfffffc00U) != 0x889f7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLLR_SL32_LDSTEXCL;
  inst.iclass = InstName::STLLR;
  return true;
}

static bool TryExtractSTLLR_SL64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11001000100111110111110000000000
  if ((bits & 0xfffffc00U) != 0xc89f7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLLR_SL64_LDSTEXCL;
  inst.iclass = InstName::STLLR;
  return true;
}

static bool TryExtractSSUBL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000010000000000000
  if ((bits & 0xbf20fc00U) != 0xe202000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SSUBL_ASIMDDIFF_L;
  inst.iclass = InstName::SSUBL;
  return true;
}

static bool TryExtractSMLSL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001010000000000000
  if ((bits & 0xbf20fc00U) != 0xe20a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMLSL_ASIMDDIFF_L;
  inst.iclass = InstName::SMLSL;
  return true;
}

static bool TryExtractMOV_ADD_32_ADDSUB_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00010001000000000000000000000000
  if ((bits & 0xfffffc00U) != 0x11000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOV_ADD_32_ADDSUB_IMM;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractMOV_ADD_64_ADDSUB_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10010001000000000000000000000000
  if ((bits & 0xfffffc00U) != 0x91000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOV_ADD_64_ADDSUB_IMM;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractSTTRB_32_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000000000000000100000000000
  if ((bits & 0xffe00c00U) != 0x38000800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STTRB_32_LDST_UNPRIV;
  inst.iclass = InstName::STTRB;
  return true;
}

static bool TryExtractBIC_32_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   00001010001000000000000000000000
  if ((bits & 0xff200000U) != 0xa200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::BIC_32_LOG_SHIFT;
  inst.iclass = InstName::BIC;
  return true;
}

static bool TryExtractBIC_64_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   10001010001000000000000000000000
  if ((bits & 0xff200000U) != 0x8a200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::BIC_64_LOG_SHIFT;
  inst.iclass = InstName::BIC;
  return true;
}

static bool TryExtractTST_ANDS_32S_LOG_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000011111
  //   --------------------------------
  //   01110010000000000000000000011111
  if ((bits & 0xffc0001fU) != 0x7200001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::TST_ANDS_32S_LOG_IMM;
  inst.iclass = InstName::ANDS;
  return true;
}

static bool TryExtractTST_ANDS_64S_LOG_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000000000011111
  //   --------------------------------
  //   11110010000000000000000000011111
  if ((bits & 0xff80001fU) != 0xf200001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::TST_ANDS_64S_LOG_IMM;
  inst.iclass = InstName::ANDS;
  return true;
}

static bool TryExtractAND_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110001000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0xe201c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::AND_ASIMDSAME_ONLY;
  inst.iclass = InstName::AND;
  return true;
}

static bool TryExtractSTLXP_SP32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   10001000001000001000000000000000
  if ((bits & 0xffe08000U) != 0x88208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLXP_SP32_LDSTEXCL;
  inst.iclass = InstName::STLXP;
  return true;
}

static bool TryExtractSTLXP_SP64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   11001000001000001000000000000000
  if ((bits & 0xffe08000U) != 0xc8208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLXP_SP64_LDSTEXCL;
  inst.iclass = InstName::STLXP;
  return true;
}

static bool TryExtractSQRSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000000101110000000000
  if ((bits & 0xff20fc00U) != 0x5e205c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRSHL_ASISDSAME_ONLY;
  inst.iclass = InstName::SQRSHL;
  return true;
}

static bool TryExtractSQRSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000101110000000000
  if ((bits & 0xbf20fc00U) != 0xe205c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRSHL_ASIMDSAME_ONLY;
  inst.iclass = InstName::SQRSHL;
  return true;
}

static bool TryExtractUABAL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000101000000000000
  if ((bits & 0xbf20fc00U) != 0x2e205000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t op : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UABAL_ASIMDDIFF_L;
  inst.iclass = InstName::UABAL;
  return true;
}

static bool TryExtractMVNI_ASIMDIMM_L_HL(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001101110000000000
  //   --------------------------------
  //   00101111000000001000010000000000
  if ((bits & 0xbff8dc00U) != 0x2f008400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MVNI_ASIMDIMM_L_HL;
  inst.iclass = InstName::MVNI;
  return true;
}

static bool TryExtractMVNI_ASIMDIMM_L_SL(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001001110000000000
  //   --------------------------------
  //   00101111000000000000010000000000
  if ((bits & 0xbff89c00U) != 0x2f000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MVNI_ASIMDIMM_L_SL;
  inst.iclass = InstName::MVNI;
  return true;
}

static bool TryExtractMVNI_ASIMDIMM_M_SM(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001110110000000000
  //   --------------------------------
  //   00101111000000001100010000000000
  if ((bits & 0xbff8ec00U) != 0x2f00c400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MVNI_ASIMDIMM_M_SM;
  inst.iclass = InstName::MVNI;
  return true;
}

static bool TryExtractMOV_INS_ASIMDINS_IV_V(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000010000000000
  //   --------------------------------
  //   01101110000000000000010000000000
  if ((bits & 0xffe08400U) != 0x6e000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOV_INS_ASIMDINS_IV_V;
  inst.iclass = InstName::INS;
  return true;
}

static bool TryExtractSRSHR_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000000010010000000000
  if ((bits & 0xff80fc00U) != 0x5f002400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SRSHR_ASISDSHF_R;
  inst.iclass = InstName::SRSHR;
  return true;
}

static bool TryExtractSRSHR_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000000010010000000000
  if ((bits & 0xbf80fc00U) != 0xf002400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SRSHR_ASIMDSHF_R;
  inst.iclass = InstName::SRSHR;
  return true;
}

static bool TryExtractLSL_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01010011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x53000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  if (!(inst.imms.uimm != 0x1f))
    return false;
  if (!(inst.imms.uimm != 0x3f))
    return false;
  inst.iform = InstForm::LSL_UBFM_32M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractLSL_UBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   11010011010000000000000000000000
  if ((bits & 0xffc00000U) != 0xd3400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  if (!(inst.imms.uimm != 0x1f))
    return false;
  if (!(inst.imms.uimm != 0x3f))
    return false;
  inst.iform = InstForm::LSL_UBFM_64M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractCLS_32_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011010110000000001010000000000
  if ((bits & 0xfffffc00U) != 0x5ac01400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op : 1;
      uint32_t opcode : 5;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CLS_32_DP_1SRC;
  inst.iclass = InstName::CLS;
  return true;
}

static bool TryExtractCLS_64_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11011010110000000001010000000000
  if ((bits & 0xfffffc00U) != 0xdac01400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op : 1;
      uint32_t opcode : 5;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CLS_64_DP_1SRC;
  inst.iclass = InstName::CLS;
  return true;
}

static bool TryExtractSEV_HI_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010101000000110010000010011111
  if ((bits & 0xffffffffU) != 0xd503209fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::SEV_HI_SYSTEM;
  inst.iclass = InstName::SEV;
  return true;
}

static bool TryExtractUMIN_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000110110000000000
  if ((bits & 0xbf20fc00U) != 0x2e206c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMIN_ASIMDSAME_ONLY;
  inst.iclass = InstName::UMIN;
  return true;
}

static bool TryExtractFMULX_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110010000000001110000000000
  if ((bits & 0xffe0fc00U) != 0x5e401c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMULX_ASISDSAMEFP16_ONLY;
  inst.iclass = InstName::FMULX;
  return true;
}

static bool TryExtractFMULX_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101000001111110000000000
  //   --------------------------------
  //   01011110001000001101110000000000
  if ((bits & 0xffa0fc00U) != 0x5e20dc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMULX_ASISDSAME_ONLY;
  inst.iclass = InstName::FMULX;
  return true;
}

static bool TryExtractFMULX_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110010000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0xe401c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMULX_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMULX;
  return true;
}

static bool TryExtractFMULX_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110001000001101110000000000
  if ((bits & 0xbfa0fc00U) != 0xe20dc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMULX_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMULX;
  return true;
}

static bool TryExtractADDS_32S_ADDSUB_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMN_ADDS_32S_ADDSUB_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   00110001000000000000000000000000
  if ((bits & 0xff000000U) != 0x31000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADDS_32S_ADDSUB_IMM;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractADDS_64S_ADDSUB_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMN_ADDS_64S_ADDSUB_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   10110001000000000000000000000000
  if ((bits & 0xff000000U) != 0xb1000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADDS_64S_ADDSUB_IMM;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractUQSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000000100110000000000
  if ((bits & 0xff20fc00U) != 0x7e204c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQSHL_ASISDSAME_ONLY;
  inst.iclass = InstName::UQSHL;
  return true;
}

static bool TryExtractUQSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000100110000000000
  if ((bits & 0xbf20fc00U) != 0x2e204c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQSHL_ASIMDSAME_ONLY;
  inst.iclass = InstName::UQSHL;
  return true;
}

static bool TryExtractSTEORB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000001000000010000000011111
  if ((bits & 0xffe0fc1fU) != 0x3820201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STEORB_32S_MEMOP;
  inst.iclass = InstName::STEORB;
  return true;
}

static bool TryExtractSTEORLB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000011000000010000000011111
  if ((bits & 0xffe0fc1fU) != 0x3860201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STEORLB_32S_MEMOP;
  inst.iclass = InstName::STEORLB;
  return true;
}

static bool TryExtractLDPSW_64_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101000110000000000000000000000
  if ((bits & 0xffc00000U) != 0x68c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDPSW_64_LDSTPAIR_POST;
  inst.iclass = InstName::LDPSW;
  return true;
}

static bool TryExtractLDPSW_64_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101001110000000000000000000000
  if ((bits & 0xffc00000U) != 0x69c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDPSW_64_LDSTPAIR_PRE;
  inst.iclass = InstName::LDPSW;
  return true;
}

static bool TryExtractLDPSW_64_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101001010000000000000000000000
  if ((bits & 0xffc00000U) != 0x69400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDPSW_64_LDSTPAIR_OFF;
  inst.iclass = InstName::LDPSW;
  return true;
}

static bool TryExtractSTUMAXH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000001000000110000000011111
  if ((bits & 0xffe0fc1fU) != 0x7820601fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMAXH_32S_MEMOP;
  inst.iclass = InstName::STUMAXH;
  return true;
}

static bool TryExtractSTUMAXLH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000011000000110000000011111
  if ((bits & 0xffe0fc1fU) != 0x7860601fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMAXLH_32S_MEMOP;
  inst.iclass = InstName::STUMAXLH;
  return true;
}

static bool TryExtractSMOV_ASIMDINS_W_W(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000010110000000000
  if ((bits & 0xffe0fc00U) != 0xe002c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SMOV_ASIMDINS_W_W;
  inst.iclass = InstName::SMOV;
  return true;
}

static bool TryExtractSMOV_ASIMDINS_X_X(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001110000000000010110000000000
  if ((bits & 0xffe0fc00U) != 0x4e002c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SMOV_ASIMDINS_X_X;
  inst.iclass = InstName::SMOV;
  return true;
}

static bool TryExtractUABA_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000111110000000000
  if ((bits & 0xbf20fc00U) != 0x2e207c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UABA_ASIMDSAME_ONLY;
  inst.iclass = InstName::UABA;
  return true;
}

static bool TryExtractSTSMINB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000001000000101000000011111
  if ((bits & 0xffe0fc1fU) != 0x3820501fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMINB_32S_MEMOP;
  inst.iclass = InstName::STSMINB;
  return true;
}

static bool TryExtractSTSMINLB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000011000000101000000011111
  if ((bits & 0xffe0fc1fU) != 0x3860501fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMINLB_32S_MEMOP;
  inst.iclass = InstName::STSMINLB;
  return true;
}

static bool TryExtractFCMGE_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01111110111110001100100000000000
  if ((bits & 0xfffffc00U) != 0x7ef8c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMGE_ASISDMISCFP16_FZ;
  inst.iclass = InstName::FCMGE;
  return true;
}

static bool TryExtractFCMGE_ASISDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110101000001100100000000000
  if ((bits & 0xffbffc00U) != 0x7ea0c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMGE_ASISDMISC_FZ;
  inst.iclass = InstName::FCMGE;
  return true;
}

static bool TryExtractFCMGE_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110111110001100100000000000
  if ((bits & 0xbffffc00U) != 0x2ef8c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMGE_ASIMDMISCFP16_FZ;
  inst.iclass = InstName::FCMGE;
  return true;
}

static bool TryExtractFCMGE_ASIMDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101000001100100000000000
  if ((bits & 0xbfbffc00U) != 0x2ea0c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMGE_ASIMDMISC_FZ;
  inst.iclass = InstName::FCMGE;
  return true;
}

static bool TryExtractSTLLRB_SL32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00001000100111110111110000000000
  if ((bits & 0xfffffc00U) != 0x89f7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLLRB_SL32_LDSTEXCL;
  inst.iclass = InstName::STLLRB;
  return true;
}

static bool TryExtractFRINTZ_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110111110011001100000000000
  if ((bits & 0xbffffc00U) != 0xef99800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTZ_ASIMDMISCFP16_R;
  inst.iclass = InstName::FRINTZ;
  return true;
}

static bool TryExtractFRINTZ_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000011001100000000000
  if ((bits & 0xbfbffc00U) != 0xea19800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTZ_ASIMDMISC_R;
  inst.iclass = InstName::FRINTZ;
  return true;
}

static bool TryExtractSTXRH_SR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000000000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x48007c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STXRH_SR32_LDSTEXCL;
  inst.iclass = InstName::STXRH;
  return true;
}

static bool TryExtractSTEORH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000001000000010000000011111
  if ((bits & 0xffe0fc1fU) != 0x7820201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STEORH_32S_MEMOP;
  inst.iclass = InstName::STEORH;
  return true;
}

static bool TryExtractSTEORLH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000011000000010000000011111
  if ((bits & 0xffe0fc1fU) != 0x7860201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STEORLH_32S_MEMOP;
  inst.iclass = InstName::STEORLH;
  return true;
}

static bool TryExtractFMINNMP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110110000000000010000000000
  if ((bits & 0xbfe0fc00U) != 0x2ec00400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t Op3 : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Op3 = static_cast<uint8_t>(enc.Op3);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FMINNMP_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMINNMP;
  return true;
}

static bool TryExtractFMINNMP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110101000001100010000000000
  if ((bits & 0xbfa0fc00U) != 0x2ea0c400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINNMP_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMINNMP;
  return true;
}

static bool TryExtractLDLAR_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10001000110111110111110000000000
  if ((bits & 0xfffffc00U) != 0x88df7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDLAR_LR32_LDSTEXCL;
  inst.iclass = InstName::LDLAR;
  return true;
}

static bool TryExtractLDLAR_LR64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11001000110111110111110000000000
  if ((bits & 0xfffffc00U) != 0xc8df7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDLAR_LR64_LDSTEXCL;
  inst.iclass = InstName::LDLAR;
  return true;
}

static bool TryExtractADD_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   00001011000000000000000000000000
  if ((bits & 0xff200000U) != 0xb000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ADD_32_ADDSUB_SHIFT;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractADD_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   10001011000000000000000000000000
  if ((bits & 0xff200000U) != 0x8b000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ADD_64_ADDSUB_SHIFT;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractSSHLL_ASIMDSHF_L(InstData &inst, uint32_t bits) {
  if (false && TryExtractSXTL_SSHLL_ASIMDSHF_L(inst, bits))
    return true;

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000001010010000000000
  if ((bits & 0xbf80fc00U) != 0xf00a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SSHLL_ASIMDSHF_L;
  inst.iclass = InstName::SSHLL;
  return true;
}

static bool TryExtractRORV_32_DP_2SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractROR_RORV_32_DP_2SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000010110000000000
  if ((bits & 0xffe0fc00U) != 0x1ac02c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::RORV_32_DP_2SRC;
  inst.iclass = InstName::RORV;
  return true;
}

static bool TryExtractRORV_64_DP_2SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractROR_RORV_64_DP_2SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000010110000000000
  if ((bits & 0xffe0fc00U) != 0x9ac02c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::RORV_64_DP_2SRC;
  inst.iclass = InstName::RORV;
  return true;
}

static bool TryExtractSTCLRB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000001000000001000000011111
  if ((bits & 0xffe0fc1fU) != 0x3820101fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STCLRB_32S_MEMOP;
  inst.iclass = InstName::STCLRB;
  return true;
}

static bool TryExtractSTCLRLB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000011000000001000000011111
  if ((bits & 0xffe0fc1fU) != 0x3860101fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STCLRLB_32S_MEMOP;
  inst.iclass = InstName::STCLRLB;
  return true;
}

static bool TryExtractLDARH_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001000110111111111110000000000
  if ((bits & 0xfffffc00U) != 0x48dffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDARH_LR32_LDSTEXCL;
  inst.iclass = InstName::LDARH;
  return true;
}

static bool TryExtractSTSMAX_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000001000000100000000011111
  if ((bits & 0xffe0fc1fU) != 0xb820401fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMAX_32S_MEMOP;
  inst.iclass = InstName::STSMAX;
  return true;
}

static bool TryExtractSTSMAXL_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000011000000100000000011111
  if ((bits & 0xffe0fc1fU) != 0xb860401fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMAXL_32S_MEMOP;
  inst.iclass = InstName::STSMAXL;
  return true;
}

static bool TryExtractSTSMAX_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000001000000100000000011111
  if ((bits & 0xffe0fc1fU) != 0xf820401fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMAX_64S_MEMOP;
  inst.iclass = InstName::STSMAX;
  return true;
}

static bool TryExtractSTSMAXL_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000011000000100000000011111
  if ((bits & 0xffe0fc1fU) != 0xf860401fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMAXL_64S_MEMOP;
  inst.iclass = InstName::STSMAXL;
  return true;
}

static bool TryExtractBLR_64_BRANCH_REG(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000011111
  //   --------------------------------
  //   11010110001111110000000000000000
  if ((bits & 0xfffffc1fU) != 0xd63f0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t op4 : 5;
      uint32_t Rn : 5;
      uint32_t op3 : 6;
      uint32_t op2 : 5;
      uint32_t op : 2;
      uint32_t opc : 2;
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.op4 = static_cast<uint8_t>(enc.op4);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.op3 = static_cast<uint8_t>(enc.op3);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::BLR_64_BRANCH_REG;
  inst.iclass = InstName::BLR;
  return true;
}

static bool TryExtractCMN_ADDS_32S_ADDSUB_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000011111
  //   --------------------------------
  //   00110001000000000000000000011111
  if ((bits & 0xff00001fU) != 0x3100001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMN_ADDS_32S_ADDSUB_IMM;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractCMN_ADDS_64S_ADDSUB_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000011111
  //   --------------------------------
  //   10110001000000000000000000011111
  if ((bits & 0xff00001fU) != 0xb100001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMN_ADDS_64S_ADDSUB_IMM;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractSQDMULL_ASISDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000001111010000000000
  //   --------------------------------
  //   01011111000000001011000000000000
  if ((bits & 0xff00f400U) != 0x5f00b000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMULL_ASISDELEM_L;
  inst.iclass = InstName::SQDMULL;
  return true;
}

static bool TryExtractSQDMULL_ASIMDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00001111000000001011000000000000
  if ((bits & 0xbf00f400U) != 0xf00b000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMULL_ASIMDELEM_L;
  inst.iclass = InstName::SQDMULL;
  return true;
}

static bool TryExtractCSET_CSINC_32_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000111111100000
  //   --------------------------------
  //   00011010100111110000011111100000
  if ((bits & 0xffff0fe0U) != 0x1a9f07e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSET_CSINC_32_CONDSEL;
  inst.iclass = InstName::CSINC;
  return true;
}

static bool TryExtractCSET_CSINC_64_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000111111100000
  //   --------------------------------
  //   10011010100111110000011111100000
  if ((bits & 0xffff0fe0U) != 0x9a9f07e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSET_CSINC_64_CONDSEL;
  inst.iclass = InstName::CSINC;
  return true;
}

static bool TryExtractLD1_ASISDLSO_B1_1B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101010000000000000000000000
  if ((bits & 0xbfffe000U) != 0xd400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSO_B1_1B;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSO_H1_1H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101010000000100000000000000
  if ((bits & 0xbfffe400U) != 0xd404000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSO_H1_1H;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSO_S1_1S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101010000001000000000000000
  if ((bits & 0xbfffec00U) != 0xd408000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSO_S1_1S;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSO_D1_1D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101010000001000010000000000
  if ((bits & 0xbffffc00U) != 0xd408400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSO_D1_1D;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSOP_B1_I1B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101110111110000000000000000
  if ((bits & 0xbfffe000U) != 0xddf0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSOP_B1_I1B;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSOP_BX1_R1B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110000000000000
  //   --------------------------------
  //   00001101110000000000000000000000
  if ((bits & 0xbfe0e000U) != 0xdc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSOP_BX1_R1B;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSOP_H1_I1H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101110111110100000000000000
  if ((bits & 0xbfffe400U) != 0xddf4000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSOP_H1_I1H;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSOP_HX1_R1H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110010000000000
  //   --------------------------------
  //   00001101110000000100000000000000
  if ((bits & 0xbfe0e400U) != 0xdc04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSOP_HX1_R1H;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSOP_S1_I1S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101110111111000000000000000
  if ((bits & 0xbfffec00U) != 0xddf8000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSOP_S1_I1S;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSOP_SX1_R1S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110110000000000
  //   --------------------------------
  //   00001101110000001000000000000000
  if ((bits & 0xbfe0ec00U) != 0xdc08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSOP_SX1_R1S;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSOP_D1_I1D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101110111111000010000000000
  if ((bits & 0xbffffc00U) != 0xddf8400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSOP_D1_I1D;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSOP_DX1_R1D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001101110000001000010000000000
  if ((bits & 0xbfe0fc00U) != 0xdc08400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSOP_DX1_R1D;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractCCMN_32_CONDCMP_REG(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   00111010010000000000000000000000
  if ((bits & 0xffe00c10U) != 0x3a400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t o3 : 1;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CCMN_32_CONDCMP_REG;
  inst.iclass = InstName::CCMN;
  return true;
}

static bool TryExtractCCMN_64_CONDCMP_REG(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   10111010010000000000000000000000
  if ((bits & 0xffe00c10U) != 0xba400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t o3 : 1;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CCMN_64_CONDCMP_REG;
  inst.iclass = InstName::CCMN;
  return true;
}

static bool TryExtractSTNP_S_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101100000000000000000000000000
  if ((bits & 0xffc00000U) != 0x2c000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STNP_S_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::STNP;
  return true;
}

static bool TryExtractSTNP_D_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101100000000000000000000000000
  if ((bits & 0xffc00000U) != 0x6c000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STNP_D_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::STNP;
  return true;
}

static bool TryExtractSTNP_Q_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101100000000000000000000000000
  if ((bits & 0xffc00000U) != 0xac000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STNP_Q_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::STNP;
  return true;
}

static bool TryExtractFSUB_H_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110111000000011100000000000
  if ((bits & 0xffe0fc00U) != 0x1ee03800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FSUB_H_FLOATDP2;
  inst.iclass = InstName::FSUB;
  return true;
}

static bool TryExtractFSUB_S_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110001000000011100000000000
  if ((bits & 0xffe0fc00U) != 0x1e203800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FSUB_S_FLOATDP2;
  inst.iclass = InstName::FSUB;
  return true;
}

static bool TryExtractFSUB_D_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110011000000011100000000000
  if ((bits & 0xffe0fc00U) != 0x1e603800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FSUB_D_FLOATDP2;
  inst.iclass = InstName::FSUB;
  return true;
}

static bool TryExtractCSNEG_32_CONDSEL(InstData &inst, uint32_t bits) {
  if (false && TryExtractCNEG_CSNEG_32_CONDSEL(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01011010100000000000010000000000
  if ((bits & 0xffe00c00U) != 0x5a800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSNEG_32_CONDSEL;
  inst.iclass = InstName::CSNEG;
  return true;
}

static bool TryExtractCSNEG_64_CONDSEL(InstData &inst, uint32_t bits) {
  if (false && TryExtractCNEG_CSNEG_64_CONDSEL(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11011010100000000000010000000000
  if ((bits & 0xffe00c00U) != 0xda800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSNEG_64_CONDSEL;
  inst.iclass = InstName::CSNEG;
  return true;
}

static bool TryExtractASR_ASRV_32_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000010100000000000
  if ((bits & 0xffe0fc00U) != 0x1ac02800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ASR_ASRV_32_DP_2SRC;
  inst.iclass = InstName::ASRV;
  return true;
}

static bool TryExtractASR_ASRV_64_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000010100000000000
  if ((bits & 0xffe0fc00U) != 0x9ac02800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ASR_ASRV_64_DP_2SRC;
  inst.iclass = InstName::ASRV;
  return true;
}

static bool TryExtractUMULL_UMADDL_64WA_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011011101000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x9ba07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::UMULL_UMADDL_64WA_DP_3SRC;
  inst.iclass = InstName::UMADDL;
  return true;
}

static bool TryExtractFCMGT_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111110110000000010010000000000
  if ((bits & 0xffe0fc00U) != 0x7ec02400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMGT_ASISDSAMEFP16_ONLY;
  inst.iclass = InstName::FCMGT;
  return true;
}

static bool TryExtractFCMGT_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101000001111110000000000
  //   --------------------------------
  //   01111110101000001110010000000000
  if ((bits & 0xffa0fc00U) != 0x7ea0e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMGT_ASISDSAME_ONLY;
  inst.iclass = InstName::FCMGT;
  return true;
}

static bool TryExtractFCMGT_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110110000000010010000000000
  if ((bits & 0xbfe0fc00U) != 0x2ec02400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMGT_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FCMGT;
  return true;
}

static bool TryExtractFCMGT_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110101000001110010000000000
  if ((bits & 0xbfa0fc00U) != 0x2ea0e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMGT_ASIMDSAME_ONLY;
  inst.iclass = InstName::FCMGT;
  return true;
}

static bool TryExtractUSUBW_ASIMDDIFF_W(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000011000000000000
  if ((bits & 0xbf20fc00U) != 0x2e203000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::USUBW_ASIMDDIFF_W;
  inst.iclass = InstName::USUBW;
  return true;
}

static bool TryExtractREV32_64_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11011010110000000000100000000000
  if ((bits & 0xfffffc00U) != 0xdac00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opc : 2;
      uint32_t opcode : 4;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.iform = InstForm::REV32_64_DP_1SRC;
  inst.iclass = InstName::REV32;
  return true;
}

static bool TryExtractFSQRT_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110111110011111100000000000
  if ((bits & 0xbffffc00U) != 0x2ef9f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FSQRT_ASIMDMISCFP16_R;
  inst.iclass = InstName::FSQRT;
  return true;
}

static bool TryExtractFSQRT_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101000011111100000000000
  if ((bits & 0xbfbffc00U) != 0x2ea1f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FSQRT_ASIMDMISC_R;
  inst.iclass = InstName::FSQRT;
  return true;
}

static bool TryExtractLSL_LSLV_32_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x1ac02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::LSL_LSLV_32_DP_2SRC;
  inst.iclass = InstName::LSLV;
  return true;
}

static bool TryExtractLSL_LSLV_64_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x9ac02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::LSL_LSLV_64_DP_2SRC;
  inst.iclass = InstName::LSLV;
  return true;
}

static bool TryExtractEXTR_32_EXTRACT(InstData &inst, uint32_t bits) {
  if (false && TryExtractROR_EXTR_32_EXTRACT(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00010011100000000000000000000000
  if ((bits & 0xffe08000U) != 0x13800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t Rm : 5;
      uint32_t o0 : 1;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t op21 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.op21 = static_cast<uint8_t>(enc.op21);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::EXTR_32_EXTRACT;
  inst.iclass = InstName::EXTR;
  return true;
}

static bool TryExtractEXTR_64_EXTRACT(InstData &inst, uint32_t bits) {
  if (false && TryExtractROR_EXTR_64_EXTRACT(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   10010011110000000000000000000000
  if ((bits & 0xffe00000U) != 0x93c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t Rm : 5;
      uint32_t o0 : 1;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t op21 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.op21 = static_cast<uint8_t>(enc.op21);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::EXTR_64_EXTRACT;
  inst.iclass = InstName::EXTR;
  return true;
}

static bool TryExtractFCVTAU_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01111110011110011100100000000000
  if ((bits & 0xfffffc00U) != 0x7e79c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t size : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FCVTAU_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractFCVTAU_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110001000011100100000000000
  if ((bits & 0xffbffc00U) != 0x7e21c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCVTAU_ASISDMISC_R;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractFCVTAU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110011110011100100000000000
  if ((bits & 0xbffffc00U) != 0x2e79c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCVTAU_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractFCVTAU_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110001000011100100000000000
  if ((bits & 0xbfbffc00U) != 0x2e21c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCVTAU_ASIMDMISC_R;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractBFXIL_BFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00110011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x33000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::BFXIL_BFM_32M_BITFIELD;
  inst.iclass = InstName::BFM;
  return true;
}

static bool TryExtractBFXIL_BFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10110011010000000000000000000000
  if ((bits & 0xffc00000U) != 0xb3400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::BFXIL_BFM_64M_BITFIELD;
  inst.iclass = InstName::BFM;
  return true;
}

static bool TryExtractZIP1_ASIMDPERM_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110000000000011100000000000
  if ((bits & 0xbf20fc00U) != 0xe003800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ZIP1_ASIMDPERM_ONLY;
  inst.iclass = InstName::ZIP1;
  return true;
}

static bool TryExtractLDSETAH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000101000000011000000000000
  if ((bits & 0xffe0fc00U) != 0x78a03000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETAH_32_MEMOP;
  inst.iclass = InstName::LDSETAH;
  return true;
}

static bool TryExtractLDSETALH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000111000000011000000000000
  if ((bits & 0xffe0fc00U) != 0x78e03000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETALH_32_MEMOP;
  inst.iclass = InstName::LDSETALH;
  return true;
}

static bool TryExtractLDSETH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000001000000011000000000000
  if ((bits & 0xffe0fc00U) != 0x78203000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETH_32_MEMOP;
  inst.iclass = InstName::LDSETH;
  return true;
}

static bool TryExtractLDSETLH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000011000000011000000000000
  if ((bits & 0xffe0fc00U) != 0x78603000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETLH_32_MEMOP;
  inst.iclass = InstName::LDSETLH;
  return true;
}

static bool TryExtractLDR_32_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000011000000000100000000000
  if ((bits & 0xffe00c00U) != 0xb8600800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_32_LDST_REGOFF;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_64_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000011000000000100000000000
  if ((bits & 0xffe00c00U) != 0xf8600800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_64_LDST_REGOFF;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDADDAH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000101000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x78a00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDAH_32_MEMOP;
  inst.iclass = InstName::LDADDAH;
  return true;
}

static bool TryExtractLDADDALH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000111000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x78e00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDALH_32_MEMOP;
  inst.iclass = InstName::LDADDALH;
  return true;
}

static bool TryExtractLDADDH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000001000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x78200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDH_32_MEMOP;
  inst.iclass = InstName::LDADDH;
  return true;
}

static bool TryExtractLDADDLH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000011000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x78600000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDLH_32_MEMOP;
  inst.iclass = InstName::LDADDLH;
  return true;
}

static bool TryExtractANDS_32_LOG_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractTST_ANDS_32_LOG_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   01101010000000000000000000000000
  if ((bits & 0xff200000U) != 0x6a000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ANDS_32_LOG_SHIFT;
  inst.iclass = InstName::ANDS;
  return true;
}

static bool TryExtractANDS_64_LOG_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractTST_ANDS_64_LOG_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   11101010000000000000000000000000
  if ((bits & 0xff200000U) != 0xea000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ANDS_64_LOG_SHIFT;
  inst.iclass = InstName::ANDS;
  return true;
}

static bool TryExtractLD3_ASISDLSE_R3(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100010000000100000000000000
  if ((bits & 0xbffff000U) != 0xc404000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSE_R3;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSEP_I3_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100110111110100000000000000
  if ((bits & 0xbffff000U) != 0xcdf4000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSEP_I3_I;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSEP_R3_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100110000000100000000000000
  if ((bits & 0xbfe0f000U) != 0xcc04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSEP_R3_R;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractFMUL_H_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110111000000000100000000000
  if ((bits & 0xffe0fc00U) != 0x1ee00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t op : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMUL_H_FLOATDP2;
  inst.iclass = InstName::FMUL;
  return true;
}

static bool TryExtractFMUL_S_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110001000000000100000000000
  if ((bits & 0xffe0fc00U) != 0x1e200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t op : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMUL_S_FLOATDP2;
  inst.iclass = InstName::FMUL;
  return true;
}

static bool TryExtractFMUL_D_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110011000000000100000000000
  if ((bits & 0xffe0fc00U) != 0x1e600800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t op : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMUL_D_FLOATDP2;
  inst.iclass = InstName::FMUL;
  return true;
}

static bool TryExtractLDAXR_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10001000010111111111110000000000
  if ((bits & 0xfffffc00U) != 0x885ffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDAXR_LR32_LDSTEXCL;
  inst.iclass = InstName::LDAXR;
  return true;
}

static bool TryExtractLDAXR_LR64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11001000010111111111110000000000
  if ((bits & 0xfffffc00U) != 0xc85ffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDAXR_LR64_LDSTEXCL;
  inst.iclass = InstName::LDAXR;
  return true;
}

static bool TryExtractLDRB_32B_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000011000000000100000000000
  if ((bits & 0xffe00c00U) != 0x38600800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRB_32B_LDST_REGOFF;
  inst.iclass = InstName::LDRB;
  return true;
}

static bool TryExtractLDRB_32BL_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001110110000000000
  //   --------------------------------
  //   00111000011000000110100000000000
  if ((bits & 0xffe0ec00U) != 0x38606800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRB_32BL_LDST_REGOFF;
  inst.iclass = InstName::LDRB;
  return true;
}

static bool TryExtractUADALP_ASIMDMISC_P(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000000110100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e206800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UADALP_ASIMDMISC_P;
  inst.iclass = InstName::UADALP;
  return true;
}

static bool TryExtractFRINTX_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110011110011001100000000000
  if ((bits & 0xbffffc00U) != 0x2e799800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTX_ASIMDMISCFP16_R;
  inst.iclass = InstName::FRINTX;
  return true;
}

static bool TryExtractFRINTX_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110001000011001100000000000
  if ((bits & 0xbfbffc00U) != 0x2e219800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTX_ASIMDMISC_R;
  inst.iclass = InstName::FRINTX;
  return true;
}

static bool TryExtractHLT_EX_EXCEPTION(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   11010100010000000000000000000000
  if ((bits & 0xffe0001fU) != 0xd4400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t LL : 2;
      uint32_t op2 : 3;
      uint32_t imm16 : 16;
      uint32_t opc : 3;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.LL = static_cast<uint8_t>(enc.LL);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::HLT_EX_EXCEPTION;
  inst.iclass = InstName::HLT;
  return true;
}

static bool TryExtractSABA_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000111110000000000
  if ((bits & 0xbf20fc00U) != 0xe207c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SABA_ASIMDSAME_ONLY;
  inst.iclass = InstName::SABA;
  return true;
}

static bool TryExtractFMAX_H_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110111000000100100000000000
  if ((bits & 0xffe0fc00U) != 0x1ee04800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMAX_H_FLOATDP2;
  inst.iclass = InstName::FMAX;
  return true;
}

static bool TryExtractFMAX_S_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110001000000100100000000000
  if ((bits & 0xffe0fc00U) != 0x1e204800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMAX_S_FLOATDP2;
  inst.iclass = InstName::FMAX;
  return true;
}

static bool TryExtractFMAX_D_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110011000000100100000000000
  if ((bits & 0xffe0fc00U) != 0x1e604800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMAX_D_FLOATDP2;
  inst.iclass = InstName::FMAX;
  return true;
}

static bool TryExtractAESD_B_CRYPTOAES(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001110001010000101100000000000
  if ((bits & 0xfffffc00U) != 0x4e285800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t D : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.D = static_cast<uint8_t>(enc.D);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::AESD_B_CRYPTOAES;
  inst.iclass = InstName::AESD;
  return true;
}

static bool TryExtractAESMC_B_CRYPTOAES(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001110001010000110100000000000
  if ((bits & 0xfffffc00U) != 0x4e286800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t D : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.D = static_cast<uint8_t>(enc.D);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::AESMC_B_CRYPTOAES;
  inst.iclass = InstName::AESMC;
  return true;
}

static bool TryExtractLD2_ASISDLSO_B2_2B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101011000000000000000000000
  if ((bits & 0xbfffe000U) != 0xd600000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSO_B2_2B;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSO_H2_2H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101011000000100000000000000
  if ((bits & 0xbfffe400U) != 0xd604000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSO_H2_2H;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSO_S2_2S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101011000001000000000000000
  if ((bits & 0xbfffec00U) != 0xd608000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSO_S2_2S;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSO_D2_2D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101011000001000010000000000
  if ((bits & 0xbffffc00U) != 0xd608400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSO_D2_2D;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSOP_B2_I2B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101111111110000000000000000
  if ((bits & 0xbfffe000U) != 0xdff0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSOP_B2_I2B;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSOP_BX2_R2B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110000000000000
  //   --------------------------------
  //   00001101111000000000000000000000
  if ((bits & 0xbfe0e000U) != 0xde00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSOP_BX2_R2B;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSOP_H2_I2H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101111111110100000000000000
  if ((bits & 0xbfffe400U) != 0xdff4000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSOP_H2_I2H;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSOP_HX2_R2H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110010000000000
  //   --------------------------------
  //   00001101111000000100000000000000
  if ((bits & 0xbfe0e400U) != 0xde04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSOP_HX2_R2H;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSOP_S2_I2S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101111111111000000000000000
  if ((bits & 0xbfffec00U) != 0xdff8000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSOP_S2_I2S;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSOP_SX2_R2S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110110000000000
  //   --------------------------------
  //   00001101111000001000000000000000
  if ((bits & 0xbfe0ec00U) != 0xde08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSOP_SX2_R2S;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSOP_D2_I2D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101111111111000010000000000
  if ((bits & 0xbffffc00U) != 0xdff8400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSOP_D2_I2D;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSOP_DX2_R2D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001101111000001000010000000000
  if ((bits & 0xbfe0fc00U) != 0xde08400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSOP_DX2_R2D;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractBR_64_BRANCH_REG(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000011111
  //   --------------------------------
  //   11010110000111110000000000000000
  if ((bits & 0xfffffc1fU) != 0xd61f0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t op4 : 5;
      uint32_t Rn : 5;
      uint32_t op3 : 6;
      uint32_t op2 : 5;
      uint32_t op : 2;
      uint32_t opc : 2;
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.op4 = static_cast<uint8_t>(enc.op4);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.op3 = static_cast<uint8_t>(enc.op3);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::BR_64_BRANCH_REG;
  inst.iclass = InstName::BR;
  return true;
}

static bool TryExtractFCVTZU_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01111110111110011011100000000000
  if ((bits & 0xfffffc00U) != 0x7ef9b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTZU_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110101000011011100000000000
  if ((bits & 0xffbffc00U) != 0x7ea1b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTZU_ASISDMISC_R;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110111110011011100000000000
  if ((bits & 0xbffffc00U) != 0x2ef9b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTZU_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101000011011100000000000
  if ((bits & 0xbfbffc00U) != 0x2ea1b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTZU_ASIMDMISC_R;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractMVN_ORN_32_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000001111100000
  //   --------------------------------
  //   00101010001000000000001111100000
  if ((bits & 0xff2003e0U) != 0x2a2003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::MVN_ORN_32_LOG_SHIFT;
  inst.iclass = InstName::ORN;
  return true;
}

static bool TryExtractMVN_ORN_64_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000001111100000
  //   --------------------------------
  //   10101010001000000000001111100000
  if ((bits & 0xff2003e0U) != 0xaa2003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::MVN_ORN_64_LOG_SHIFT;
  inst.iclass = InstName::ORN;
  return true;
}

static bool TryExtractSTEOR_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000001000000010000000011111
  if ((bits & 0xffe0fc1fU) != 0xb820201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STEOR_32S_MEMOP;
  inst.iclass = InstName::STEOR;
  return true;
}

static bool TryExtractSTEORL_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000011000000010000000011111
  if ((bits & 0xffe0fc1fU) != 0xb860201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STEORL_32S_MEMOP;
  inst.iclass = InstName::STEORL;
  return true;
}

static bool TryExtractSTEOR_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000001000000010000000011111
  if ((bits & 0xffe0fc1fU) != 0xf820201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STEOR_64S_MEMOP;
  inst.iclass = InstName::STEOR;
  return true;
}

static bool TryExtractSTEORL_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000011000000010000000011111
  if ((bits & 0xffe0fc1fU) != 0xf860201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STEORL_64S_MEMOP;
  inst.iclass = InstName::STEORL;
  return true;
}

static bool TryExtractTBX_ASIMDTBL_L2_2(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000011000000000000
  if ((bits & 0xbfe0fc00U) != 0xe003000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t len : 2;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t op2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.len = static_cast<uint8_t>(enc.len);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::TBX_ASIMDTBL_L2_2;
  inst.iclass = InstName::TBX;
  return true;
}

static bool TryExtractTBX_ASIMDTBL_L3_3(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000101000000000000
  if ((bits & 0xbfe0fc00U) != 0xe005000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t len : 2;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t op2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.len = static_cast<uint8_t>(enc.len);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::TBX_ASIMDTBL_L3_3;
  inst.iclass = InstName::TBX;
  return true;
}

static bool TryExtractTBX_ASIMDTBL_L4_4(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000111000000000000
  if ((bits & 0xbfe0fc00U) != 0xe007000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t len : 2;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t op2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.len = static_cast<uint8_t>(enc.len);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::TBX_ASIMDTBL_L4_4;
  inst.iclass = InstName::TBX;
  return true;
}

static bool TryExtractTBX_ASIMDTBL_L1_1(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000001000000000000
  if ((bits & 0xbfe0fc00U) != 0xe001000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t len : 2;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t op2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.len = static_cast<uint8_t>(enc.len);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::TBX_ASIMDTBL_L1_1;
  inst.iclass = InstName::TBX;
  return true;
}

static bool TryExtractUMLAL_ASIMDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00101111000000000010000000000000
  if ((bits & 0xbf00f400U) != 0x2f002000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMLAL_ASIMDELEM_L;
  inst.iclass = InstName::UMLAL;
  return true;
}

static bool TryExtractUMINP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001010110000000000
  if ((bits & 0xbf20fc00U) != 0x2e20ac00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMINP_ASIMDSAME_ONLY;
  inst.iclass = InstName::UMINP;
  return true;
}

static bool TryExtractCMLE_ASISDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01111110001000001001100000000000
  if ((bits & 0xff3ffc00U) != 0x7e209800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMLE_ASISDMISC_Z;
  inst.iclass = InstName::CMLE;
  return true;
}

static bool TryExtractCMLE_ASIMDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000001001100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e209800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMLE_ASIMDMISC_Z;
  inst.iclass = InstName::CMLE;
  return true;
}

static bool TryExtractEOR_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110001000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0x2e201c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opc2 = static_cast<uint8_t>(enc.opc2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::EOR_ASIMDSAME_ONLY;
  inst.iclass = InstName::EOR;
  return true;
}

static bool TryExtractCMEQ_ASISDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01011110001000001001100000000000
  if ((bits & 0xff3ffc00U) != 0x5e209800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMEQ_ASISDMISC_Z;
  inst.iclass = InstName::CMEQ;
  return true;
}

static bool TryExtractCMEQ_ASIMDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000001001100000000000
  if ((bits & 0xbf3ffc00U) != 0xe209800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMEQ_ASIMDMISC_Z;
  inst.iclass = InstName::CMEQ;
  return true;
}

static bool TryExtractLDUMAXAH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000101000000110000000000000
  if ((bits & 0xffe0fc00U) != 0x78a06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXAH_32_MEMOP;
  inst.iclass = InstName::LDUMAXAH;
  return true;
}

static bool TryExtractLDUMAXALH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000111000000110000000000000
  if ((bits & 0xffe0fc00U) != 0x78e06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXALH_32_MEMOP;
  inst.iclass = InstName::LDUMAXALH;
  return true;
}

static bool TryExtractLDUMAXH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000001000000110000000000000
  if ((bits & 0xffe0fc00U) != 0x78206000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXH_32_MEMOP;
  inst.iclass = InstName::LDUMAXH;
  return true;
}

static bool TryExtractLDUMAXLH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000011000000110000000000000
  if ((bits & 0xffe0fc00U) != 0x78606000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXLH_32_MEMOP;
  inst.iclass = InstName::LDUMAXLH;
  return true;
}

static bool TryExtractST3_ASISDLSO_B3_3B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101000000000010000000000000
  if ((bits & 0xbfffe000U) != 0xd002000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSO_B3_3B;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSO_H3_3H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101000000000110000000000000
  if ((bits & 0xbfffe400U) != 0xd006000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSO_H3_3H;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSO_S3_3S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101000000001010000000000000
  if ((bits & 0xbfffec00U) != 0xd00a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSO_S3_3S;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSO_D3_3D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101000000001010010000000000
  if ((bits & 0xbffffc00U) != 0xd00a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSO_D3_3D;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSOP_B3_I3B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101100111110010000000000000
  if ((bits & 0xbfffe000U) != 0xd9f2000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSOP_B3_I3B;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSOP_BX3_R3B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110000000000000
  //   --------------------------------
  //   00001101100000000010000000000000
  if ((bits & 0xbfe0e000U) != 0xd802000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSOP_BX3_R3B;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSOP_H3_I3H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101100111110110000000000000
  if ((bits & 0xbfffe400U) != 0xd9f6000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSOP_H3_I3H;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSOP_HX3_R3H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110010000000000
  //   --------------------------------
  //   00001101100000000110000000000000
  if ((bits & 0xbfe0e400U) != 0xd806000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSOP_HX3_R3H;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSOP_S3_I3S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101100111111010000000000000
  if ((bits & 0xbfffec00U) != 0xd9fa000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSOP_S3_I3S;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSOP_SX3_R3S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110110000000000
  //   --------------------------------
  //   00001101100000001010000000000000
  if ((bits & 0xbfe0ec00U) != 0xd80a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSOP_SX3_R3S;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSOP_D3_I3D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101100111111010010000000000
  if ((bits & 0xbffffc00U) != 0xd9fa400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSOP_D3_I3D;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSOP_DX3_R3D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001101100000001010010000000000
  if ((bits & 0xbfe0fc00U) != 0xd80a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSOP_DX3_R3D;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractASR_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000001111110000000000
  //   --------------------------------
  //   00010011000000000111110000000000
  if ((bits & 0xffc0fc00U) != 0x13007c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::ASR_SBFM_32M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractASR_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000001111110000000000
  //   --------------------------------
  //   10010011010000001111110000000000
  if ((bits & 0xffc0fc00U) != 0x9340fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::ASR_SBFM_64M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractLDRSW_64_LOADLIT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   10011000000000000000000000000000
  if ((bits & 0xff000000U) != 0x98000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.iform = InstForm::LDRSW_64_LOADLIT;
  inst.iclass = InstName::LDRSW;
  return true;
}

static bool TryExtractLDADDA_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000101000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xb8a00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDA_32_MEMOP;
  inst.iclass = InstName::LDADDA;
  return true;
}

static bool TryExtractLDADDAL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000111000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xb8e00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDAL_32_MEMOP;
  inst.iclass = InstName::LDADDAL;
  return true;
}

static bool TryExtractLDADD_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000001000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xb8200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADD_32_MEMOP;
  inst.iclass = InstName::LDADD;
  return true;
}

static bool TryExtractLDADDL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000011000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xb8600000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDL_32_MEMOP;
  inst.iclass = InstName::LDADDL;
  return true;
}

static bool TryExtractLDADDA_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000101000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xf8a00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDA_64_MEMOP;
  inst.iclass = InstName::LDADDA;
  return true;
}

static bool TryExtractLDADDAL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000111000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xf8e00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDAL_64_MEMOP;
  inst.iclass = InstName::LDADDAL;
  return true;
}

static bool TryExtractLDADD_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000001000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xf8200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADD_64_MEMOP;
  inst.iclass = InstName::LDADD;
  return true;
}

static bool TryExtractLDADDL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000011000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xf8600000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDL_64_MEMOP;
  inst.iclass = InstName::LDADDL;
  return true;
}

static bool TryExtractFCVTZS_ASISDSHF_C(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000001111110000000000
  if ((bits & 0xff80fc00U) != 0x5f00fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCVTZS_ASISDSHF_C;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_ASIMDSHF_C(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000001111110000000000
  if ((bits & 0xbf80fc00U) != 0xf00fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCVTZS_ASIMDSHF_C;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractLSR_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000001111110000000000
  //   --------------------------------
  //   01010011000000000111110000000000
  if ((bits & 0xffc0fc00U) != 0x53007c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::LSR_UBFM_32M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractLSR_UBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000001111110000000000
  //   --------------------------------
  //   11010011010000001111110000000000
  if ((bits & 0xffc0fc00U) != 0xd340fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::LSR_UBFM_64M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractST2_ASISDLSO_B2_2B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101001000000000000000000000
  if ((bits & 0xbfffe000U) != 0xd200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSO_B2_2B;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSO_H2_2H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101001000000100000000000000
  if ((bits & 0xbfffe400U) != 0xd204000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSO_H2_2H;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSO_S2_2S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101001000001000000000000000
  if ((bits & 0xbfffec00U) != 0xd208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSO_S2_2S;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSO_D2_2D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101001000001000010000000000
  if ((bits & 0xbffffc00U) != 0xd208400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSO_D2_2D;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSOP_B2_I2B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101101111110000000000000000
  if ((bits & 0xbfffe000U) != 0xdbf0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSOP_B2_I2B;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSOP_BX2_R2B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110000000000000
  //   --------------------------------
  //   00001101101000000000000000000000
  if ((bits & 0xbfe0e000U) != 0xda00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSOP_BX2_R2B;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSOP_H2_I2H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101101111110100000000000000
  if ((bits & 0xbfffe400U) != 0xdbf4000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSOP_H2_I2H;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSOP_HX2_R2H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110010000000000
  //   --------------------------------
  //   00001101101000000100000000000000
  if ((bits & 0xbfe0e400U) != 0xda04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSOP_HX2_R2H;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSOP_S2_I2S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101101111111000000000000000
  if ((bits & 0xbfffec00U) != 0xdbf8000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSOP_S2_I2S;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSOP_SX2_R2S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110110000000000
  //   --------------------------------
  //   00001101101000001000000000000000
  if ((bits & 0xbfe0ec00U) != 0xda08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSOP_SX2_R2S;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSOP_D2_I2D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101101111111000010000000000
  if ((bits & 0xbffffc00U) != 0xdbf8400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSOP_D2_I2D;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSOP_DX2_R2D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001101101000001000010000000000
  if ((bits & 0xbfe0fc00U) != 0xda08400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSOP_DX2_R2D;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractRADDHN_ASIMDDIFF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000100000000000000
  if ((bits & 0xbf20fc00U) != 0x2e204000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::RADDHN_ASIMDDIFF_N;
  inst.iclass = InstName::RADDHN;
  return true;
}

static bool TryExtractSTUR_32_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000000000000000000000000000
  if ((bits & 0xffe00c00U) != 0xb8000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUR_32_LDST_UNSCALED;
  inst.iclass = InstName::STUR;
  return true;
}

static bool TryExtractSTUR_64_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000000000000000000000000000
  if ((bits & 0xffe00c00U) != 0xf8000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUR_64_LDST_UNSCALED;
  inst.iclass = InstName::STUR;
  return true;
}

static bool TryExtractCLS_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000000100100000000000
  if ((bits & 0xbf3ffc00U) != 0xe204800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CLS_ASIMDMISC_R;
  inst.iclass = InstName::CLS;
  return true;
}

static bool TryExtractSADDL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000000000000000000
  if ((bits & 0xbf20fc00U) != 0xe200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SADDL_ASIMDDIFF_L;
  inst.iclass = InstName::SADDL;
  return true;
}

static bool TryExtractADDP_ASISDPAIR_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01011110001100011011100000000000
  if ((bits & 0xff3ffc00U) != 0x5e31b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ADDP_ASISDPAIR_ONLY;
  inst.iclass = InstName::ADDP;
  return true;
}

static bool TryExtractCMP_SUBS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000011111
  //   --------------------------------
  //   01101011000000000000000000011111
  if ((bits & 0xff20001fU) != 0x6b00001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::CMP_SUBS_32_ADDSUB_SHIFT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractCMP_SUBS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000011111
  //   --------------------------------
  //   11101011000000000000000000011111
  if ((bits & 0xff20001fU) != 0xeb00001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::CMP_SUBS_64_ADDSUB_SHIFT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractSTR_B_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100000000000000010000000000
  if ((bits & 0xffe00c00U) != 0x3c000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_B_LDST_IMMPOST;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_H_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111100000000000000010000000000
  if ((bits & 0xffe00c00U) != 0x7c000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_H_LDST_IMMPOST;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_S_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111100000000000000010000000000
  if ((bits & 0xffe00c00U) != 0xbc000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_S_LDST_IMMPOST;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_D_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111100000000000000010000000000
  if ((bits & 0xffe00c00U) != 0xfc000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_D_LDST_IMMPOST;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_Q_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100100000000000010000000000
  if ((bits & 0xffe00c00U) != 0x3c800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_Q_LDST_IMMPOST;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_B_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100000000000000110000000000
  if ((bits & 0xffe00c00U) != 0x3c000c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_B_LDST_IMMPRE;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_H_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111100000000000000110000000000
  if ((bits & 0xffe00c00U) != 0x7c000c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_H_LDST_IMMPRE;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_S_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111100000000000000110000000000
  if ((bits & 0xffe00c00U) != 0xbc000c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_S_LDST_IMMPRE;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_D_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111100000000000000110000000000
  if ((bits & 0xffe00c00U) != 0xfc000c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_D_LDST_IMMPRE;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_Q_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100100000000000110000000000
  if ((bits & 0xffe00c00U) != 0x3c800c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_Q_LDST_IMMPRE;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_B_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00111101000000000000000000000000
  if ((bits & 0xffc00000U) != 0x3d000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_B_LDST_POS;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_H_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01111101000000000000000000000000
  if ((bits & 0xffc00000U) != 0x7d000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_H_LDST_POS;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_S_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10111101000000000000000000000000
  if ((bits & 0xffc00000U) != 0xbd000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_S_LDST_POS;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_D_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   11111101000000000000000000000000
  if ((bits & 0xffc00000U) != 0xfd000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_D_LDST_POS;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_Q_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00111101100000000000000000000000
  if ((bits & 0xffc00000U) != 0x3d800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_Q_LDST_POS;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractLDSETAB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000101000000011000000000000
  if ((bits & 0xffe0fc00U) != 0x38a03000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETAB_32_MEMOP;
  inst.iclass = InstName::LDSETAB;
  return true;
}

static bool TryExtractLDSETALB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000111000000011000000000000
  if ((bits & 0xffe0fc00U) != 0x38e03000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETALB_32_MEMOP;
  inst.iclass = InstName::LDSETALB;
  return true;
}

static bool TryExtractLDSETB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000001000000011000000000000
  if ((bits & 0xffe0fc00U) != 0x38203000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETB_32_MEMOP;
  inst.iclass = InstName::LDSETB;
  return true;
}

static bool TryExtractLDSETLB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000011000000011000000000000
  if ((bits & 0xffe0fc00U) != 0x38603000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETLB_32_MEMOP;
  inst.iclass = InstName::LDSETLB;
  return true;
}

static bool TryExtractMOV_ORR_32_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111111111100000
  //   --------------------------------
  //   00101010000000000000001111100000
  if ((bits & 0xffe0ffe0U) != 0x2a0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::MOV_ORR_32_LOG_SHIFT;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractMOV_ORR_64_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111111111100000
  //   --------------------------------
  //   10101010000000000000001111100000
  if ((bits & 0xffe0ffe0U) != 0xaa0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::MOV_ORR_64_LOG_SHIFT;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractFRINTP_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001001100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee4c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTP_H_FLOATDP1;
  inst.iclass = InstName::FRINTP;
  return true;
}

static bool TryExtractFRINTP_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001001100000000000000
  if ((bits & 0xfffffc00U) != 0x1e24c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTP_S_FLOATDP1;
  inst.iclass = InstName::FRINTP;
  return true;
}

static bool TryExtractFRINTP_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011001001100000000000000
  if ((bits & 0xfffffc00U) != 0x1e64c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTP_D_FLOATDP1;
  inst.iclass = InstName::FRINTP;
  return true;
}

static bool TryExtractCASA_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10001000111000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x88e07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASA_C32_LDSTEXCL;
  inst.iclass = InstName::CASA;
  return true;
}

static bool TryExtractCASAL_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10001000111000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x88e0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASAL_C32_LDSTEXCL;
  inst.iclass = InstName::CASAL;
  return true;
}

static bool TryExtractCAS_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10001000101000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x88a07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CAS_C32_LDSTEXCL;
  inst.iclass = InstName::CAS;
  return true;
}

static bool TryExtractCASL_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10001000101000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x88a0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASL_C32_LDSTEXCL;
  inst.iclass = InstName::CASL;
  return true;
}

static bool TryExtractCASA_C64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11001000111000000111110000000000
  if ((bits & 0xffe0fc00U) != 0xc8e07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASA_C64_LDSTEXCL;
  inst.iclass = InstName::CASA;
  return true;
}

static bool TryExtractCASAL_C64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11001000111000001111110000000000
  if ((bits & 0xffe0fc00U) != 0xc8e0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASAL_C64_LDSTEXCL;
  inst.iclass = InstName::CASAL;
  return true;
}

static bool TryExtractCAS_C64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11001000101000000111110000000000
  if ((bits & 0xffe0fc00U) != 0xc8a07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CAS_C64_LDSTEXCL;
  inst.iclass = InstName::CAS;
  return true;
}

static bool TryExtractCASL_C64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11001000101000001111110000000000
  if ((bits & 0xffe0fc00U) != 0xc8a0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASL_C64_LDSTEXCL;
  inst.iclass = InstName::CASL;
  return true;
}

static bool TryExtractWFE_HI_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010101000000110010000001011111
  if ((bits & 0xffffffffU) != 0xd503205fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::WFE_HI_SYSTEM;
  inst.iclass = InstName::WFE;
  return true;
}

static bool TryExtractLDUMINA_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000101000000111000000000000
  if ((bits & 0xffe0fc00U) != 0xb8a07000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINA_32_MEMOP;
  inst.iclass = InstName::LDUMINA;
  return true;
}

static bool TryExtractLDUMINAL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000111000000111000000000000
  if ((bits & 0xffe0fc00U) != 0xb8e07000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINAL_32_MEMOP;
  inst.iclass = InstName::LDUMINAL;
  return true;
}

static bool TryExtractLDUMIN_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000001000000111000000000000
  if ((bits & 0xffe0fc00U) != 0xb8207000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMIN_32_MEMOP;
  inst.iclass = InstName::LDUMIN;
  return true;
}

static bool TryExtractLDUMINL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000011000000111000000000000
  if ((bits & 0xffe0fc00U) != 0xb8607000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINL_32_MEMOP;
  inst.iclass = InstName::LDUMINL;
  return true;
}

static bool TryExtractLDUMINA_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000101000000111000000000000
  if ((bits & 0xffe0fc00U) != 0xf8a07000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINA_64_MEMOP;
  inst.iclass = InstName::LDUMINA;
  return true;
}

static bool TryExtractLDUMINAL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000111000000111000000000000
  if ((bits & 0xffe0fc00U) != 0xf8e07000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINAL_64_MEMOP;
  inst.iclass = InstName::LDUMINAL;
  return true;
}

static bool TryExtractLDUMIN_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000001000000111000000000000
  if ((bits & 0xffe0fc00U) != 0xf8207000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMIN_64_MEMOP;
  inst.iclass = InstName::LDUMIN;
  return true;
}

static bool TryExtractLDUMINL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000011000000111000000000000
  if ((bits & 0xffe0fc00U) != 0xf8607000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINL_64_MEMOP;
  inst.iclass = InstName::LDUMINL;
  return true;
}

static bool TryExtractSTXRB_SR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000000000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x8007c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STXRB_SR32_LDSTEXCL;
  inst.iclass = InstName::STXRB;
  return true;
}

static bool TryExtractSTLXRH_SR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000000000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x4800fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLXRH_SR32_LDSTEXCL;
  inst.iclass = InstName::STLXRH;
  return true;
}

static bool TryExtractSTLLRH_SL32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001000100111110111110000000000
  if ((bits & 0xfffffc00U) != 0x489f7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLLRH_SL32_LDSTEXCL;
  inst.iclass = InstName::STLLRH;
  return true;
}

static bool TryExtractLDUMINAH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000101000000111000000000000
  if ((bits & 0xffe0fc00U) != 0x78a07000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINAH_32_MEMOP;
  inst.iclass = InstName::LDUMINAH;
  return true;
}

static bool TryExtractLDUMINALH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000111000000111000000000000
  if ((bits & 0xffe0fc00U) != 0x78e07000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINALH_32_MEMOP;
  inst.iclass = InstName::LDUMINALH;
  return true;
}

static bool TryExtractLDUMINH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000001000000111000000000000
  if ((bits & 0xffe0fc00U) != 0x78207000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINH_32_MEMOP;
  inst.iclass = InstName::LDUMINH;
  return true;
}

static bool TryExtractLDUMINLH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000011000000111000000000000
  if ((bits & 0xffe0fc00U) != 0x78607000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMINLH_32_MEMOP;
  inst.iclass = InstName::LDUMINLH;
  return true;
}

static bool TryExtractLSLV_32_DP_2SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractLSL_LSLV_32_DP_2SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x1ac02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::LSLV_32_DP_2SRC;
  inst.iclass = InstName::LSLV;
  return true;
}

static bool TryExtractLSLV_64_DP_2SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractLSL_LSLV_64_DP_2SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x9ac02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::LSLV_64_DP_2SRC;
  inst.iclass = InstName::LSLV;
  return true;
}

static bool TryExtractINS_ASIMDINS_IR_R(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_INS_ASIMDINS_IR_R(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001110000000000001110000000000
  if ((bits & 0xffe0fc00U) != 0x4e001c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::INS_ASIMDINS_IR_R;
  inst.iclass = InstName::INS;
  return true;
}

static bool TryExtractCMGT_ASISDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01011110001000001000100000000000
  if ((bits & 0xff3ffc00U) != 0x5e208800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMGT_ASISDMISC_Z;
  inst.iclass = InstName::CMGT;
  return true;
}

static bool TryExtractCMGT_ASIMDMISC_Z(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000001000100000000000
  if ((bits & 0xbf3ffc00U) != 0xe208800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMGT_ASIMDMISC_Z;
  inst.iclass = InstName::CMGT;
  return true;
}

static bool TryExtractSMLAL_ASIMDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00001111000000000010000000000000
  if ((bits & 0xbf00f400U) != 0xf002000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMLAL_ASIMDELEM_L;
  inst.iclass = InstName::SMLAL;
  return true;
}

static bool TryExtractSTCLR_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000001000000001000000011111
  if ((bits & 0xffe0fc1fU) != 0xb820101fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STCLR_32S_MEMOP;
  inst.iclass = InstName::STCLR;
  return true;
}

static bool TryExtractSTCLRL_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000011000000001000000011111
  if ((bits & 0xffe0fc1fU) != 0xb860101fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STCLRL_32S_MEMOP;
  inst.iclass = InstName::STCLRL;
  return true;
}

static bool TryExtractSTCLR_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000001000000001000000011111
  if ((bits & 0xffe0fc1fU) != 0xf820101fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STCLR_64S_MEMOP;
  inst.iclass = InstName::STCLR;
  return true;
}

static bool TryExtractSTCLRL_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000011000000001000000011111
  if ((bits & 0xffe0fc1fU) != 0xf860101fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STCLRL_64S_MEMOP;
  inst.iclass = InstName::STCLRL;
  return true;
}

static bool TryExtractBIT_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110101000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0x2ea01c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opc2 = static_cast<uint8_t>(enc.opc2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::BIT_ASIMDSAME_ONLY;
  inst.iclass = InstName::BIT;
  return true;
}

static bool TryExtractCMEQ_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000001000110000000000
  if ((bits & 0xff20fc00U) != 0x7e208c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMEQ_ASISDSAME_ONLY;
  inst.iclass = InstName::CMEQ;
  return true;
}

static bool TryExtractCMEQ_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001000110000000000
  if ((bits & 0xbf20fc00U) != 0x2e208c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMEQ_ASIMDSAME_ONLY;
  inst.iclass = InstName::CMEQ;
  return true;
}

static bool TryExtractCRC32CB_32C_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x1ac05000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t sz : 2;
      uint32_t C : 1;
      uint32_t opcode2 : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.C = static_cast<uint8_t>(enc.C);
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CRC32CB_32C_DP_2SRC;
  inst.iclass = InstName::CRC32CB;
  return true;
}

static bool TryExtractCRC32CH_32C_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000101010000000000
  if ((bits & 0xffe0fc00U) != 0x1ac05400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t sz : 2;
      uint32_t C : 1;
      uint32_t opcode2 : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.C = static_cast<uint8_t>(enc.C);
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CRC32CH_32C_DP_2SRC;
  inst.iclass = InstName::CRC32CH;
  return true;
}

static bool TryExtractCRC32CW_32C_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000101100000000000
  if ((bits & 0xffe0fc00U) != 0x1ac05800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t sz : 2;
      uint32_t C : 1;
      uint32_t opcode2 : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.C = static_cast<uint8_t>(enc.C);
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CRC32CW_32C_DP_2SRC;
  inst.iclass = InstName::CRC32CW;
  return true;
}

static bool TryExtractCRC32CX_64C_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000101110000000000
  if ((bits & 0xffe0fc00U) != 0x9ac05c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t sz : 2;
      uint32_t C : 1;
      uint32_t opcode2 : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.C = static_cast<uint8_t>(enc.C);
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CRC32CX_64C_DP_2SRC;
  inst.iclass = InstName::CRC32CX;
  return true;
}

static bool TryExtractSTRH_32_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000001000000000100000000000
  if ((bits & 0xffe00c00U) != 0x78200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STRH_32_LDST_REGOFF;
  inst.iclass = InstName::STRH;
  return true;
}

static bool TryExtractBRK_EX_EXCEPTION(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   11010100001000000000000000000000
  if ((bits & 0xffe0001fU) != 0xd4200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t LL : 2;
      uint32_t op2 : 3;
      uint32_t imm16 : 16;
      uint32_t opc : 3;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.LL = static_cast<uint8_t>(enc.LL);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::BRK_EX_EXCEPTION;
  inst.iclass = InstName::BRK;
  return true;
}

static bool TryExtractUADDLP_ASIMDMISC_P(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000000010100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e202800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UADDLP_ASIMDMISC_P;
  inst.iclass = InstName::UADDLP;
  return true;
}

static bool TryExtractUMAXV_ASIMDALL_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001100001010100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e30a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t op : 1;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMAXV_ASIMDALL_ONLY;
  inst.iclass = InstName::UMAXV;
  return true;
}

static bool TryExtractLDEORAH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000101000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x78a02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORAH_32_MEMOP;
  inst.iclass = InstName::LDEORAH;
  return true;
}

static bool TryExtractLDEORALH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000111000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x78e02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORALH_32_MEMOP;
  inst.iclass = InstName::LDEORALH;
  return true;
}

static bool TryExtractLDEORH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000001000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x78202000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORH_32_MEMOP;
  inst.iclass = InstName::LDEORH;
  return true;
}

static bool TryExtractLDEORLH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000011000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x78602000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORLH_32_MEMOP;
  inst.iclass = InstName::LDEORLH;
  return true;
}

static bool TryExtractSMAXV_ASIMDALL_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001100001010100000000000
  if ((bits & 0xbf3ffc00U) != 0xe30a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t op : 1;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMAXV_ASIMDALL_ONLY;
  inst.iclass = InstName::SMAXV;
  return true;
}

static bool TryExtractXTN_ASIMDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000010010100000000000
  if ((bits & 0xbf3ffc00U) != 0xe212800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::XTN_ASIMDMISC_N;
  inst.iclass = InstName::XTN;
  return true;
}

static bool TryExtractSTRB_32_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000000000000000010000000000
  if ((bits & 0xffe00c00U) != 0x38000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STRB_32_LDST_IMMPOST;
  inst.iclass = InstName::STRB;
  return true;
}

static bool TryExtractSTRB_32_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000000000000000110000000000
  if ((bits & 0xffe00c00U) != 0x38000c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STRB_32_LDST_IMMPRE;
  inst.iclass = InstName::STRB;
  return true;
}

static bool TryExtractSTRB_32_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00111001000000000000000000000000
  if ((bits & 0xffc00000U) != 0x39000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STRB_32_LDST_POS;
  inst.iclass = InstName::STRB;
  return true;
}

static bool TryExtractUSQADD_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01111110001000000011100000000000
  if ((bits & 0xff3ffc00U) != 0x7e203800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::USQADD_ASISDMISC_R;
  inst.iclass = InstName::USQADD;
  return true;
}

static bool TryExtractUSQADD_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000000011100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e203800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::USQADD_ASIMDMISC_R;
  inst.iclass = InstName::USQADD;
  return true;
}

static bool TryExtractFCVTZS_32H_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110110110000000000000000000
  if ((bits & 0xffff0000U) != 0x1ed80000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_32H_FLOAT2FIX;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_64H_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110110110000000000000000000
  if ((bits & 0xffff0000U) != 0x9ed80000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_64H_FLOAT2FIX;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_32S_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110000110000000000000000000
  if ((bits & 0xffff0000U) != 0x1e180000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_32S_FLOAT2FIX;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_64S_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110000110000000000000000000
  if ((bits & 0xffff0000U) != 0x9e180000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_64S_FLOAT2FIX;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_32D_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110010110000000000000000000
  if ((bits & 0xffff0000U) != 0x1e580000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_32D_FLOAT2FIX;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_64D_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110010110000000000000000000
  if ((bits & 0xffff0000U) != 0x9e580000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_64D_FLOAT2FIX;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractUQADD_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000000000110000000000
  if ((bits & 0xff20fc00U) != 0x7e200c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQADD_ASISDSAME_ONLY;
  inst.iclass = InstName::UQADD;
  return true;
}

static bool TryExtractUQADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000000110000000000
  if ((bits & 0xbf20fc00U) != 0x2e200c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQADD_ASIMDSAME_ONLY;
  inst.iclass = InstName::UQADD;
  return true;
}

static bool TryExtractLDR_32_LOADLIT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   00011000000000000000000000000000
  if ((bits & 0xff000000U) != 0x18000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.iform = InstForm::LDR_32_LOADLIT;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_64_LOADLIT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   01011000000000000000000000000000
  if ((bits & 0xff000000U) != 0x58000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.iform = InstForm::LDR_64_LOADLIT;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractFNMSUB_H_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111111000001000000000000000
  if ((bits & 0xffe08000U) != 0x1fe08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FNMSUB_H_FLOATDP3;
  inst.iclass = InstName::FNMSUB;
  return true;
}

static bool TryExtractFNMSUB_S_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111001000001000000000000000
  if ((bits & 0xffe08000U) != 0x1f208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FNMSUB_S_FLOATDP3;
  inst.iclass = InstName::FNMSUB;
  return true;
}

static bool TryExtractFNMSUB_D_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111011000001000000000000000
  if ((bits & 0xffe08000U) != 0x1f608000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FNMSUB_D_FLOATDP3;
  inst.iclass = InstName::FNMSUB;
  return true;
}

static bool TryExtractADDP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001011110000000000
  if ((bits & 0xbf20fc00U) != 0xe20bc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ADDP_ASIMDSAME_ONLY;
  inst.iclass = InstName::ADDP;
  return true;
}

static bool TryExtractSHA1M_QSV_CRYPTOSHA3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110000000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x5e002000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHA1M_QSV_CRYPTOSHA3;
  inst.iclass = InstName::SHA1M;
  return true;
}

static bool TryExtractLDAXP_LP32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111000000000000000
  //   --------------------------------
  //   10001000011111111000000000000000
  if ((bits & 0xffff8000U) != 0x887f8000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDAXP_LP32_LDSTEXCL;
  inst.iclass = InstName::LDAXP;
  return true;
}

static bool TryExtractLDAXP_LP64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111000000000000000
  //   --------------------------------
  //   11001000011111111000000000000000
  if ((bits & 0xffff8000U) != 0xc87f8000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDAXP_LP64_LDSTEXCL;
  inst.iclass = InstName::LDAXP;
  return true;
}

static bool TryExtractCASPA_CP32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000011000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x8607c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASPA_CP32_LDSTEXCL;
  inst.iclass = InstName::CASPA;
  return true;
}

static bool TryExtractCASPAL_CP32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000011000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x860fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASPAL_CP32_LDSTEXCL;
  inst.iclass = InstName::CASPAL;
  return true;
}

static bool TryExtractCASP_CP32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000001000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x8207c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASP_CP32_LDSTEXCL;
  inst.iclass = InstName::CASP;
  return true;
}

static bool TryExtractCASPL_CP32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000001000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x820fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASPL_CP32_LDSTEXCL;
  inst.iclass = InstName::CASPL;
  return true;
}

static bool TryExtractCASPA_CP64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000011000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x48607c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASPA_CP64_LDSTEXCL;
  inst.iclass = InstName::CASPA;
  return true;
}

static bool TryExtractCASPAL_CP64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000011000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x4860fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASPAL_CP64_LDSTEXCL;
  inst.iclass = InstName::CASPAL;
  return true;
}

static bool TryExtractCASP_CP64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000001000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x48207c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASP_CP64_LDSTEXCL;
  inst.iclass = InstName::CASP;
  return true;
}

static bool TryExtractCASPL_CP64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000001000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x4820fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t sz : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASPL_CP64_LDSTEXCL;
  inst.iclass = InstName::CASPL;
  return true;
}

static bool TryExtractFCVTZU_32H_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110110110010000000000000000
  if ((bits & 0xffff0000U) != 0x1ed90000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_32H_FLOAT2FIX;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_64H_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110110110010000000000000000
  if ((bits & 0xffff0000U) != 0x9ed90000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_64H_FLOAT2FIX;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_32S_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110000110010000000000000000
  if ((bits & 0xffff0000U) != 0x1e190000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_32S_FLOAT2FIX;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_64S_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110000110010000000000000000
  if ((bits & 0xffff0000U) != 0x9e190000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_64S_FLOAT2FIX;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_32D_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110010110010000000000000000
  if ((bits & 0xffff0000U) != 0x1e590000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_32D_FLOAT2FIX;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_64D_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110010110010000000000000000
  if ((bits & 0xffff0000U) != 0x9e590000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_64D_FLOAT2FIX;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractSHA1P_QSV_CRYPTOSHA3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110000000000001000000000000
  if ((bits & 0xffe0fc00U) != 0x5e001000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHA1P_QSV_CRYPTOSHA3;
  inst.iclass = InstName::SHA1P;
  return true;
}

static bool TryExtractSADDLV_ASIMDALL_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001100000011100000000000
  if ((bits & 0xbf3ffc00U) != 0xe303800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SADDLV_ASIMDALL_ONLY;
  inst.iclass = InstName::SADDLV;
  return true;
}

static bool TryExtractTBL_ASIMDTBL_L2_2(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000010000000000000
  if ((bits & 0xbfe0fc00U) != 0xe002000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t len : 2;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t op2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.len = static_cast<uint8_t>(enc.len);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::TBL_ASIMDTBL_L2_2;
  inst.iclass = InstName::TBL;
  return true;
}

static bool TryExtractTBL_ASIMDTBL_L3_3(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000100000000000000
  if ((bits & 0xbfe0fc00U) != 0xe004000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t len : 2;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t op2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.len = static_cast<uint8_t>(enc.len);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::TBL_ASIMDTBL_L3_3;
  inst.iclass = InstName::TBL;
  return true;
}

static bool TryExtractTBL_ASIMDTBL_L4_4(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000110000000000000
  if ((bits & 0xbfe0fc00U) != 0xe006000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t len : 2;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t op2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.len = static_cast<uint8_t>(enc.len);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::TBL_ASIMDTBL_L4_4;
  inst.iclass = InstName::TBL;
  return true;
}

static bool TryExtractTBL_ASIMDTBL_L1_1(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000000000000000000
  if ((bits & 0xbfe0fc00U) != 0xe000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t len : 2;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t op2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.len = static_cast<uint8_t>(enc.len);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::TBL_ASIMDTBL_L1_1;
  inst.iclass = InstName::TBL;
  return true;
}

static bool TryExtractADD_32_ADDSUB_EXT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   00001011001000000000000000000000
  if ((bits & 0xffe00000U) != 0xb200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADD_32_ADDSUB_EXT;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractADD_64_ADDSUB_EXT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   10001011001000000000000000000000
  if ((bits & 0xffe00000U) != 0x8b200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADD_64_ADDSUB_EXT;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractFMAXNMP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110001100001100100000000000
  if ((bits & 0xfffffc00U) != 0x5e30c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXNMP_ASISDPAIR_ONLY_H;
  inst.iclass = InstName::FMAXNMP;
  return true;
}

static bool TryExtractFMAXNMP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110001100001100100000000000
  if ((bits & 0xffbffc00U) != 0x7e30c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXNMP_ASISDPAIR_ONLY_SD;
  inst.iclass = InstName::FMAXNMP;
  return true;
}

static bool TryExtractBICS_32_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   01101010001000000000000000000000
  if ((bits & 0xff200000U) != 0x6a200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::BICS_32_LOG_SHIFT;
  inst.iclass = InstName::BICS;
  return true;
}

static bool TryExtractBICS_64_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   11101010001000000000000000000000
  if ((bits & 0xff200000U) != 0xea200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::BICS_64_LOG_SHIFT;
  inst.iclass = InstName::BICS;
  return true;
}

static bool TryExtractFNMUL_H_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110111000001000100000000000
  if ((bits & 0xffe0fc00U) != 0x1ee08800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t op : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FNMUL_H_FLOATDP2;
  inst.iclass = InstName::FNMUL;
  return true;
}

static bool TryExtractFNMUL_S_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110001000001000100000000000
  if ((bits & 0xffe0fc00U) != 0x1e208800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t op : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FNMUL_S_FLOATDP2;
  inst.iclass = InstName::FNMUL;
  return true;
}

static bool TryExtractFNMUL_D_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110011000001000100000000000
  if ((bits & 0xffe0fc00U) != 0x1e608800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t op : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FNMUL_D_FLOATDP2;
  inst.iclass = InstName::FNMUL;
  return true;
}

static bool TryExtractSQSUB_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000000010110000000000
  if ((bits & 0xff20fc00U) != 0x5e202c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQSUB_ASISDSAME_ONLY;
  inst.iclass = InstName::SQSUB;
  return true;
}

static bool TryExtractSQSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000010110000000000
  if ((bits & 0xbf20fc00U) != 0xe202c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQSUB_ASIMDSAME_ONLY;
  inst.iclass = InstName::SQSUB;
  return true;
}

static bool TryExtractSQXTN_ASISDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01011110001000010100100000000000
  if ((bits & 0xff3ffc00U) != 0x5e214800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQXTN_ASISDMISC_N;
  inst.iclass = InstName::SQXTN;
  return true;
}

static bool TryExtractSQXTN_ASIMDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000010100100000000000
  if ((bits & 0xbf3ffc00U) != 0xe214800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQXTN_ASIMDMISC_N;
  inst.iclass = InstName::SQXTN;
  return true;
}

static bool TryExtractMOV_ORR_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110101000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0xea01c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::MOV_ORR_ASIMDSAME_ONLY;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractREV64_REV_64_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11011010110000000000110000000000
  if ((bits & 0xfffffc00U) != 0xdac00c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opc : 2;
      uint32_t opcode : 4;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.iform = InstForm::REV64_REV_64_DP_1SRC;
  inst.iclass = InstName::REV;
  return true;
}

static bool TryExtractSTLXRB_SR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000000000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x800fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLXRB_SR32_LDSTEXCL;
  inst.iclass = InstName::STLXRB;
  return true;
}

static bool TryExtractSTTRH_32_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000000000000000100000000000
  if ((bits & 0xffe00c00U) != 0x78000800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STTRH_32_LDST_UNPRIV;
  inst.iclass = InstName::STTRH;
  return true;
}

static bool TryExtractSMINP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001010110000000000
  if ((bits & 0xbf20fc00U) != 0xe20ac00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMINP_ASIMDSAME_ONLY;
  inst.iclass = InstName::SMINP;
  return true;
}

static bool TryExtractSHA256SU1_VVV_CRYPTOSHA3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110000000000110000000000000
  if ((bits & 0xffe0fc00U) != 0x5e006000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHA256SU1_VVV_CRYPTOSHA3;
  inst.iclass = InstName::SHA256SU1;
  return true;
}

static bool TryExtractFMSUB_H_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111110000001000000000000000
  if ((bits & 0xffe08000U) != 0x1fc08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FMSUB_H_FLOATDP3;
  inst.iclass = InstName::FMSUB;
  return true;
}

static bool TryExtractFMSUB_S_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111000000001000000000000000
  if ((bits & 0xffe08000U) != 0x1f008000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FMSUB_S_FLOATDP3;
  inst.iclass = InstName::FMSUB;
  return true;
}

static bool TryExtractFMSUB_D_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111010000001000000000000000
  if ((bits & 0xffe08000U) != 0x1f408000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FMSUB_D_FLOATDP3;
  inst.iclass = InstName::FMSUB;
  return true;
}

static bool TryExtractNGCS_SBCS_32_ADDSUB_CARRY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111111111100000
  //   --------------------------------
  //   01111010000000000000001111100000
  if ((bits & 0xffe0ffe0U) != 0x7a0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::NGCS_SBCS_32_ADDSUB_CARRY;
  inst.iclass = InstName::SBCS;
  return true;
}

static bool TryExtractNGCS_SBCS_64_ADDSUB_CARRY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111111111100000
  //   --------------------------------
  //   11111010000000000000001111100000
  if ((bits & 0xffe0ffe0U) != 0xfa0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::NGCS_SBCS_64_ADDSUB_CARRY;
  inst.iclass = InstName::SBCS;
  return true;
}

static bool TryExtractSTR_32_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000000000000000010000000000
  if ((bits & 0xffe00c00U) != 0xb8000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_32_LDST_IMMPOST;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_64_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000000000000000010000000000
  if ((bits & 0xffe00c00U) != 0xf8000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_64_LDST_IMMPOST;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_32_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000000000000000110000000000
  if ((bits & 0xffe00c00U) != 0xb8000c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_32_LDST_IMMPRE;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_64_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000000000000000110000000000
  if ((bits & 0xffe00c00U) != 0xf8000c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_64_LDST_IMMPRE;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_32_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10111001000000000000000000000000
  if ((bits & 0xffc00000U) != 0xb9000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_32_LDST_POS;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_64_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   11111001000000000000000000000000
  if ((bits & 0xffc00000U) != 0xf9000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_64_LDST_POS;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractINS_ASIMDINS_IV_V(InstData &inst, uint32_t bits) {
  if (TryExtractMOV_INS_ASIMDINS_IV_V(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000010000000000
  //   --------------------------------
  //   01101110000000000000010000000000
  if ((bits & 0xffe08400U) != 0x6e000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::INS_ASIMDINS_IV_V;
  inst.iclass = InstName::INS;
  return true;
}

static bool TryExtractDCPS2_DC_EXCEPTION(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   11010100101000000000000000000010
  if ((bits & 0xffe0001fU) != 0xd4a00002U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t LL : 2;
      uint32_t op2 : 3;
      uint32_t imm16 : 16;
      uint32_t opc : 3;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.LL = static_cast<uint8_t>(enc.LL);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::DCPS2_DC_EXCEPTION;
  inst.iclass = InstName::DCPS2;
  return true;
}

static bool TryExtractTST_ANDS_32_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000011111
  //   --------------------------------
  //   01101010000000000000000000011111
  if ((bits & 0xff20001fU) != 0x6a00001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::TST_ANDS_32_LOG_SHIFT;
  inst.iclass = InstName::ANDS;
  return true;
}

static bool TryExtractTST_ANDS_64_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000011111
  //   --------------------------------
  //   11101010000000000000000000011111
  if ((bits & 0xff20001fU) != 0xea00001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::TST_ANDS_64_LOG_SHIFT;
  inst.iclass = InstName::ANDS;
  return true;
}

static bool TryExtractDCPS1_DC_EXCEPTION(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   11010100101000000000000000000001
  if ((bits & 0xffe0001fU) != 0xd4a00001U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t LL : 2;
      uint32_t op2 : 3;
      uint32_t imm16 : 16;
      uint32_t opc : 3;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.LL = static_cast<uint8_t>(enc.LL);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::DCPS1_DC_EXCEPTION;
  inst.iclass = InstName::DCPS1;
  return true;
}

static bool TryExtractFMLA_ASISDELEM_RH_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000001111010000000000
  //   --------------------------------
  //   01011111000000000001000000000000
  if ((bits & 0xffc0f400U) != 0x5f001000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FMLA_ASISDELEM_RH_H;
  inst.iclass = InstName::FMLA;
  return true;
}

static bool TryExtractFMLA_ASISDELEM_R_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111010000000000
  //   --------------------------------
  //   01011111100000000001000000000000
  if ((bits & 0xff80f400U) != 0x5f801000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.iform = InstForm::FMLA_ASISDELEM_R_SD;
  inst.iclass = InstName::FMLA;
  return true;
}

static bool TryExtractFMLA_ASIMDELEM_RH_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111110000001111010000000000
  //   --------------------------------
  //   00001111000000000001000000000000
  if ((bits & 0xbfc0f400U) != 0xf001000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FMLA_ASIMDELEM_RH_H;
  inst.iclass = InstName::FMLA;
  return true;
}

static bool TryExtractFMLA_ASIMDELEM_R_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111010000000000
  //   --------------------------------
  //   00001111100000000001000000000000
  if ((bits & 0xbf80f400U) != 0xf801000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t sz : 1;
      uint32_t opcode: 6; // 011111
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.iform = InstForm::FMLA_ASIMDELEM_R_SD;
  inst.iclass = InstName::FMLA;
  return true;
}

static bool TryExtractSCVTF_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110011110011101100000000000
  if ((bits & 0xfffffc00U) != 0x5e79d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::SCVTF_ASISDMISCFP16_R;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110001000011101100000000000
  if ((bits & 0xffbffc00U) != 0x5e21d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::SCVTF_ASISDMISC_R;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110011110011101100000000000
  if ((bits & 0xbffffc00U) != 0xe79d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SCVTF_ASIMDMISCFP16_R;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110001000011101100000000000
  if ((bits & 0xbfbffc00U) != 0xe21d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::SCVTF_ASIMDMISC_R;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractUMULL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001100000000000000
  if ((bits & 0xbf20fc00U) != 0x2e20c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMULL_ASIMDDIFF_L;
  inst.iclass = InstName::UMULL;
  return true;
}

static bool TryExtractFMUL_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110010000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0x2e401c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMUL_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMUL;
  return true;
}

static bool TryExtractFMUL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110001000001101110000000000
  if ((bits & 0xbfa0fc00U) != 0x2e20dc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMUL_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMUL;
  return true;
}

static bool TryExtractFMLA_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110010000000000110000000000
  if ((bits & 0xbfe0fc00U) != 0xe400c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMLA_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMLA;
  return true;
}

static bool TryExtractFMLA_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110001000001100110000000000
  if ((bits & 0xbfa0fc00U) != 0xe20cc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t op : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMLA_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMLA;
  return true;
}

static bool TryExtractSDIV_32_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000000110000000000
  if ((bits & 0xffe0fc00U) != 0x1ac00c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o1 : 1;
      uint32_t opcode2 : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SDIV_32_DP_2SRC;
  inst.iclass = InstName::SDIV;
  return true;
}

static bool TryExtractSDIV_64_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000000110000000000
  if ((bits & 0xffe0fc00U) != 0x9ac00c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o1 : 1;
      uint32_t opcode2 : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SDIV_64_DP_2SRC;
  inst.iclass = InstName::SDIV;
  return true;
}

static bool TryExtractADD_32_ADDSUB_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_ADD_32_ADDSUB_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   00010001000000000000000000000000
  if ((bits & 0xff000000U) != 0x11000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADD_32_ADDSUB_IMM;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractADD_64_ADDSUB_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_ADD_64_ADDSUB_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   10010001000000000000000000000000
  if ((bits & 0xff000000U) != 0x91000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADD_64_ADDSUB_IMM;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractRBIT_32_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011010110000000000000000000000
  if ((bits & 0xfffffc00U) != 0x5ac00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode : 6;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.iform = InstForm::RBIT_32_DP_1SRC;
  inst.iclass = InstName::RBIT;
  return true;
}

static bool TryExtractRBIT_64_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11011010110000000000000000000000
  if ((bits & 0xfffffc00U) != 0xdac00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode : 6;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.iform = InstForm::RBIT_64_DP_1SRC;
  inst.iclass = InstName::RBIT;
  return true;
}

static bool TryExtractSMNEGL_SMSUBL_64WA_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011011001000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x9b20fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SMNEGL_SMSUBL_64WA_DP_3SRC;
  inst.iclass = InstName::SMSUBL;
  return true;
}

static bool TryExtractMOV_DUP_ASISDONE_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110000000000000010000000000
  if ((bits & 0xffe0fc00U) != 0x5e000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOV_DUP_ASISDONE_ONLY;
  inst.iclass = InstName::DUP;
  return true;
}

static bool TryExtractSMULL_SMADDL_64WA_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011011001000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x9b207c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SMULL_SMADDL_64WA_DP_3SRC;
  inst.iclass = InstName::SMADDL;
  return true;
}

static bool TryExtractZIP2_ASIMDPERM_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110000000000111100000000000
  if ((bits & 0xbf20fc00U) != 0xe007800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ZIP2_ASIMDPERM_ONLY;
  inst.iclass = InstName::ZIP2;
  return true;
}

static bool TryExtractLDAXRB_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00001000010111111111110000000000
  if ((bits & 0xfffffc00U) != 0x85ffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDAXRB_LR32_LDSTEXCL;
  inst.iclass = InstName::LDAXRB;
  return true;
}

static bool TryExtractMNEG_MSUB_32A_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011011000000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x1b00fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t op31 : 3;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.op31 = static_cast<uint8_t>(enc.op31);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MNEG_MSUB_32A_DP_3SRC;
  inst.iclass = InstName::MSUB;
  return true;
}

static bool TryExtractMNEG_MSUB_64A_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011011000000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x9b00fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t op31 : 3;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.op31 = static_cast<uint8_t>(enc.op31);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MNEG_MSUB_64A_DP_3SRC;
  inst.iclass = InstName::MSUB;
  return true;
}

static bool TryExtractHVC_EX_EXCEPTION(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   11010100000000000000000000000010
  if ((bits & 0xffe0001fU) != 0xd4000002U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t LL : 2;
      uint32_t op2 : 3;
      uint32_t imm16 : 16;
      uint32_t opc : 3;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.LL = static_cast<uint8_t>(enc.LL);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::HVC_EX_EXCEPTION;
  inst.iclass = InstName::HVC;
  return true;
}

static bool TryExtractDCPS3_DC_EXCEPTION(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   11010100101000000000000000000011
  if ((bits & 0xffe0001fU) != 0xd4a00003U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t LL : 2;
      uint32_t op2 : 3;
      uint32_t imm16 : 16;
      uint32_t opc : 3;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.LL = static_cast<uint8_t>(enc.LL);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::DCPS3_DC_EXCEPTION;
  inst.iclass = InstName::DCPS3;
  return true;
}

static bool TryExtractFCVTNU_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01111110011110011010100000000000
  if ((bits & 0xfffffc00U) != 0x7e79a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTNU_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractFCVTNU_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110001000011010100000000000
  if ((bits & 0xffbffc00U) != 0x7e21a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTNU_ASISDMISC_R;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractFCVTNU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110011110011010100000000000
  if ((bits & 0xbffffc00U) != 0x2e79a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTNU_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractFCVTNU_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110001000011010100000000000
  if ((bits & 0xbfbffc00U) != 0x2e21a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTNU_ASIMDMISC_R;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractSTUMINB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000001000000111000000011111
  if ((bits & 0xffe0fc1fU) != 0x3820701fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMINB_32S_MEMOP;
  inst.iclass = InstName::STUMINB;
  return true;
}

static bool TryExtractSTUMINLB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000011000000111000000011111
  if ((bits & 0xffe0fc1fU) != 0x3860701fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMINLB_32S_MEMOP;
  inst.iclass = InstName::STUMINLB;
  return true;
}

static bool TryExtractTBNZ_ONLY_TESTBRANCH(InstData &inst, uint32_t bits) {

  //   bits
  // & 01111111000000000000000000000000
  //   --------------------------------
  //   00110111000000000000000000000000
  if ((bits & 0x7f000000U) != 0x37000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm14 : 14;
      uint32_t b40 : 5;
      uint32_t op : 1;
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t _30 : 1;  // 0
      uint32_t b5 : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.b5 = static_cast<uint8_t>(enc.b5);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.imm14.uimm = static_cast<uint64_t>(enc.imm14);
  inst.b40 = static_cast<uint8_t>(enc.b40);
  inst.iform = InstForm::TBNZ_ONLY_TESTBRANCH;
  inst.iclass = InstName::TBNZ;
  return true;
}

static bool TryExtractSTCLRH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000001000000001000000011111
  if ((bits & 0xffe0fc1fU) != 0x7820101fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STCLRH_32S_MEMOP;
  inst.iclass = InstName::STCLRH;
  return true;
}

static bool TryExtractSTCLRLH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000011000000001000000011111
  if ((bits & 0xffe0fc1fU) != 0x7860101fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STCLRLH_32S_MEMOP;
  inst.iclass = InstName::STCLRLH;
  return true;
}

static bool TryExtractBL_ONLY_BRANCH_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111100000000000000000000000000
  //   --------------------------------
  //   10010100000000000000000000000000
  if ((bits & 0xfc000000U) != 0x94000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t imm26 : 26;
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 0
      uint32_t op : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm26.uimm = static_cast<uint64_t>(enc.imm26);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::BL_ONLY_BRANCH_IMM;
  inst.iclass = InstName::BL;
  return true;
}

static bool TryExtractFCVTMU_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01111110011110011011100000000000
  if ((bits & 0xfffffc00U) != 0x7e79b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTMU_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractFCVTMU_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110001000011011100000000000
  if ((bits & 0xffbffc00U) != 0x7e21b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTMU_ASISDMISC_R;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractFCVTMU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110011110011011100000000000
  if ((bits & 0xbffffc00U) != 0x2e79b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTMU_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractFCVTMU_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110001000011011100000000000
  if ((bits & 0xbfbffc00U) != 0x2e21b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTMU_ASIMDMISC_R;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractFMAXNMP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110010000000000010000000000
  if ((bits & 0xbfe0fc00U) != 0x2e400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t Op3 : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Op3 = static_cast<uint8_t>(enc.Op3);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FMAXNMP_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMAXNMP;
  return true;
}

static bool TryExtractFMAXNMP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110001000001100010000000000
  if ((bits & 0xbfa0fc00U) != 0x2e20c400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXNMP_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMAXNMP;
  return true;
}

static bool TryExtractFMOV_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001100000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee60000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_32H_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111001100000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee60000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_64H_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_H32_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001110000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee70000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_H32_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_S32_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001110000000000000000
  if ((bits & 0xfffffc00U) != 0x1e270000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_S32_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001100000000000000000
  if ((bits & 0xfffffc00U) != 0x1e260000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_32S_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_H64_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111001110000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee70000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_H64_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_D64_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011001110000000000000000
  if ((bits & 0xfffffc00U) != 0x9e670000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_D64_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_V64I_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110101011110000000000000000
  if ((bits & 0xfffffc00U) != 0x9eaf0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_V64I_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011001100000000000000000
  if ((bits & 0xfffffc00U) != 0x9e660000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_64D_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_64VX_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110101011100000000000000000
  if ((bits & 0xfffffc00U) != 0x9eae0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FMOV_64VX_FLOAT2INT;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractLDCLRAH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000101000000001000000000000
  if ((bits & 0xffe0fc00U) != 0x78a01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRAH_32_MEMOP;
  inst.iclass = InstName::LDCLRAH;
  return true;
}

static bool TryExtractLDCLRALH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000111000000001000000000000
  if ((bits & 0xffe0fc00U) != 0x78e01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRALH_32_MEMOP;
  inst.iclass = InstName::LDCLRALH;
  return true;
}

static bool TryExtractLDCLRH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000001000000001000000000000
  if ((bits & 0xffe0fc00U) != 0x78201000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRH_32_MEMOP;
  inst.iclass = InstName::LDCLRH;
  return true;
}

static bool TryExtractLDCLRLH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000011000000001000000000000
  if ((bits & 0xffe0fc00U) != 0x78601000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRLH_32_MEMOP;
  inst.iclass = InstName::LDCLRLH;
  return true;
}

static bool TryExtractSABAL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000101000000000000
  if ((bits & 0xbf20fc00U) != 0xe205000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t op : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SABAL_ASIMDDIFF_L;
  inst.iclass = InstName::SABAL;
  return true;
}

static bool TryExtractLDSETA_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000101000000011000000000000
  if ((bits & 0xffe0fc00U) != 0xb8a03000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETA_32_MEMOP;
  inst.iclass = InstName::LDSETA;
  return true;
}

static bool TryExtractLDSETAL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000111000000011000000000000
  if ((bits & 0xffe0fc00U) != 0xb8e03000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETAL_32_MEMOP;
  inst.iclass = InstName::LDSETAL;
  return true;
}

static bool TryExtractLDSET_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000001000000011000000000000
  if ((bits & 0xffe0fc00U) != 0xb8203000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSET_32_MEMOP;
  inst.iclass = InstName::LDSET;
  return true;
}

static bool TryExtractLDSETL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000011000000011000000000000
  if ((bits & 0xffe0fc00U) != 0xb8603000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETL_32_MEMOP;
  inst.iclass = InstName::LDSETL;
  return true;
}

static bool TryExtractLDSETA_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000101000000011000000000000
  if ((bits & 0xffe0fc00U) != 0xf8a03000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETA_64_MEMOP;
  inst.iclass = InstName::LDSETA;
  return true;
}

static bool TryExtractLDSETAL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000111000000011000000000000
  if ((bits & 0xffe0fc00U) != 0xf8e03000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETAL_64_MEMOP;
  inst.iclass = InstName::LDSETAL;
  return true;
}

static bool TryExtractLDSET_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000001000000011000000000000
  if ((bits & 0xffe0fc00U) != 0xf8203000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSET_64_MEMOP;
  inst.iclass = InstName::LDSET;
  return true;
}

static bool TryExtractLDSETL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000011000000011000000000000
  if ((bits & 0xffe0fc00U) != 0xf8603000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSETL_64_MEMOP;
  inst.iclass = InstName::LDSETL;
  return true;
}

static bool TryExtractFRECPS_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110010000000011110000000000
  if ((bits & 0xffe0fc00U) != 0x5e403c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRECPS_ASISDSAMEFP16_ONLY;
  inst.iclass = InstName::FRECPS;
  return true;
}

static bool TryExtractFRECPS_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101000001111110000000000
  //   --------------------------------
  //   01011110001000001111110000000000
  if ((bits & 0xffa0fc00U) != 0x5e20fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRECPS_ASISDSAME_ONLY;
  inst.iclass = InstName::FRECPS;
  return true;
}

static bool TryExtractFRECPS_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110010000000011110000000000
  if ((bits & 0xbfe0fc00U) != 0xe403c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRECPS_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FRECPS;
  return true;
}

static bool TryExtractFRECPS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110001000001111110000000000
  if ((bits & 0xbfa0fc00U) != 0xe20fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRECPS_ASIMDSAME_ONLY;
  inst.iclass = InstName::FRECPS;
  return true;
}

static bool TryExtractSMLAL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001000000000000000
  if ((bits & 0xbf20fc00U) != 0xe208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMLAL_ASIMDDIFF_L;
  inst.iclass = InstName::SMLAL;
  return true;
}

static bool TryExtractLDSMINAH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000101000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x78a05000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINAH_32_MEMOP;
  inst.iclass = InstName::LDSMINAH;
  return true;
}

static bool TryExtractLDSMINALH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000111000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x78e05000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINALH_32_MEMOP;
  inst.iclass = InstName::LDSMINALH;
  return true;
}

static bool TryExtractLDSMINH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000001000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x78205000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINH_32_MEMOP;
  inst.iclass = InstName::LDSMINH;
  return true;
}

static bool TryExtractLDSMINLH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000011000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x78605000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINLH_32_MEMOP;
  inst.iclass = InstName::LDSMINLH;
  return true;
}

static bool TryExtractFRINTI_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001111100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee7c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTI_H_FLOATDP1;
  inst.iclass = InstName::FRINTI;
  return true;
}

static bool TryExtractFRINTI_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001111100000000000000
  if ((bits & 0xfffffc00U) != 0x1e27c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTI_S_FLOATDP1;
  inst.iclass = InstName::FRINTI;
  return true;
}

static bool TryExtractFRINTI_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011001111100000000000000
  if ((bits & 0xfffffc00U) != 0x1e67c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTI_D_FLOATDP1;
  inst.iclass = InstName::FRINTI;
  return true;
}

static bool TryExtractSMULH_64_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011011010000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x9b407c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SMULH_64_DP_3SRC;
  inst.iclass = InstName::SMULH;
  return true;
}

static bool TryExtractFMADD_H_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111110000000000000000000000
  if ((bits & 0xffe08000U) != 0x1fc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FMADD_H_FLOATDP3;
  inst.iclass = InstName::FMADD;
  return true;
}

static bool TryExtractFMADD_S_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111000000000000000000000000
  if ((bits & 0xffe08000U) != 0x1f000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FMADD_S_FLOATDP3;
  inst.iclass = InstName::FMADD;
  return true;
}

static bool TryExtractFMADD_D_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111010000000000000000000000
  if ((bits & 0xffe08000U) != 0x1f400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FMADD_D_FLOATDP3;
  inst.iclass = InstName::FMADD;
  return true;
}

static bool TryExtractCCMP_32_CONDCMP_REG(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   01111010010000000000000000000000
  if ((bits & 0xffe00c10U) != 0x7a400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t o3 : 1;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CCMP_32_CONDCMP_REG;
  inst.iclass = InstName::CCMP;
  return true;
}

static bool TryExtractCCMP_64_CONDCMP_REG(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   11111010010000000000000000000000
  if ((bits & 0xffe00c10U) != 0xfa400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t o3 : 1;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CCMP_64_CONDCMP_REG;
  inst.iclass = InstName::CCMP;
  return true;
}

static bool TryExtractSRSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000000101010000000000
  if ((bits & 0xff20fc00U) != 0x5e205400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SRSHL_ASISDSAME_ONLY;
  inst.iclass = InstName::SRSHL;
  return true;
}

static bool TryExtractSRSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000101010000000000
  if ((bits & 0xbf20fc00U) != 0xe205400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SRSHL_ASIMDSAME_ONLY;
  inst.iclass = InstName::SRSHL;
  return true;
}

static bool TryExtractFADD_H_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110111000000010100000000000
  if ((bits & 0xffe0fc00U) != 0x1ee02800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FADD_H_FLOATDP2;
  inst.iclass = InstName::FADD;
  return true;
}

static bool TryExtractFADD_S_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110001000000010100000000000
  if ((bits & 0xffe0fc00U) != 0x1e202800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FADD_S_FLOATDP2;
  inst.iclass = InstName::FADD;
  return true;
}

static bool TryExtractFADD_D_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110011000000010100000000000
  if ((bits & 0xffe0fc00U) != 0x1e602800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FADD_D_FLOATDP2;
  inst.iclass = InstName::FADD;
  return true;
}

static bool TryExtractFMULX_ASISDELEM_RH_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000001111010000000000
  //   --------------------------------
  //   01111111000000001001000000000000
  if ((bits & 0xffc0f400U) != 0x7f009000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FMULX_ASISDELEM_RH_H;
  inst.iclass = InstName::FMULX;
  return true;
}

static bool TryExtractFMULX_ASISDELEM_R_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111010000000000
  //   --------------------------------
  //   01111111100000001001000000000000
  if ((bits & 0xff80f400U) != 0x7f809000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMULX_ASISDELEM_R_SD;
  inst.iclass = InstName::FMULX;
  return true;
}

static bool TryExtractFMULX_ASIMDELEM_RH_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111110000001111010000000000
  //   --------------------------------
  //   00101111000000001001000000000000
  if ((bits & 0xbfc0f400U) != 0x2f009000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FMULX_ASIMDELEM_RH_H;
  inst.iclass = InstName::FMULX;
  return true;
}

static bool TryExtractFMULX_ASIMDELEM_R_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111010000000000
  //   --------------------------------
  //   00101111100000001001000000000000
  if ((bits & 0xbf80f400U) != 0x2f809000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMULX_ASIMDELEM_R_SD;
  inst.iclass = InstName::FMULX;
  return true;
}

static bool TryExtractBIC_ASIMDIMM_L_HL(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001101110000000000
  //   --------------------------------
  //   00101111000000001001010000000000
  if ((bits & 0xbff8dc00U) != 0x2f009400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::BIC_ASIMDIMM_L_HL;
  inst.iclass = InstName::BIC;
  return true;
}

static bool TryExtractBIC_ASIMDIMM_L_SL(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001001110000000000
  //   --------------------------------
  //   00101111000000000001010000000000
  if ((bits & 0xbff89c00U) != 0x2f001400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::BIC_ASIMDIMM_L_SL;
  inst.iclass = InstName::BIC;
  return true;
}

static bool TryExtractDC_SYS_CR_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111110001111000000000000
  //   --------------------------------
  //   11010101000010000111000000000000
  if ((bits & 0xfff8f000U) != 0xd5087000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::DC_SYS_CR_SYSTEM;
  inst.iclass = InstName::SYS;
  return true;
}

static bool TryExtractPRFM_P_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000101000000000100000000000
  if ((bits & 0xffe00c00U) != 0xf8a00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::PRFM_P_LDST_REGOFF;
  inst.iclass = InstName::PRFM;
  return true;
}

static bool TryExtractSTUMINH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000001000000111000000011111
  if ((bits & 0xffe0fc1fU) != 0x7820701fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMINH_32S_MEMOP;
  inst.iclass = InstName::STUMINH;
  return true;
}

static bool TryExtractSTUMINLH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000011000000111000000011111
  if ((bits & 0xffe0fc1fU) != 0x7860701fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMINLH_32S_MEMOP;
  inst.iclass = InstName::STUMINLH;
  return true;
}

static bool TryExtractORR_ASIMDIMM_L_HL(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001101110000000000
  //   --------------------------------
  //   00001111000000001001010000000000
  if ((bits & 0xbff8dc00U) != 0xf009400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ORR_ASIMDIMM_L_HL;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractORR_ASIMDIMM_L_SL(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001001110000000000
  //   --------------------------------
  //   00001111000000000001010000000000
  if ((bits & 0xbff89c00U) != 0xf001400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ORR_ASIMDIMM_L_SL;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractFCVTAU_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001010000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee50000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAU_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractFCVTAU_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111001010000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee50000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAU_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractFCVTAU_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e250000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAU_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractFCVTAU_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001001010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e250000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAU_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractFCVTAU_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011001010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e650000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAU_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractFCVTAU_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011001010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e650000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAU_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTAU;
  return true;
}

static bool TryExtractLDXR_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10001000010111110111110000000000
  if ((bits & 0xfffffc00U) != 0x885f7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDXR_LR32_LDSTEXCL;
  inst.iclass = InstName::LDXR;
  return true;
}

static bool TryExtractLDXR_LR64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11001000010111110111110000000000
  if ((bits & 0xfffffc00U) != 0xc85f7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDXR_LR64_LDSTEXCL;
  inst.iclass = InstName::LDXR;
  return true;
}

static bool TryExtractTLBI_SYS_CR_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111110001111000000000000
  //   --------------------------------
  //   11010101000010001000000000000000
  if ((bits & 0xfff8f000U) != 0xd5088000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::TLBI_SYS_CR_SYSTEM;
  inst.iclass = InstName::SYS;
  return true;
}

static bool TryExtractSVC_EX_EXCEPTION(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   11010100000000000000000000000001
  if ((bits & 0xffe0001fU) != 0xd4000001U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t LL : 2;
      uint32_t op2 : 3;
      uint32_t imm16 : 16;
      uint32_t opc : 3;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.LL = static_cast<uint8_t>(enc.LL);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::SVC_EX_EXCEPTION;
  inst.iclass = InstName::SVC;
  return true;
}

static bool TryExtractFCMPE_H_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110111000000010000000010000
  if ((bits & 0xffe0fc1fU) != 0x1ee02010U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMPE_H_FLOATCMP;
  inst.iclass = InstName::FCMPE;
  return true;
}

static bool TryExtractFCMPE_HZ_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110111000000010000000011000
  if ((bits & 0xffe0fc1fU) != 0x1ee02018U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMPE_HZ_FLOATCMP;
  inst.iclass = InstName::FCMPE;
  return true;
}

static bool TryExtractFCMPE_S_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110001000000010000000010000
  if ((bits & 0xffe0fc1fU) != 0x1e202010U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMPE_S_FLOATCMP;
  inst.iclass = InstName::FCMPE;
  return true;
}

static bool TryExtractFCMPE_SZ_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110001000000010000000011000
  if ((bits & 0xffe0fc1fU) != 0x1e202018U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMPE_SZ_FLOATCMP;
  inst.iclass = InstName::FCMPE;
  return true;
}

static bool TryExtractFCMPE_D_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110011000000010000000010000
  if ((bits & 0xffe0fc1fU) != 0x1e602010U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMPE_D_FLOATCMP;
  inst.iclass = InstName::FCMPE;
  return true;
}

static bool TryExtractFCMPE_DZ_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110011000000010000000011000
  if ((bits & 0xffe0fc1fU) != 0x1e602018U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMPE_DZ_FLOATCMP;
  inst.iclass = InstName::FCMPE;
  return true;
}

static bool TryExtractFRSQRTS_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110110000000011110000000000
  if ((bits & 0xffe0fc00U) != 0x5ec03c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRSQRTS_ASISDSAMEFP16_ONLY;
  inst.iclass = InstName::FRSQRTS;
  return true;
}

static bool TryExtractFRSQRTS_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101000001111110000000000
  //   --------------------------------
  //   01011110101000001111110000000000
  if ((bits & 0xffa0fc00U) != 0x5ea0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRSQRTS_ASISDSAME_ONLY;
  inst.iclass = InstName::FRSQRTS;
  return true;
}

static bool TryExtractFRSQRTS_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110110000000011110000000000
  if ((bits & 0xbfe0fc00U) != 0xec03c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRSQRTS_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FRSQRTS;
  return true;
}

static bool TryExtractFRSQRTS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110101000001111110000000000
  if ((bits & 0xbfa0fc00U) != 0xea0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRSQRTS_ASIMDSAME_ONLY;
  inst.iclass = InstName::FRSQRTS;
  return true;
}

static bool TryExtractFRINTN_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001000100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee44000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTN_H_FLOATDP1;
  inst.iclass = InstName::FRINTN;
  return true;
}

static bool TryExtractFRINTN_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001000100000000000000
  if ((bits & 0xfffffc00U) != 0x1e244000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTN_S_FLOATDP1;
  inst.iclass = InstName::FRINTN;
  return true;
}

static bool TryExtractFRINTN_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011001000100000000000000
  if ((bits & 0xfffffc00U) != 0x1e644000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTN_D_FLOATDP1;
  inst.iclass = InstName::FRINTN;
  return true;
}

static bool TryExtractFMOV_H_FLOATIMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000001111111100000
  //   --------------------------------
  //   00011110111000000001000000000000
  if ((bits & 0xffe01fe0U) != 0x1ee01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm5 : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t imm8 : 8;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.type = static_cast<uint8_t>(enc.type);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.imm8.uimm = static_cast<uint64_t>(enc.imm8);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.iform = InstForm::FMOV_H_FLOATIMM;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_S_FLOATIMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000001111111100000
  //   --------------------------------
  //   00011110001000000001000000000000
  if ((bits & 0xffe01fe0U) != 0x1e201000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm5 : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t imm8 : 8;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.type = static_cast<uint8_t>(enc.type);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.imm8.uimm = static_cast<uint64_t>(enc.imm8);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.iform = InstForm::FMOV_S_FLOATIMM;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_D_FLOATIMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000001111111100000
  //   --------------------------------
  //   00011110011000000001000000000000
  if ((bits & 0xffe01fe0U) != 0x1e601000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm5 : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t imm8 : 8;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.type = static_cast<uint8_t>(enc.type);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.imm8.uimm = static_cast<uint64_t>(enc.imm8);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.iform = InstForm::FMOV_D_FLOATIMM;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractEOR_32_LOG_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01010010000000000000000000000000
  if ((bits & 0xffc00000U) != 0x52000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::EOR_32_LOG_IMM;
  inst.iclass = InstName::EOR;
  return true;
}

static bool TryExtractEOR_64_LOG_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   11010010000000000000000000000000
  if ((bits & 0xff800000U) != 0xd2000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::EOR_64_LOG_IMM;
  inst.iclass = InstName::EOR;
  return true;
}

static bool TryExtractMRS_RS_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111100000000000000000000
  //   --------------------------------
  //   11010101001100000000000000000000
  if ((bits & 0xfff00000U) != 0xd5300000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t o0 : 1;
      uint32_t _20 : 1;  // 1
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MRS_RS_SYSTEM;
  inst.iclass = InstName::MRS;
  return true;
}

static bool TryExtractESB_HI_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010101000000110010001000011111
  if ((bits & 0xffffffffU) != 0xd503221fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::ESB_HI_SYSTEM;
  inst.iclass = InstName::ESB;
  return true;
}

static bool TryExtractFCMLT_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110111110001110100000000000
  if ((bits & 0xfffffc00U) != 0x5ef8e800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCMLT_ASISDMISCFP16_FZ;
  inst.iclass = InstName::FCMLT;
  return true;
}

static bool TryExtractFCMLT_ASISDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110101000001110100000000000
  if ((bits & 0xffbffc00U) != 0x5ea0e800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCMLT_ASISDMISC_FZ;
  inst.iclass = InstName::FCMLT;
  return true;
}

static bool TryExtractFCMLT_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110111110001110100000000000
  if ((bits & 0xbffffc00U) != 0xef8e800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMLT_ASIMDMISCFP16_FZ;
  inst.iclass = InstName::FCMLT;
  return true;
}

static bool TryExtractFCMLT_ASIMDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000001110100000000000
  if ((bits & 0xbfbffc00U) != 0xea0e800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCMLT_ASIMDMISC_FZ;
  inst.iclass = InstName::FCMLT;
  return true;
}

static bool TryExtractSQRDMULH_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000001011010000000000
  if ((bits & 0xff20fc00U) != 0x7e20b400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMULH_ASISDSAME_ONLY;
  inst.iclass = InstName::SQRDMULH;
  return true;
}

static bool TryExtractSQRDMULH_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001011010000000000
  if ((bits & 0xbf20fc00U) != 0x2e20b400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMULH_ASIMDSAME_ONLY;
  inst.iclass = InstName::SQRDMULH;
  return true;
}

static bool TryExtractSWPAH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000101000001000000000000000
  if ((bits & 0xffe0fc00U) != 0x78a08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPAH_32_MEMOP;
  inst.iclass = InstName::SWPAH;
  return true;
}

static bool TryExtractSWPALH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000111000001000000000000000
  if ((bits & 0xffe0fc00U) != 0x78e08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPALH_32_MEMOP;
  inst.iclass = InstName::SWPALH;
  return true;
}

static bool TryExtractSWPH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000001000001000000000000000
  if ((bits & 0xffe0fc00U) != 0x78208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPH_32_MEMOP;
  inst.iclass = InstName::SWPH;
  return true;
}

static bool TryExtractSWPLH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000011000001000000000000000
  if ((bits & 0xffe0fc00U) != 0x78608000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPLH_32_MEMOP;
  inst.iclass = InstName::SWPLH;
  return true;
}

static bool TryExtractDUP_ASISDONE_ONLY(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_DUP_ASISDONE_ONLY(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110000000000000010000000000
  if ((bits & 0xffe0fc00U) != 0x5e000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::DUP_ASISDONE_ONLY;
  inst.iclass = InstName::DUP;
  return true;
}

static bool TryExtractDUP_ASIMDINS_DV_V(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000000010000000000
  if ((bits & 0xbfe0fc00U) != 0xe000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::DUP_ASIMDINS_DV_V;
  inst.iclass = InstName::DUP;
  return true;
}

static bool TryExtractSTLRH_SL32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001000100111111111110000000000
  if ((bits & 0xfffffc00U) != 0x489ffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLRH_SL32_LDSTEXCL;
  inst.iclass = InstName::STLRH;
  return true;
}

static bool TryExtractLDUMAXA_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000101000000110000000000000
  if ((bits & 0xffe0fc00U) != 0xb8a06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXA_32_MEMOP;
  inst.iclass = InstName::LDUMAXA;
  return true;
}

static bool TryExtractLDUMAXAL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000111000000110000000000000
  if ((bits & 0xffe0fc00U) != 0xb8e06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXAL_32_MEMOP;
  inst.iclass = InstName::LDUMAXAL;
  return true;
}

static bool TryExtractLDUMAX_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000001000000110000000000000
  if ((bits & 0xffe0fc00U) != 0xb8206000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAX_32_MEMOP;
  inst.iclass = InstName::LDUMAX;
  return true;
}

static bool TryExtractLDUMAXL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000011000000110000000000000
  if ((bits & 0xffe0fc00U) != 0xb8606000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXL_32_MEMOP;
  inst.iclass = InstName::LDUMAXL;
  return true;
}

static bool TryExtractLDUMAXA_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000101000000110000000000000
  if ((bits & 0xffe0fc00U) != 0xf8a06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXA_64_MEMOP;
  inst.iclass = InstName::LDUMAXA;
  return true;
}

static bool TryExtractLDUMAXAL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000111000000110000000000000
  if ((bits & 0xffe0fc00U) != 0xf8e06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXAL_64_MEMOP;
  inst.iclass = InstName::LDUMAXAL;
  return true;
}

static bool TryExtractLDUMAX_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000001000000110000000000000
  if ((bits & 0xffe0fc00U) != 0xf8206000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAX_64_MEMOP;
  inst.iclass = InstName::LDUMAX;
  return true;
}

static bool TryExtractLDUMAXL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000011000000110000000000000
  if ((bits & 0xffe0fc00U) != 0xf8606000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDUMAXL_64_MEMOP;
  inst.iclass = InstName::LDUMAXL;
  return true;
}

static bool TryExtractSQNEG_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01111110001000000111100000000000
  if ((bits & 0xff3ffc00U) != 0x7e207800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQNEG_ASISDMISC_R;
  inst.iclass = InstName::SQNEG;
  return true;
}

static bool TryExtractSQNEG_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000000111100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e207800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQNEG_ASIMDMISC_R;
  inst.iclass = InstName::SQNEG;
  return true;
}

static bool TryExtractUHADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000000010000000000
  if ((bits & 0xbf20fc00U) != 0x2e200400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UHADD_ASIMDSAME_ONLY;
  inst.iclass = InstName::UHADD;
  return true;
}

static bool TryExtractCMP_SUBS_32S_ADDSUB_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000011111
  //   --------------------------------
  //   01110001000000000000000000011111
  if ((bits & 0xff00001fU) != 0x7100001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMP_SUBS_32S_ADDSUB_IMM;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractCMP_SUBS_64S_ADDSUB_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000011111
  //   --------------------------------
  //   11110001000000000000000000011111
  if ((bits & 0xff00001fU) != 0xf100001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMP_SUBS_64S_ADDSUB_IMM;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractCASAH_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000111000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x48e07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASAH_C32_LDSTEXCL;
  inst.iclass = InstName::CASAH;
  return true;
}

static bool TryExtractCASALH_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000111000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x48e0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASALH_C32_LDSTEXCL;
  inst.iclass = InstName::CASALH;
  return true;
}

static bool TryExtractCASH_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000101000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x48a07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASH_C32_LDSTEXCL;
  inst.iclass = InstName::CASH;
  return true;
}

static bool TryExtractCASLH_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001000101000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x48a0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASLH_C32_LDSTEXCL;
  inst.iclass = InstName::CASLH;
  return true;
}

static bool TryExtractADCS_32_ADDSUB_CARRY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111010000000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x3a000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADCS_32_ADDSUB_CARRY;
  inst.iclass = InstName::ADCS;
  return true;
}

static bool TryExtractADCS_64_ADDSUB_CARRY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111010000000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xba000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADCS_64_ADDSUB_CARRY;
  inst.iclass = InstName::ADCS;
  return true;
}

static bool TryExtractFRINTZ_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001011100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee5c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTZ_H_FLOATDP1;
  inst.iclass = InstName::FRINTZ;
  return true;
}

static bool TryExtractFRINTZ_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001011100000000000000
  if ((bits & 0xfffffc00U) != 0x1e25c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTZ_S_FLOATDP1;
  inst.iclass = InstName::FRINTZ;
  return true;
}

static bool TryExtractFRINTZ_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011001011100000000000000
  if ((bits & 0xfffffc00U) != 0x1e65c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTZ_D_FLOATDP1;
  inst.iclass = InstName::FRINTZ;
  return true;
}

static bool TryExtractSCVTF_H32_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110110000100000000000000000
  if ((bits & 0xffff0000U) != 0x1ec20000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_H32_FLOAT2FIX;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_S32_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110000000100000000000000000
  if ((bits & 0xffff0000U) != 0x1e020000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_S32_FLOAT2FIX;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_D32_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110010000100000000000000000
  if ((bits & 0xffff0000U) != 0x1e420000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_D32_FLOAT2FIX;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_H64_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110110000100000000000000000
  if ((bits & 0xffff0000U) != 0x9ec20000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_H64_FLOAT2FIX;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_S64_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110000000100000000000000000
  if ((bits & 0xffff0000U) != 0x9e020000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_S64_FLOAT2FIX;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractSCVTF_D64_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110010000100000000000000000
  if ((bits & 0xffff0000U) != 0x9e420000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::SCVTF_D64_FLOAT2FIX;
  inst.iclass = InstName::SCVTF;
  return true;
}

static bool TryExtractCSETM_CSINV_32_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000111111100000
  //   --------------------------------
  //   01011010100111110000001111100000
  if ((bits & 0xffff0fe0U) != 0x5a9f03e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSETM_CSINV_32_CONDSEL;
  inst.iclass = InstName::CSINV;
  return true;
}

static bool TryExtractCSETM_CSINV_64_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000111111100000
  //   --------------------------------
  //   11011010100111110000001111100000
  if ((bits & 0xffff0fe0U) != 0xda9f03e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSETM_CSINV_64_CONDSEL;
  inst.iclass = InstName::CSINV;
  return true;
}

static bool TryExtractSQDMLAL_ASISDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000001111010000000000
  //   --------------------------------
  //   01011111000000000011000000000000
  if ((bits & 0xff00f400U) != 0x5f003000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMLAL_ASISDELEM_L;
  inst.iclass = InstName::SQDMLAL;
  return true;
}

static bool TryExtractSQDMLAL_ASIMDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00001111000000000011000000000000
  if ((bits & 0xbf00f400U) != 0xf003000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMLAL_ASIMDELEM_L;
  inst.iclass = InstName::SQDMLAL;
  return true;
}

static bool TryExtractSHL_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000000101010000000000
  if ((bits & 0xff80fc00U) != 0x5f005400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SHL_ASISDSHF_R;
  inst.iclass = InstName::SHL;
  return true;
}

static bool TryExtractSHL_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000000101010000000000
  if ((bits & 0xbf80fc00U) != 0xf005400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SHL_ASIMDSHF_R;
  inst.iclass = InstName::SHL;
  return true;
}

static bool TryExtractLD2_ASISDLSE_R2(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100010000001000000000000000
  if ((bits & 0xbffff000U) != 0xc408000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSE_R2;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSEP_I2_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100110111111000000000000000
  if ((bits & 0xbffff000U) != 0xcdf8000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSEP_I2_I;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractLD2_ASISDLSEP_R2_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100110000001000000000000000
  if ((bits & 0xbfe0f000U) != 0xcc08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2_ASISDLSEP_R2_R;
  inst.iclass = InstName::LD2;
  return true;
}

static bool TryExtractSBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {
  if (false && TryExtractSXTH_SBFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractSXTB_SBFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractASR_SBFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractSBFIZ_SBFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractSBFX_SBFM_32M_BITFIELD(inst, bits))
    return true;

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00010011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x13000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SBFM_32M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractSBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {
  if (false && TryExtractSXTH_SBFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractSXTW_SBFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractSXTB_SBFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractASR_SBFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractSBFIZ_SBFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractSBFX_SBFM_64M_BITFIELD(inst, bits))
    return true;

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10010011010000000000000000000000
  if ((bits & 0xffc00000U) != 0x93400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SBFM_64M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractFMAXV_ASIMDALL_ONLY_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110001100001111100000000000
  if ((bits & 0xbffffc00U) != 0xe30f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXV_ASIMDALL_ONLY_H;
  inst.iclass = InstName::FMAXV;
  return true;
}

static bool TryExtractFMAXV_ASIMDALL_ONLY_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110001100001111100000000000
  if ((bits & 0xbfbffc00U) != 0x2e30f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXV_ASIMDALL_ONLY_SD;
  inst.iclass = InstName::FMAXV;
  return true;
}

static bool TryExtractSTADDB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000001000000000000000011111
  if ((bits & 0xffe0fc1fU) != 0x3820001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STADDB_32S_MEMOP;
  inst.iclass = InstName::STADDB;
  return true;
}

static bool TryExtractSTADDLB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000011000000000000000011111
  if ((bits & 0xffe0fc1fU) != 0x3860001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STADDLB_32S_MEMOP;
  inst.iclass = InstName::STADDLB;
  return true;
}

static bool TryExtractSTUMAX_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000001000000110000000011111
  if ((bits & 0xffe0fc1fU) != 0xb820601fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMAX_32S_MEMOP;
  inst.iclass = InstName::STUMAX;
  return true;
}

static bool TryExtractSTUMAXL_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000011000000110000000011111
  if ((bits & 0xffe0fc1fU) != 0xb860601fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMAXL_32S_MEMOP;
  inst.iclass = InstName::STUMAXL;
  return true;
}

static bool TryExtractSTUMAX_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000001000000110000000011111
  if ((bits & 0xffe0fc1fU) != 0xf820601fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMAX_64S_MEMOP;
  inst.iclass = InstName::STUMAX;
  return true;
}

static bool TryExtractSTUMAXL_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000011000000110000000011111
  if ((bits & 0xffe0fc1fU) != 0xf860601fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMAXL_64S_MEMOP;
  inst.iclass = InstName::STUMAXL;
  return true;
}

static bool TryExtractSQDMULH_ASISDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000001111010000000000
  //   --------------------------------
  //   01011111000000001100000000000000
  if ((bits & 0xff00f400U) != 0x5f00c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQDMULH_ASISDELEM_R;
  inst.iclass = InstName::SQDMULH;
  return true;
}

static bool TryExtractSQDMULH_ASIMDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00001111000000001100000000000000
  if ((bits & 0xbf00f400U) != 0xf00c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQDMULH_ASIMDELEM_R;
  inst.iclass = InstName::SQDMULH;
  return true;
}

static bool TryExtractFRSQRTE_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01111110111110011101100000000000
  if ((bits & 0xfffffc00U) != 0x7ef9d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRSQRTE_ASISDMISCFP16_R;
  inst.iclass = InstName::FRSQRTE;
  return true;
}

static bool TryExtractFRSQRTE_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110101000011101100000000000
  if ((bits & 0xffbffc00U) != 0x7ea1d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRSQRTE_ASISDMISC_R;
  inst.iclass = InstName::FRSQRTE;
  return true;
}

static bool TryExtractFRSQRTE_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110111110011101100000000000
  if ((bits & 0xbffffc00U) != 0x2ef9d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FRSQRTE_ASIMDMISCFP16_R;
  inst.iclass = InstName::FRSQRTE;
  return true;
}

static bool TryExtractFRSQRTE_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101000011101100000000000
  if ((bits & 0xbfbffc00U) != 0x2ea1d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRSQRTE_ASIMDMISC_R;
  inst.iclass = InstName::FRSQRTE;
  return true;
}

static bool TryExtractADD_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000001000010000000000
  if ((bits & 0xff20fc00U) != 0x5e208400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ADD_ASISDSAME_ONLY;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001000010000000000
  if ((bits & 0xbf20fc00U) != 0xe208400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ADD_ASIMDSAME_ONLY;
  inst.iclass = InstName::ADD;
  return true;
}

static bool TryExtractSABDL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000111000000000000
  if ((bits & 0xbf20fc00U) != 0xe207000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t op : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SABDL_ASIMDDIFF_L;
  inst.iclass = InstName::SABDL;
  return true;
}

static bool TryExtractROR_RORV_32_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000010110000000000
  if ((bits & 0xffe0fc00U) != 0x1ac02c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ROR_RORV_32_DP_2SRC;
  inst.iclass = InstName::RORV;
  return true;
}

static bool TryExtractROR_RORV_64_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000010110000000000
  if ((bits & 0xffe0fc00U) != 0x9ac02c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ROR_RORV_64_DP_2SRC;
  inst.iclass = InstName::RORV;
  return true;
}

static bool TryExtractUCVTF_H32_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000110000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee30000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_H32_FLOAT2INT;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_S32_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000110000000000000000
  if ((bits & 0xfffffc00U) != 0x1e230000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_S32_FLOAT2INT;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_D32_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000110000000000000000
  if ((bits & 0xfffffc00U) != 0x1e630000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_D32_FLOAT2INT;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_H64_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111000110000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee30000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_H64_FLOAT2INT;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_S64_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001000110000000000000000
  if ((bits & 0xfffffc00U) != 0x9e230000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_S64_FLOAT2INT;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_D64_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011000110000000000000000
  if ((bits & 0xfffffc00U) != 0x9e630000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_D64_FLOAT2INT;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_H32_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110110000110000000000000000
  if ((bits & 0xffff0000U) != 0x1ec30000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_H32_FLOAT2FIX;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_S32_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110000000110000000000000000
  if ((bits & 0xffff0000U) != 0x1e030000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_S32_FLOAT2FIX;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_D32_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   00011110010000110000000000000000
  if ((bits & 0xffff0000U) != 0x1e430000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_D32_FLOAT2FIX;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_H64_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110110000110000000000000000
  if ((bits & 0xffff0000U) != 0x9ec30000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_H64_FLOAT2FIX;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_S64_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110000000110000000000000000
  if ((bits & 0xffff0000U) != 0x9e030000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_S64_FLOAT2FIX;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractUCVTF_D64_FLOAT2FIX(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111110000000000000000
  //   --------------------------------
  //   10011110010000110000000000000000
  if ((bits & 0xffff0000U) != 0x9e430000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t scale : 6;
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 0
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.scale = static_cast<uint8_t>(enc.scale);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::UCVTF_D64_FLOAT2FIX;
  inst.iclass = InstName::UCVTF;
  return true;
}

static bool TryExtractMOVI_ASIMDIMM_N_B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001111110000000000
  //   --------------------------------
  //   00001111000000001110010000000000
  if ((bits & 0xbff8fc00U) != 0xf00e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOVI_ASIMDIMM_N_B;
  inst.iclass = InstName::MOVI;
  return true;
}

static bool TryExtractMOVI_ASIMDIMM_L_HL(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001101110000000000
  //   --------------------------------
  //   00001111000000001000010000000000
  if ((bits & 0xbff8dc00U) != 0xf008400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOVI_ASIMDIMM_L_HL;
  inst.iclass = InstName::MOVI;
  return true;
}

static bool TryExtractMOVI_ASIMDIMM_L_SL(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001001110000000000
  //   --------------------------------
  //   00001111000000000000010000000000
  if ((bits & 0xbff89c00U) != 0xf000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOVI_ASIMDIMM_L_SL;
  inst.iclass = InstName::MOVI;
  return true;
}

static bool TryExtractMOVI_ASIMDIMM_M_SM(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001110110000000000
  //   --------------------------------
  //   00001111000000001100010000000000
  if ((bits & 0xbff8ec00U) != 0xf00c400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOVI_ASIMDIMM_M_SM;
  inst.iclass = InstName::MOVI;
  return true;
}

static bool TryExtractMOVI_ASIMDIMM_D_DS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111110001111110000000000
  //   --------------------------------
  //   00101111000000001110010000000000
  if ((bits & 0xfff8fc00U) != 0x2f00e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOVI_ASIMDIMM_D_DS;
  inst.iclass = InstName::MOVI;
  return true;
}

static bool TryExtractMOVI_ASIMDIMM_D2_D(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111110001111110000000000
  //   --------------------------------
  //   01101111000000001110010000000000
  if ((bits & 0xfff8fc00U) != 0x6f00e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOVI_ASIMDIMM_D2_D;
  inst.iclass = InstName::MOVI;
  return true;
}

static bool TryExtractREV16_32_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011010110000000000010000000000
  if ((bits & 0xfffffc00U) != 0x5ac00400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opc : 2;
      uint32_t opcode : 4;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.iform = InstForm::REV16_32_DP_1SRC;
  inst.iclass = InstName::REV16;
  return true;
}

static bool TryExtractREV16_64_DP_1SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11011010110000000000010000000000
  if ((bits & 0xfffffc00U) != 0xdac00400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opc : 2;
      uint32_t opcode : 4;
      uint32_t opcode2 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 1
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.iform = InstForm::REV16_64_DP_1SRC;
  inst.iclass = InstName::REV16;
  return true;
}

static bool TryExtractSQRDMLAH_ASISDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000001111010000000000
  //   --------------------------------
  //   01111111000000001101000000000000
  if ((bits & 0xff00f400U) != 0x7f00d000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t S : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMLAH_ASISDELEM_R;
  inst.iclass = InstName::SQRDMLAH;
  return true;
}

static bool TryExtractSQRDMLAH_ASIMDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00101111000000001101000000000000
  if ((bits & 0xbf00f400U) != 0x2f00d000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t S : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMLAH_ASIMDELEM_R;
  inst.iclass = InstName::SQRDMLAH;
  return true;
}

static bool TryExtractFMAXP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110001100001111100000000000
  if ((bits & 0xfffffc00U) != 0x5e30f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXP_ASISDPAIR_ONLY_H;
  inst.iclass = InstName::FMAXP;
  return true;
}

static bool TryExtractFMAXP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110001100001111100000000000
  if ((bits & 0xffbffc00U) != 0x7e30f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXP_ASISDPAIR_ONLY_SD;
  inst.iclass = InstName::FMAXP;
  return true;
}

static bool TryExtractBIF_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110111000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0x2ee01c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opc2 = static_cast<uint8_t>(enc.opc2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::BIF_ASIMDSAME_ONLY;
  inst.iclass = InstName::BIF;
  return true;
}

static bool TryExtractFCMLE_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01111110111110001101100000000000
  if ((bits & 0xfffffc00U) != 0x7ef8d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMLE_ASISDMISCFP16_FZ;
  inst.iclass = InstName::FCMLE;
  return true;
}

static bool TryExtractFCMLE_ASISDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110101000001101100000000000
  if ((bits & 0xffbffc00U) != 0x7ea0d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMLE_ASISDMISC_FZ;
  inst.iclass = InstName::FCMLE;
  return true;
}

static bool TryExtractFCMLE_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110111110001101100000000000
  if ((bits & 0xbffffc00U) != 0x2ef8d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMLE_ASIMDMISCFP16_FZ;
  inst.iclass = InstName::FCMLE;
  return true;
}

static bool TryExtractFCMLE_ASIMDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101000001101100000000000
  if ((bits & 0xbfbffc00U) != 0x2ea0d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMLE_ASIMDMISC_FZ;
  inst.iclass = InstName::FCMLE;
  return true;
}

static bool TryExtractDRPS_64E_BRANCH_REG(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010110101111110000001111100000
  if ((bits & 0xffffffffU) != 0xd6bf03e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t op4 : 5;
      uint32_t Rt : 5;
      uint32_t op3 : 6;
      uint32_t op2 : 5;
      uint32_t opc : 4;
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.op4 = static_cast<uint8_t>(enc.op4);
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.op3 = static_cast<uint8_t>(enc.op3);
  inst.iform = InstForm::DRPS_64E_BRANCH_REG;
  inst.iclass = InstName::DRPS;
  return true;
}

static bool TryExtractSLI_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000000101010000000000
  if ((bits & 0xff80fc00U) != 0x7f005400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SLI_ASISDSHF_R;
  inst.iclass = InstName::SLI;
  return true;
}

static bool TryExtractSLI_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000000101010000000000
  if ((bits & 0xbf80fc00U) != 0x2f005400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SLI_ASIMDSHF_R;
  inst.iclass = InstName::SLI;
  return true;
}

static bool TryExtractLDAXRH_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001000010111111111110000000000
  if ((bits & 0xfffffc00U) != 0x485ffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDAXRH_LR32_LDSTEXCL;
  inst.iclass = InstName::LDAXRH;
  return true;
}

static bool TryExtractBFI_BFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00110011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x33000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  if (!(inst.Rn != 0x1f))
    return false;
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::BFI_BFM_32M_BITFIELD;
  inst.iclass = InstName::BFM;
  return true;
}

static bool TryExtractBFI_BFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10110011010000000000000000000000
  if ((bits & 0xffc00000U) != 0xb3400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  if (!(inst.Rn != 0x1f))
    return false;
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::BFI_BFM_64M_BITFIELD;
  inst.iclass = InstName::BFM;
  return true;
}

static bool TryExtractLDADDAB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000101000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x38a00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDAB_32_MEMOP;
  inst.iclass = InstName::LDADDAB;
  return true;
}

static bool TryExtractLDADDALB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000111000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x38e00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDALB_32_MEMOP;
  inst.iclass = InstName::LDADDALB;
  return true;
}

static bool TryExtractLDADDB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000001000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x38200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDB_32_MEMOP;
  inst.iclass = InstName::LDADDB;
  return true;
}

static bool TryExtractLDADDLB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000011000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x38600000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDADDLB_32_MEMOP;
  inst.iclass = InstName::LDADDLB;
  return true;
}

static bool TryExtractLDRH_32_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000010000000000010000000000
  if ((bits & 0xffe00c00U) != 0x78400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRH_32_LDST_IMMPOST;
  inst.iclass = InstName::LDRH;
  return true;
}

static bool TryExtractLDRH_32_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000010000000000110000000000
  if ((bits & 0xffe00c00U) != 0x78400c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRH_32_LDST_IMMPRE;
  inst.iclass = InstName::LDRH;
  return true;
}

static bool TryExtractLDRH_32_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01111001010000000000000000000000
  if ((bits & 0xffc00000U) != 0x79400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRH_32_LDST_POS;
  inst.iclass = InstName::LDRH;
  return true;
}

static bool TryExtractSXTB_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00010011000000000001110000000000
  if ((bits & 0xfffffc00U) != 0x13001c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SXTB_SBFM_32M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractSXTB_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10010011010000000001110000000000
  if ((bits & 0xfffffc00U) != 0x93401c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SXTB_SBFM_64M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractERET_64E_BRANCH_REG(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010110100111110000001111100000
  if ((bits & 0xffffffffU) != 0xd69f03e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t op4 : 5;
      uint32_t Rt : 5;
      uint32_t op3 : 6;
      uint32_t op2 : 5;
      uint32_t opc : 4;
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.op4 = static_cast<uint8_t>(enc.op4);
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.op3 = static_cast<uint8_t>(enc.op3);
  inst.iform = InstForm::ERET_64E_BRANCH_REG;
  inst.iclass = InstName::ERET;
  return true;
}

static bool TryExtractSTUMIN_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000001000000111000000011111
  if ((bits & 0xffe0fc1fU) != 0xb820701fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMIN_32S_MEMOP;
  inst.iclass = InstName::STUMIN;
  return true;
}

static bool TryExtractSTUMINL_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000011000000111000000011111
  if ((bits & 0xffe0fc1fU) != 0xb860701fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMINL_32S_MEMOP;
  inst.iclass = InstName::STUMINL;
  return true;
}

static bool TryExtractSTUMIN_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000001000000111000000011111
  if ((bits & 0xffe0fc1fU) != 0xf820701fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMIN_64S_MEMOP;
  inst.iclass = InstName::STUMIN;
  return true;
}

static bool TryExtractSTUMINL_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000011000000111000000011111
  if ((bits & 0xffe0fc1fU) != 0xf860701fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUMINL_64S_MEMOP;
  inst.iclass = InstName::STUMINL;
  return true;
}

static bool TryExtractSHA1SU1_VV_CRYPTOSHA2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110001010000001100000000000
  if ((bits & 0xfffffc00U) != 0x5e281800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHA1SU1_VV_CRYPTOSHA2;
  inst.iclass = InstName::SHA1SU1;
  return true;
}

static bool TryExtractLD1_ASISDLSE_R1_1V(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100010000000111000000000000
  if ((bits & 0xbffff000U) != 0xc407000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSE_R1_1V;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSE_R2_2V(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100010000001010000000000000
  if ((bits & 0xbffff000U) != 0xc40a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSE_R2_2V;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSE_R3_3V(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100010000000110000000000000
  if ((bits & 0xbffff000U) != 0xc406000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSE_R3_3V;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSE_R4_4V(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100010000000010000000000000
  if ((bits & 0xbffff000U) != 0xc402000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSE_R4_4V;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSEP_I1_I1(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100110111110111000000000000
  if ((bits & 0xbffff000U) != 0xcdf7000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSEP_I1_I1;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSEP_R1_R1(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100110000000111000000000000
  if ((bits & 0xbfe0f000U) != 0xcc07000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSEP_R1_R1;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSEP_I2_I2(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100110111111010000000000000
  if ((bits & 0xbffff000U) != 0xcdfa000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSEP_I2_I2;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSEP_R2_R2(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100110000001010000000000000
  if ((bits & 0xbfe0f000U) != 0xcc0a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSEP_R2_R2;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSEP_I3_I3(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100110111110110000000000000
  if ((bits & 0xbffff000U) != 0xcdf6000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSEP_I3_I3;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSEP_R3_R3(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100110000000110000000000000
  if ((bits & 0xbfe0f000U) != 0xcc06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSEP_R3_R3;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSEP_I4_I4(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100110111110010000000000000
  if ((bits & 0xbffff000U) != 0xcdf2000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSEP_I4_I4;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractLD1_ASISDLSEP_R4_R4(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100110000000010000000000000
  if ((bits & 0xbfe0f000U) != 0xcc02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1_ASISDLSEP_R4_R4;
  inst.iclass = InstName::LD1;
  return true;
}

static bool TryExtractSHA1H_SS_CRYPTOSHA2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110001010000000100000000000
  if ((bits & 0xfffffc00U) != 0x5e280800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHA1H_SS_CRYPTOSHA2;
  inst.iclass = InstName::SHA1H;
  return true;
}

static bool TryExtractFRINTM_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110011110011001100000000000
  if ((bits & 0xbffffc00U) != 0xe799800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTM_ASIMDMISCFP16_R;
  inst.iclass = InstName::FRINTM;
  return true;
}

static bool TryExtractFRINTM_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110001000011001100000000000
  if ((bits & 0xbfbffc00U) != 0xe219800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTM_ASIMDMISC_R;
  inst.iclass = InstName::FRINTM;
  return true;
}

static bool TryExtractSTURH_32_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000000000000000000000000000
  if ((bits & 0xffe00c00U) != 0x78000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STURH_32_LDST_UNSCALED;
  inst.iclass = InstName::STURH;
  return true;
}

static bool TryExtractSQSHLU_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000000110010000000000
  if ((bits & 0xff80fc00U) != 0x7f006400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQSHLU_ASISDSHF_R;
  inst.iclass = InstName::SQSHLU;
  return true;
}

static bool TryExtractSQSHLU_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000000110010000000000
  if ((bits & 0xbf80fc00U) != 0x2f006400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQSHLU_ASIMDSHF_R;
  inst.iclass = InstName::SQSHLU;
  return true;
}

static bool TryExtractUMULL_ASIMDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00101111000000001010000000000000
  if ((bits & 0xbf00f400U) != 0x2f00a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMULL_ASIMDELEM_L;
  inst.iclass = InstName::UMULL;
  return true;
}

static bool TryExtractNOT_ASIMDMISC_R(InstData &inst, uint32_t bits) {
  if (false && TryExtractMVN_NOT_ASIMDMISC_R(inst, bits))
    return true;

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110001000000101100000000000
  if ((bits & 0xbffffc00U) != 0x2e205800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::NOT_ASIMDMISC_R;
  inst.iclass = InstName::NOT;
  return true;
}

static bool TryExtractLDR_B_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100010000000000010000000000
  if ((bits & 0xffe00c00U) != 0x3c400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_B_LDST_IMMPOST;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_H_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111100010000000000010000000000
  if ((bits & 0xffe00c00U) != 0x7c400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_H_LDST_IMMPOST;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_S_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111100010000000000010000000000
  if ((bits & 0xffe00c00U) != 0xbc400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_S_LDST_IMMPOST;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_D_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111100010000000000010000000000
  if ((bits & 0xffe00c00U) != 0xfc400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_D_LDST_IMMPOST;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_Q_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100110000000000010000000000
  if ((bits & 0xffe00c00U) != 0x3cc00400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_Q_LDST_IMMPOST;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_B_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100010000000000110000000000
  if ((bits & 0xffe00c00U) != 0x3c400c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_B_LDST_IMMPRE;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_H_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111100010000000000110000000000
  if ((bits & 0xffe00c00U) != 0x7c400c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_H_LDST_IMMPRE;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_S_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111100010000000000110000000000
  if ((bits & 0xffe00c00U) != 0xbc400c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_S_LDST_IMMPRE;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_D_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111100010000000000110000000000
  if ((bits & 0xffe00c00U) != 0xfc400c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_D_LDST_IMMPRE;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_Q_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100110000000000110000000000
  if ((bits & 0xffe00c00U) != 0x3cc00c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_Q_LDST_IMMPRE;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_B_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00111101010000000000000000000000
  if ((bits & 0xffc00000U) != 0x3d400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_B_LDST_POS;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_H_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01111101010000000000000000000000
  if ((bits & 0xffc00000U) != 0x7d400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_H_LDST_POS;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_S_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10111101010000000000000000000000
  if ((bits & 0xffc00000U) != 0xbd400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_S_LDST_POS;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_D_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   11111101010000000000000000000000
  if ((bits & 0xffc00000U) != 0xfd400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_D_LDST_POS;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_Q_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00111101110000000000000000000000
  if ((bits & 0xffc00000U) != 0x3dc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_Q_LDST_POS;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractSWPAB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000101000001000000000000000
  if ((bits & 0xffe0fc00U) != 0x38a08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPAB_32_MEMOP;
  inst.iclass = InstName::SWPAB;
  return true;
}

static bool TryExtractSWPALB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000111000001000000000000000
  if ((bits & 0xffe0fc00U) != 0x38e08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPALB_32_MEMOP;
  inst.iclass = InstName::SWPALB;
  return true;
}

static bool TryExtractSWPB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000001000001000000000000000
  if ((bits & 0xffe0fc00U) != 0x38208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPB_32_MEMOP;
  inst.iclass = InstName::SWPB;
  return true;
}

static bool TryExtractSWPLB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000011000001000000000000000
  if ((bits & 0xffe0fc00U) != 0x38608000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SWPLB_32_MEMOP;
  inst.iclass = InstName::SWPLB;
  return true;
}

static bool TryExtractFMOV_ASIMDIMM_H_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001111110000000000
  //   --------------------------------
  //   00001111000000001111110000000000
  if ((bits & 0xbff8fc00U) != 0xf00fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMOV_ASIMDIMM_H_H;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_ASIMDIMM_S_S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111110001111110000000000
  //   --------------------------------
  //   00001111000000001111010000000000
  if ((bits & 0xbff8fc00U) != 0xf00f400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMOV_ASIMDIMM_S_S;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_ASIMDIMM_D2_D(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111110001111110000000000
  //   --------------------------------
  //   01101111000000001111010000000000
  if ((bits & 0xfff8fc00U) != 0x6f00f400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t h : 1;
      uint32_t g : 1;
      uint32_t f : 1;
      uint32_t e : 1;
      uint32_t d : 1;
      uint32_t _10 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t cmode : 4;
      uint32_t c : 1;
      uint32_t b : 1;
      uint32_t a : 1;
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.c = static_cast<uint8_t>(enc.c);
  inst.b = static_cast<uint8_t>(enc.b);
  inst.e = static_cast<uint8_t>(enc.e);
  inst.d = static_cast<uint8_t>(enc.d);
  inst.g = static_cast<uint8_t>(enc.g);
  inst.f = static_cast<uint8_t>(enc.f);
  inst.h = static_cast<uint8_t>(enc.h);
  inst.cmode = static_cast<uint8_t>(enc.cmode);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMOV_ASIMDIMM_D2_D;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMIN_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110110000000011010000000000
  if ((bits & 0xbfe0fc00U) != 0xec03400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMIN_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMIN;
  return true;
}

static bool TryExtractFMIN_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110101000001111010000000000
  if ((bits & 0xbfa0fc00U) != 0xea0f400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMIN_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMIN;
  return true;
}

static bool TryExtractSQXTUN_ASISDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01111110001000010010100000000000
  if ((bits & 0xff3ffc00U) != 0x7e212800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQXTUN_ASISDMISC_N;
  inst.iclass = InstName::SQXTUN;
  return true;
}

static bool TryExtractSQXTUN_ASIMDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000010010100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e212800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQXTUN_ASIMDMISC_N;
  inst.iclass = InstName::SQXTUN;
  return true;
}

static bool TryExtractLDEORAB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000101000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x38a02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORAB_32_MEMOP;
  inst.iclass = InstName::LDEORAB;
  return true;
}

static bool TryExtractLDEORALB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000111000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x38e02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORALB_32_MEMOP;
  inst.iclass = InstName::LDEORALB;
  return true;
}

static bool TryExtractLDEORB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000001000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x38202000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORB_32_MEMOP;
  inst.iclass = InstName::LDEORB;
  return true;
}

static bool TryExtractLDEORLB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000011000000010000000000000
  if ((bits & 0xffe0fc00U) != 0x38602000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDEORLB_32_MEMOP;
  inst.iclass = InstName::LDEORLB;
  return true;
}

static bool TryExtractFCVTPS_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110111110011010100000000000
  if ((bits & 0xfffffc00U) != 0x5ef9a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTPS_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractFCVTPS_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110101000011010100000000000
  if ((bits & 0xffbffc00U) != 0x5ea1a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTPS_ASISDMISC_R;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractFCVTPS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110111110011010100000000000
  if ((bits & 0xbffffc00U) != 0xef9a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTPS_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractFCVTPS_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000011010100000000000
  if ((bits & 0xbfbffc00U) != 0xea1a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTPS_ASIMDMISC_R;
  inst.iclass = InstName::FCVTPS;
  return true;
}

static bool TryExtractLDR_S_LOADLIT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   00011100000000000000000000000000
  if ((bits & 0xff000000U) != 0x1c000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.iform = InstForm::LDR_S_LOADLIT;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_D_LOADLIT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   01011100000000000000000000000000
  if ((bits & 0xff000000U) != 0x5c000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.iform = InstForm::LDR_D_LOADLIT;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_Q_LOADLIT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   10011100000000000000000000000000
  if ((bits & 0xff000000U) != 0x9c000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.iform = InstForm::LDR_Q_LOADLIT;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractFRINTP_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110111110011000100000000000
  if ((bits & 0xbffffc00U) != 0xef98800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTP_ASIMDMISCFP16_R;
  inst.iclass = InstName::FRINTP;
  return true;
}

static bool TryExtractFRINTP_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000011000100000000000
  if ((bits & 0xbfbffc00U) != 0xea18800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTP_ASIMDMISC_R;
  inst.iclass = InstName::FRINTP;
  return true;
}

static bool TryExtractLDLARB_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00001000110111110111110000000000
  if ((bits & 0xfffffc00U) != 0x8df7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDLARB_LR32_LDSTEXCL;
  inst.iclass = InstName::LDLARB;
  return true;
}

static bool TryExtractFNEG_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110111110001111100000000000
  if ((bits & 0xbffffc00U) != 0x2ef8f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FNEG_ASIMDMISCFP16_R;
  inst.iclass = InstName::FNEG;
  return true;
}

static bool TryExtractFNEG_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101000001111100000000000
  if ((bits & 0xbfbffc00U) != 0x2ea0f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FNEG_ASIMDMISC_R;
  inst.iclass = InstName::FNEG;
  return true;
}

static bool TryExtractADDHN_ASIMDDIFF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000100000000000000
  if ((bits & 0xbf20fc00U) != 0xe204000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ADDHN_ASIMDDIFF_N;
  inst.iclass = InstName::ADDHN;
  return true;
}

static bool TryExtractLDNP_32_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101000010000000000000000000000
  if ((bits & 0xffc00000U) != 0x28400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDNP_32_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::LDNP;
  return true;
}

static bool TryExtractLDNP_64_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101000010000000000000000000000
  if ((bits & 0xffc00000U) != 0xa8400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDNP_64_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::LDNP;
  return true;
}

static bool TryExtractSQRSHRN_ASISDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000001001110000000000
  if ((bits & 0xff80fc00U) != 0x5f009c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQRSHRN_ASISDSHF_N;
  inst.iclass = InstName::SQRSHRN;
  return true;
}

static bool TryExtractSQRSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000001001110000000000
  if ((bits & 0xbf80fc00U) != 0xf009c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQRSHRN_ASIMDSHF_N;
  inst.iclass = InstName::SQRSHRN;
  return true;
}

static bool TryExtractCMGT_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000000011010000000000
  if ((bits & 0xff20fc00U) != 0x5e203400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t eq : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.eq = static_cast<uint8_t>(enc.eq);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMGT_ASISDSAME_ONLY;
  inst.iclass = InstName::CMGT;
  return true;
}

static bool TryExtractCMGT_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000011010000000000
  if ((bits & 0xbf20fc00U) != 0xe203400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t eq : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.eq = static_cast<uint8_t>(enc.eq);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMGT_ASIMDSAME_ONLY;
  inst.iclass = InstName::CMGT;
  return true;
}

static bool TryExtractST4_ASISDLSE_R4(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100000000000000000000000000
  if ((bits & 0xbffff000U) != 0xc000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSE_R4;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSEP_I4_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100100111110000000000000000
  if ((bits & 0xbffff000U) != 0xc9f0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSEP_I4_I;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSEP_R4_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100100000000000000000000000
  if ((bits & 0xbfe0f000U) != 0xc800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSEP_R4_R;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractASRV_32_DP_2SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractASR_ASRV_32_DP_2SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000010100000000000
  if ((bits & 0xffe0fc00U) != 0x1ac02800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ASRV_32_DP_2SRC;
  inst.iclass = InstName::ASRV;
  return true;
}

static bool TryExtractASRV_64_DP_2SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractASR_ASRV_64_DP_2SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000010100000000000
  if ((bits & 0xffe0fc00U) != 0x9ac02800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ASRV_64_DP_2SRC;
  inst.iclass = InstName::ASRV;
  return true;
}

static bool TryExtractUHSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000010010000000000
  if ((bits & 0xbf20fc00U) != 0x2e202400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UHSUB_ASIMDSAME_ONLY;
  inst.iclass = InstName::UHSUB;
  return true;
}

static bool TryExtractCMHS_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000000011110000000000
  if ((bits & 0xff20fc00U) != 0x7e203c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t eq : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.eq = static_cast<uint8_t>(enc.eq);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMHS_ASISDSAME_ONLY;
  inst.iclass = InstName::CMHS;
  return true;
}

static bool TryExtractCMHS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000011110000000000
  if ((bits & 0xbf20fc00U) != 0x2e203c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t eq : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.eq = static_cast<uint8_t>(enc.eq);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMHS_ASIMDSAME_ONLY;
  inst.iclass = InstName::CMHS;
  return true;
}

static bool TryExtractMOVZ_32_MOVEWIDE(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_MOVZ_32_MOVEWIDE(inst, bits))
    return true;

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   01010010100000000000000000000000
  if ((bits & 0xff800000U) != 0x52800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOVZ_32_MOVEWIDE;
  inst.iclass = InstName::MOVZ;
  return true;
}

static bool TryExtractMOVZ_64_MOVEWIDE(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_MOVZ_64_MOVEWIDE(inst, bits))
    return true;

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   11010010100000000000000000000000
  if ((bits & 0xff800000U) != 0xd2800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOVZ_64_MOVEWIDE;
  inst.iclass = InstName::MOVZ;
  return true;
}

static bool TryExtractSADDW_ASIMDDIFF_W(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000001000000000000
  if ((bits & 0xbf20fc00U) != 0xe201000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SADDW_ASIMDDIFF_W;
  inst.iclass = InstName::SADDW;
  return true;
}

static bool TryExtractSADDLP_ASIMDMISC_P(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000000010100000000000
  if ((bits & 0xbf3ffc00U) != 0xe202800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SADDLP_ASIMDMISC_P;
  inst.iclass = InstName::SADDLP;
  return true;
}

static bool TryExtractUMNEGL_UMSUBL_64WA_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011011101000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x9ba0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::UMNEGL_UMSUBL_64WA_DP_3SRC;
  inst.iclass = InstName::UMSUBL;
  return true;
}

static bool TryExtractST2_ASISDLSE_R2(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100000000001000000000000000
  if ((bits & 0xbffff000U) != 0xc008000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSE_R2;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSEP_I2_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100100111111000000000000000
  if ((bits & 0xbffff000U) != 0xc9f8000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSEP_I2_I;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractST2_ASISDLSEP_R2_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100100000001000000000000000
  if ((bits & 0xbfe0f000U) != 0xc808000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST2_ASISDLSEP_R2_R;
  inst.iclass = InstName::ST2;
  return true;
}

static bool TryExtractUXTL_USHLL_ASIMDSHF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100001111111110000000000
  //   --------------------------------
  //   00101111000000001010010000000000
  if ((bits & 0xbf87fc00U) != 0x2f00a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::UXTL_USHLL_ASIMDSHF_L;
  inst.iclass = InstName::USHLL;
  return true;
}

static bool TryExtractLDSMINA_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000101000000101000000000000
  if ((bits & 0xffe0fc00U) != 0xb8a05000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINA_32_MEMOP;
  inst.iclass = InstName::LDSMINA;
  return true;
}

static bool TryExtractLDSMINAL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000111000000101000000000000
  if ((bits & 0xffe0fc00U) != 0xb8e05000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINAL_32_MEMOP;
  inst.iclass = InstName::LDSMINAL;
  return true;
}

static bool TryExtractLDSMIN_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000001000000101000000000000
  if ((bits & 0xffe0fc00U) != 0xb8205000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMIN_32_MEMOP;
  inst.iclass = InstName::LDSMIN;
  return true;
}

static bool TryExtractLDSMINL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000011000000101000000000000
  if ((bits & 0xffe0fc00U) != 0xb8605000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINL_32_MEMOP;
  inst.iclass = InstName::LDSMINL;
  return true;
}

static bool TryExtractLDSMINA_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000101000000101000000000000
  if ((bits & 0xffe0fc00U) != 0xf8a05000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINA_64_MEMOP;
  inst.iclass = InstName::LDSMINA;
  return true;
}

static bool TryExtractLDSMINAL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000111000000101000000000000
  if ((bits & 0xffe0fc00U) != 0xf8e05000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINAL_64_MEMOP;
  inst.iclass = InstName::LDSMINAL;
  return true;
}

static bool TryExtractLDSMIN_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000001000000101000000000000
  if ((bits & 0xffe0fc00U) != 0xf8205000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMIN_64_MEMOP;
  inst.iclass = InstName::LDSMIN;
  return true;
}

static bool TryExtractLDSMINL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000011000000101000000000000
  if ((bits & 0xffe0fc00U) != 0xf8605000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINL_64_MEMOP;
  inst.iclass = InstName::LDSMINL;
  return true;
}

static bool TryExtractPSB_HC_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010101000000110010001000111111
  if ((bits & 0xffffffffU) != 0xd503223fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::PSB_HC_SYSTEM;
  inst.iclass = InstName::PSB;
  return true;
}

static bool TryExtractFMUL_ASISDELEM_RH_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000001111010000000000
  //   --------------------------------
  //   01011111000000001001000000000000
  if ((bits & 0xffc0f400U) != 0x5f009000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FMUL_ASISDELEM_RH_H;
  inst.iclass = InstName::FMUL;
  return true;
}

static bool TryExtractFMUL_ASISDELEM_R_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111010000000000
  //   --------------------------------
  //   01011111100000001001000000000000
  if ((bits & 0xff80f400U) != 0x5f809000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMUL_ASISDELEM_R_SD;
  inst.iclass = InstName::FMUL;
  return true;
}

static bool TryExtractFMUL_ASIMDELEM_RH_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111110000001111010000000000
  //   --------------------------------
  //   00001111000000001001000000000000
  if ((bits & 0xbfc0f400U) != 0xf009000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FMUL_ASIMDELEM_RH_H;
  inst.iclass = InstName::FMUL;
  return true;
}

static bool TryExtractFMUL_ASIMDELEM_R_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111010000000000
  //   --------------------------------
  //   00001111100000001001000000000000
  if ((bits & 0xbf80f400U) != 0xf809000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMUL_ASIMDELEM_R_SD;
  inst.iclass = InstName::FMUL;
  return true;
}

static bool TryExtractSHADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000000010000000000
  if ((bits & 0xbf20fc00U) != 0xe200400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHADD_ASIMDSAME_ONLY;
  inst.iclass = InstName::SHADD;
  return true;
}

static bool TryExtractFMINP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110101100001111100000000000
  if ((bits & 0xfffffc00U) != 0x5eb0f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINP_ASISDPAIR_ONLY_H;
  inst.iclass = InstName::FMINP;
  return true;
}

static bool TryExtractFMINP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110101100001111100000000000
  if ((bits & 0xffbffc00U) != 0x7eb0f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINP_ASISDPAIR_ONLY_SD;
  inst.iclass = InstName::FMINP;
  return true;
}

static bool TryExtractREV64_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000000000100000000000
  if ((bits & 0xbf3ffc00U) != 0xe200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o0 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::REV64_ASIMDMISC_R;
  inst.iclass = InstName::REV64;
  return true;
}

static bool TryExtractSSUBW_ASIMDDIFF_W(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000011000000000000
  if ((bits & 0xbf20fc00U) != 0xe203000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SSUBW_ASIMDDIFF_W;
  inst.iclass = InstName::SSUBW;
  return true;
}

static bool TryExtractMOV_UMOV_ASIMDINS_W_W(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111001111111110000000000
  //   --------------------------------
  //   00001110000001000011110000000000
  if ((bits & 0xffe7fc00U) != 0xe043c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOV_UMOV_ASIMDINS_W_W;
  inst.iclass = InstName::UMOV;
  return true;
}

static bool TryExtractMOV_UMOV_ASIMDINS_X_X(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111011111111110000000000
  //   --------------------------------
  //   01001110000010000011110000000000
  if ((bits & 0xffeffc00U) != 0x4e083c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOV_UMOV_ASIMDINS_X_X;
  inst.iclass = InstName::UMOV;
  return true;
}

static bool TryExtractMLS_ASIMDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00101111000000000100000000000000
  if ((bits & 0xbf00f400U) != 0x2f004000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::MLS_ASIMDELEM_R;
  inst.iclass = InstName::MLS;
  return true;
}

static bool TryExtractSQDMLSL_ASISDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000001111010000000000
  //   --------------------------------
  //   01011111000000000111000000000000
  if ((bits & 0xff00f400U) != 0x5f007000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMLSL_ASISDELEM_L;
  inst.iclass = InstName::SQDMLSL;
  return true;
}

static bool TryExtractSQDMLSL_ASIMDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00001111000000000111000000000000
  if ((bits & 0xbf00f400U) != 0xf007000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMLSL_ASIMDELEM_L;
  inst.iclass = InstName::SQDMLSL;
  return true;
}

static bool TryExtractCINC_CSINC_32_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00011010100000000000010000000000
  if ((bits & 0xffe00c00U) != 0x1a800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  if (!(inst.Rm != 0x1f))
    return false;
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  if (!(inst.Rn != 0x1f))
    return false;
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CINC_CSINC_32_CONDSEL;
  inst.iclass = InstName::CSINC;
  return true;
}

static bool TryExtractCINC_CSINC_64_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10011010100000000000010000000000
  if ((bits & 0xffe00c00U) != 0x9a800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  if (!(inst.Rm != 0x1f))
    return false;
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  if (!(inst.Rn != 0x1f))
    return false;
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CINC_CSINC_64_CONDSEL;
  inst.iclass = InstName::CSINC;
  return true;
}

static bool TryExtractCSINV_32_CONDSEL(InstData &inst, uint32_t bits) {
  if (false && TryExtractCSETM_CSINV_32_CONDSEL(inst, bits))
    return true;
  if (false && TryExtractCINV_CSINV_32_CONDSEL(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01011010100000000000000000000000
  if ((bits & 0xffe00c00U) != 0x5a800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSINV_32_CONDSEL;
  inst.iclass = InstName::CSINV;
  return true;
}

static bool TryExtractCSINV_64_CONDSEL(InstData &inst, uint32_t bits) {
  if (false && TryExtractCSETM_CSINV_64_CONDSEL(inst, bits))
    return true;
  if (false && TryExtractCINV_CSINV_64_CONDSEL(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11011010100000000000000000000000
  if ((bits & 0xffe00c00U) != 0xda800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSINV_64_CONDSEL;
  inst.iclass = InstName::CSINV;
  return true;
}

static bool TryExtractFCVTZU_ASISDSHF_C(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000001111110000000000
  if ((bits & 0xff80fc00U) != 0x7f00fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCVTZU_ASISDSHF_C;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_ASIMDSHF_C(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000001111110000000000
  if ((bits & 0xbf80fc00U) != 0x2f00fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCVTZU_ASIMDSHF_C;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractSSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000000100010000000000
  if ((bits & 0xff20fc00U) != 0x5e204400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SSHL_ASISDSAME_ONLY;
  inst.iclass = InstName::SSHL;
  return true;
}

static bool TryExtractSSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000100010000000000
  if ((bits & 0xbf20fc00U) != 0xe204400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SSHL_ASIMDSAME_ONLY;
  inst.iclass = InstName::SSHL;
  return true;
}

static bool TryExtractUXTB_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01010011000000000001110000000000
  if ((bits & 0xfffffc00U) != 0x53001c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::UXTB_UBFM_32M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractSSRA_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000000001010000000000
  if ((bits & 0xff80fc00U) != 0x5f001400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SSRA_ASISDSHF_R;
  inst.iclass = InstName::SSRA;
  return true;
}

static bool TryExtractSSRA_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000000001010000000000
  if ((bits & 0xbf80fc00U) != 0xf001400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SSRA_ASIMDSHF_R;
  inst.iclass = InstName::SSRA;
  return true;
}

static bool TryExtractLDRSW_64_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000101000000000100000000000
  if ((bits & 0xffe00c00U) != 0xb8a00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSW_64_LDST_REGOFF;
  inst.iclass = InstName::LDRSW;
  return true;
}

static bool TryExtractSQSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000000100110000000000
  if ((bits & 0xff20fc00U) != 0x5e204c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQSHL_ASISDSAME_ONLY;
  inst.iclass = InstName::SQSHL;
  return true;
}

static bool TryExtractSQSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000100110000000000
  if ((bits & 0xbf20fc00U) != 0xe204c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQSHL_ASIMDSAME_ONLY;
  inst.iclass = InstName::SQSHL;
  return true;
}

static bool TryExtractADDV_ASIMDALL_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001100011011100000000000
  if ((bits & 0xbf3ffc00U) != 0xe31b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ADDV_ASIMDALL_ONLY;
  inst.iclass = InstName::ADDV;
  return true;
}

static bool TryExtractPMUL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001001110000000000
  if ((bits & 0xbf20fc00U) != 0x2e209c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::PMUL_ASIMDSAME_ONLY;
  inst.iclass = InstName::PMUL;
  return true;
}

static bool TryExtractSMLSL_ASIMDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00001111000000000110000000000000
  if ((bits & 0xbf00f400U) != 0xf006000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMLSL_ASIMDELEM_L;
  inst.iclass = InstName::SMLSL;
  return true;
}

static bool TryExtractNEG_SUB_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000001111100000
  //   --------------------------------
  //   01001011000000000000001111100000
  if ((bits & 0xff2003e0U) != 0x4b0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::NEG_SUB_32_ADDSUB_SHIFT;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractNEG_SUB_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000001111100000
  //   --------------------------------
  //   11001011000000000000001111100000
  if ((bits & 0xff2003e0U) != 0xcb0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::NEG_SUB_64_ADDSUB_SHIFT;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractFCMP_H_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110111000000010000000000000
  if ((bits & 0xffe0fc1fU) != 0x1ee02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMP_H_FLOATCMP;
  inst.iclass = InstName::FCMP;
  return true;
}

static bool TryExtractFCMP_HZ_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110111000000010000000001000
  if ((bits & 0xffe0fc1fU) != 0x1ee02008U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMP_HZ_FLOATCMP;
  inst.iclass = InstName::FCMP;
  return true;
}

static bool TryExtractFCMP_S_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110001000000010000000000000
  if ((bits & 0xffe0fc1fU) != 0x1e202000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMP_S_FLOATCMP;
  inst.iclass = InstName::FCMP;
  return true;
}

static bool TryExtractFCMP_SZ_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110001000000010000000001000
  if ((bits & 0xffe0fc1fU) != 0x1e202008U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMP_SZ_FLOATCMP;
  inst.iclass = InstName::FCMP;
  return true;
}

static bool TryExtractFCMP_D_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110011000000010000000000000
  if ((bits & 0xffe0fc1fU) != 0x1e602000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMP_D_FLOATCMP;
  inst.iclass = InstName::FCMP;
  return true;
}

static bool TryExtractFCMP_DZ_FLOATCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00011110011000000010000000001000
  if ((bits & 0xffe0fc1fU) != 0x1e602008U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t _0 : 1;  // 0
      uint32_t _1 : 1;  // 0
      uint32_t _2 : 1;  // 0
      uint32_t opc : 2;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 2;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMP_DZ_FLOATCMP;
  inst.iclass = InstName::FCMP;
  return true;
}

static bool TryExtractORR_32_LOG_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_ORR_32_LOG_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   00101010000000000000000000000000
  if ((bits & 0xff200000U) != 0x2a000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ORR_32_LOG_SHIFT;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractORR_64_LOG_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_ORR_64_LOG_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   10101010000000000000000000000000
  if ((bits & 0xff200000U) != 0xaa000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ORR_64_LOG_SHIFT;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractSHA1SU0_VVV_CRYPTOSHA3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110000000000011000000000000
  if ((bits & 0xffe0fc00U) != 0x5e003000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHA1SU0_VVV_CRYPTOSHA3;
  inst.iclass = InstName::SHA1SU0;
  return true;
}

static bool TryExtractSTSET_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000001000000011000000011111
  if ((bits & 0xffe0fc1fU) != 0xb820301fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSET_32S_MEMOP;
  inst.iclass = InstName::STSET;
  return true;
}

static bool TryExtractSTSETL_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000011000000011000000011111
  if ((bits & 0xffe0fc1fU) != 0xb860301fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSETL_32S_MEMOP;
  inst.iclass = InstName::STSETL;
  return true;
}

static bool TryExtractSTSET_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000001000000011000000011111
  if ((bits & 0xffe0fc1fU) != 0xf820301fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSET_64S_MEMOP;
  inst.iclass = InstName::STSET;
  return true;
}

static bool TryExtractSTSETL_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000011000000011000000011111
  if ((bits & 0xffe0fc1fU) != 0xf860301fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSETL_64S_MEMOP;
  inst.iclass = InstName::STSETL;
  return true;
}

static bool TryExtractMLA_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001001010000000000
  if ((bits & 0xbf20fc00U) != 0xe209400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::MLA_ASIMDSAME_ONLY;
  inst.iclass = InstName::MLA;
  return true;
}

static bool TryExtractADDS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMN_ADDS_32_ADDSUB_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   00101011000000000000000000000000
  if ((bits & 0xff200000U) != 0x2b000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ADDS_32_ADDSUB_SHIFT;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractADDS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMN_ADDS_64_ADDSUB_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   10101011000000000000000000000000
  if ((bits & 0xff200000U) != 0xab000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ADDS_64_ADDSUB_SHIFT;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractLD3R_ASISDLSO_R3(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001101010000001110000000000000
  if ((bits & 0xbffff000U) != 0xd40e000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3R_ASISDLSO_R3;
  inst.iclass = InstName::LD3R;
  return true;
}

static bool TryExtractLD3R_ASISDLSOP_R3_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001101110111111110000000000000
  if ((bits & 0xbffff000U) != 0xddfe000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3R_ASISDLSOP_R3_I;
  inst.iclass = InstName::LD3R;
  return true;
}

static bool TryExtractLD3R_ASISDLSOP_RX3_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001101110000001110000000000000
  if ((bits & 0xbfe0f000U) != 0xdc0e000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3R_ASISDLSOP_RX3_R;
  inst.iclass = InstName::LD3R;
  return true;
}

static bool TryExtractPRFM_P_LOADLIT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   11011000000000000000000000000000
  if ((bits & 0xff000000U) != 0xd8000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.iform = InstForm::PRFM_P_LOADLIT;
  inst.iclass = InstName::PRFM;
  return true;
}

static bool TryExtractCASAB_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000111000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x8e07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASAB_C32_LDSTEXCL;
  inst.iclass = InstName::CASAB;
  return true;
}

static bool TryExtractCASALB_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000111000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x8e0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASALB_C32_LDSTEXCL;
  inst.iclass = InstName::CASALB;
  return true;
}

static bool TryExtractCASB_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000101000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x8a07c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASB_C32_LDSTEXCL;
  inst.iclass = InstName::CASB;
  return true;
}

static bool TryExtractCASLB_C32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001000101000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x8a0fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::CASLB_C32_LDSTEXCL;
  inst.iclass = InstName::CASLB;
  return true;
}

static bool TryExtractNEGS_SUBS_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000001111100000
  //   --------------------------------
  //   01101011000000000000001111100000
  if ((bits & 0xff2003e0U) != 0x6b0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::NEGS_SUBS_32_ADDSUB_SHIFT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractNEGS_SUBS_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000001111100000
  //   --------------------------------
  //   11101011000000000000001111100000
  if ((bits & 0xff2003e0U) != 0xeb0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::NEGS_SUBS_64_ADDSUB_SHIFT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractLDSMAXAH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000101000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x78a04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXAH_32_MEMOP;
  inst.iclass = InstName::LDSMAXAH;
  return true;
}

static bool TryExtractLDSMAXALH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000111000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x78e04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXALH_32_MEMOP;
  inst.iclass = InstName::LDSMAXALH;
  return true;
}

static bool TryExtractLDSMAXH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000001000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x78204000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXH_32_MEMOP;
  inst.iclass = InstName::LDSMAXH;
  return true;
}

static bool TryExtractLDSMAXLH_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111000011000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x78604000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXLH_32_MEMOP;
  inst.iclass = InstName::LDSMAXLH;
  return true;
}

static bool TryExtractMSUB_32A_DP_3SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractMNEG_MSUB_32A_DP_3SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011011000000001000000000000000
  if ((bits & 0xffe08000U) != 0x1b008000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t op31 : 3;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.op31 = static_cast<uint8_t>(enc.op31);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MSUB_32A_DP_3SRC;
  inst.iclass = InstName::MSUB;
  return true;
}

static bool TryExtractMSUB_64A_DP_3SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractMNEG_MSUB_64A_DP_3SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   10011011000000001000000000000000
  if ((bits & 0xffe08000U) != 0x9b008000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t op31 : 3;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.op31 = static_cast<uint8_t>(enc.op31);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MSUB_64A_DP_3SRC;
  inst.iclass = InstName::MSUB;
  return true;
}

static bool TryExtractLD4_ASISDLSE_R4(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100010000000000000000000000
  if ((bits & 0xbffff000U) != 0xc400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSE_R4;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSEP_I4_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100110111110000000000000000
  if ((bits & 0xbffff000U) != 0xcdf0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSEP_I4_I;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSEP_R4_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100110000000000000000000000
  if ((bits & 0xbfe0f000U) != 0xcc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSEP_R4_R;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractUQXTN_ASISDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01111110001000010100100000000000
  if ((bits & 0xff3ffc00U) != 0x7e214800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQXTN_ASISDMISC_N;
  inst.iclass = InstName::UQXTN;
  return true;
}

static bool TryExtractUQXTN_ASIMDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000010100100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e214800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQXTN_ASIMDMISC_N;
  inst.iclass = InstName::UQXTN;
  return true;
}

static bool TryExtractTBZ_ONLY_TESTBRANCH(InstData &inst, uint32_t bits) {

  //   bits
  // & 01111111000000000000000000000000
  //   --------------------------------
  //   00110110000000000000000000000000
  if ((bits & 0x7f000000U) != 0x36000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm14 : 14;
      uint32_t b40 : 5;
      uint32_t op : 1;
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t _30 : 1;  // 0
      uint32_t b5 : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.b5 = static_cast<uint8_t>(enc.b5);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.imm14.uimm = static_cast<uint64_t>(enc.imm14);
  inst.b40 = static_cast<uint8_t>(enc.b40);
  inst.iform = InstForm::TBZ_ONLY_TESTBRANCH;
  inst.iclass = InstName::TBZ;
  return true;
}

static bool TryExtractFMINNMV_ASIMDALL_ONLY_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110101100001100100000000000
  if ((bits & 0xbffffc00U) != 0xeb0c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINNMV_ASIMDALL_ONLY_H;
  inst.iclass = InstName::FMINNMV;
  return true;
}

static bool TryExtractFMINNMV_ASIMDALL_ONLY_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101100001100100000000000
  if ((bits & 0xbfbffc00U) != 0x2eb0c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINNMV_ASIMDALL_ONLY_SD;
  inst.iclass = InstName::FMINNMV;
  return true;
}

static bool TryExtractFCVTZS_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110111110011011100000000000
  if ((bits & 0xfffffc00U) != 0x5ef9b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTZS_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110101000011011100000000000
  if ((bits & 0xffbffc00U) != 0x5ea1b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTZS_ASISDMISC_R;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110111110011011100000000000
  if ((bits & 0xbffffc00U) != 0xef9b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTZS_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000011011100000000000
  if ((bits & 0xbfbffc00U) != 0xea1b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTZS_ASIMDMISC_R;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFMAXNM_H_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110111000000110100000000000
  if ((bits & 0xffe0fc00U) != 0x1ee06800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMAXNM_H_FLOATDP2;
  inst.iclass = InstName::FMAXNM;
  return true;
}

static bool TryExtractFMAXNM_S_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110001000000110100000000000
  if ((bits & 0xffe0fc00U) != 0x1e206800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMAXNM_S_FLOATDP2;
  inst.iclass = InstName::FMAXNM;
  return true;
}

static bool TryExtractFMAXNM_D_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110011000000110100000000000
  if ((bits & 0xffe0fc00U) != 0x1e606800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 2;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMAXNM_D_FLOATDP2;
  inst.iclass = InstName::FMAXNM;
  return true;
}

static bool TryExtractLDR_32_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000010000000000010000000000
  if ((bits & 0xffe00c00U) != 0xb8400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_32_LDST_IMMPOST;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_64_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000010000000000010000000000
  if ((bits & 0xffe00c00U) != 0xf8400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_64_LDST_IMMPOST;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_32_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000010000000000110000000000
  if ((bits & 0xffe00c00U) != 0xb8400c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_32_LDST_IMMPRE;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_64_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000010000000000110000000000
  if ((bits & 0xffe00c00U) != 0xf8400c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_64_LDST_IMMPRE;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_32_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10111001010000000000000000000000
  if ((bits & 0xffc00000U) != 0xb9400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_32_LDST_POS;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractLDR_64_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   11111001010000000000000000000000
  if ((bits & 0xffc00000U) != 0xf9400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDR_64_LDST_POS;
  inst.iclass = InstName::LDR;
  return true;
}

static bool TryExtractCNT_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000000101100000000000
  if ((bits & 0xbf3ffc00U) != 0xe205800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CNT_ASIMDMISC_R;
  inst.iclass = InstName::CNT;
  return true;
}

static bool TryExtractSQSHL_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000000111010000000000
  if ((bits & 0xff80fc00U) != 0x5f007400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQSHL_ASISDSHF_R;
  inst.iclass = InstName::SQSHL;
  return true;
}

static bool TryExtractSQSHL_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000000111010000000000
  if ((bits & 0xbf80fc00U) != 0xf007400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQSHL_ASIMDSHF_R;
  inst.iclass = InstName::SQSHL;
  return true;
}

static bool TryExtractLDTR_32_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000010000000000100000000000
  if ((bits & 0xffe00c00U) != 0xb8400800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDTR_32_LDST_UNPRIV;
  inst.iclass = InstName::LDTR;
  return true;
}

static bool TryExtractLDTR_64_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000010000000000100000000000
  if ((bits & 0xffe00c00U) != 0xf8400800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDTR_64_LDST_UNPRIV;
  inst.iclass = InstName::LDTR;
  return true;
}

static bool TryExtractCCMP_32_CONDCMP_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   01111010010000000000100000000000
  if ((bits & 0xffe00c10U) != 0x7a400800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t o3 : 1;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 1
      uint32_t cond : 4;
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CCMP_32_CONDCMP_IMM;
  inst.iclass = InstName::CCMP;
  return true;
}

static bool TryExtractCCMP_64_CONDCMP_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   11111010010000000000100000000000
  if ((bits & 0xffe00c10U) != 0xfa400800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t o3 : 1;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 1
      uint32_t cond : 4;
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CCMP_64_CONDCMP_IMM;
  inst.iclass = InstName::CCMP;
  return true;
}

static bool TryExtractUZP2_ASIMDPERM_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110000000000101100000000000
  if ((bits & 0xbf20fc00U) != 0xe005800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UZP2_ASIMDPERM_ONLY;
  inst.iclass = InstName::UZP2;
  return true;
}

static bool TryExtractLDURB_32_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000010000000000000000000000
  if ((bits & 0xffe00c00U) != 0x38400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDURB_32_LDST_UNSCALED;
  inst.iclass = InstName::LDURB;
  return true;
}

static bool TryExtractSQRDMLSH_ASISDSAME2_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110000000001000110000000000
  if ((bits & 0xff20fc00U) != 0x7e008c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMLSH_ASISDSAME2_ONLY;
  inst.iclass = InstName::SQRDMLSH;
  return true;
}

static bool TryExtractSQRDMLSH_ASIMDSAME2_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110000000001000110000000000
  if ((bits & 0xbf20fc00U) != 0x2e008c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMLSH_ASIMDSAME2_ONLY;
  inst.iclass = InstName::SQRDMLSH;
  return true;
}

static bool TryExtractMOV_INS_ASIMDINS_IR_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01001110000000000001110000000000
  if ((bits & 0xffe0fc00U) != 0x4e001c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::MOV_INS_ASIMDINS_IR_R;
  inst.iclass = InstName::INS;
  return true;
}

static bool TryExtractLDTRSB_32_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000110000000000100000000000
  if ((bits & 0xffe00c00U) != 0x38c00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDTRSB_32_LDST_UNPRIV;
  inst.iclass = InstName::LDTRSB;
  return true;
}

static bool TryExtractLDTRSB_64_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000100000000000100000000000
  if ((bits & 0xffe00c00U) != 0x38800800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDTRSB_64_LDST_UNPRIV;
  inst.iclass = InstName::LDTRSB;
  return true;
}

static bool TryExtractSMINV_ASIMDALL_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001100011010100000000000
  if ((bits & 0xbf3ffc00U) != 0xe31a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t op : 1;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMINV_ASIMDALL_ONLY;
  inst.iclass = InstName::SMINV;
  return true;
}

static bool TryExtractURHADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000001010000000000
  if ((bits & 0xbf20fc00U) != 0x2e201400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::URHADD_ASIMDSAME_ONLY;
  inst.iclass = InstName::URHADD;
  return true;
}

static bool TryExtractAND_32_LOG_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00010010000000000000000000000000
  if ((bits & 0xffc00000U) != 0x12000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::AND_32_LOG_IMM;
  inst.iclass = InstName::AND;
  return true;
}

static bool TryExtractAND_64_LOG_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   10010010000000000000000000000000
  if ((bits & 0xff800000U) != 0x92000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::AND_64_LOG_IMM;
  inst.iclass = InstName::AND;
  return true;
}

static bool TryExtractSABD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000111010000000000
  if ((bits & 0xbf20fc00U) != 0xe207400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SABD_ASIMDSAME_ONLY;
  inst.iclass = InstName::SABD;
  return true;
}

static bool TryExtractFCMGE_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111110010000000010010000000000
  if ((bits & 0xffe0fc00U) != 0x7e402400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMGE_ASISDSAMEFP16_ONLY;
  inst.iclass = InstName::FCMGE;
  return true;
}

static bool TryExtractFCMGE_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101000001111110000000000
  //   --------------------------------
  //   01111110001000001110010000000000
  if ((bits & 0xffa0fc00U) != 0x7e20e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMGE_ASISDSAME_ONLY;
  inst.iclass = InstName::FCMGE;
  return true;
}

static bool TryExtractFCMGE_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110010000000010010000000000
  if ((bits & 0xbfe0fc00U) != 0x2e402400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMGE_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FCMGE;
  return true;
}

static bool TryExtractFCMGE_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110001000001110010000000000
  if ((bits & 0xbfa0fc00U) != 0x2e20e400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCMGE_ASIMDSAME_ONLY;
  inst.iclass = InstName::FCMGE;
  return true;
}

static bool TryExtractMVN_NOT_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110001000000101100000000000
  if ((bits & 0xbffffc00U) != 0x2e205800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::MVN_NOT_ASIMDMISC_R;
  inst.iclass = InstName::NOT;
  return true;
}

static bool TryExtractSTSMIN_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000001000000101000000011111
  if ((bits & 0xffe0fc1fU) != 0xb820501fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMIN_32S_MEMOP;
  inst.iclass = InstName::STSMIN;
  return true;
}

static bool TryExtractSTSMINL_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   10111000011000000101000000011111
  if ((bits & 0xffe0fc1fU) != 0xb860501fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMINL_32S_MEMOP;
  inst.iclass = InstName::STSMINL;
  return true;
}

static bool TryExtractSTSMIN_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000001000000101000000011111
  if ((bits & 0xffe0fc1fU) != 0xf820501fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMIN_64S_MEMOP;
  inst.iclass = InstName::STSMIN;
  return true;
}

static bool TryExtractSTSMINL_64S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   11111000011000000101000000011111
  if ((bits & 0xffe0fc1fU) != 0xf860501fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMINL_64S_MEMOP;
  inst.iclass = InstName::STSMINL;
  return true;
}

static bool TryExtractTRN1_ASIMDPERM_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110000000000010100000000000
  if ((bits & 0xbf20fc00U) != 0xe002800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::TRN1_ASIMDPERM_ONLY;
  inst.iclass = InstName::TRN1;
  return true;
}

static bool TryExtractSBCS_32_ADDSUB_CARRY(InstData &inst, uint32_t bits) {
  if (false && TryExtractNGCS_SBCS_32_ADDSUB_CARRY(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111010000000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x7a000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SBCS_32_ADDSUB_CARRY;
  inst.iclass = InstName::SBCS;
  return true;
}

static bool TryExtractSBCS_64_ADDSUB_CARRY(InstData &inst, uint32_t bits) {
  if (false && TryExtractNGCS_SBCS_64_ADDSUB_CARRY(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111010000000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xfa000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SBCS_64_ADDSUB_CARRY;
  inst.iclass = InstName::SBCS;
  return true;
}

static bool TryExtractSMULL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001100000000000000
  if ((bits & 0xbf20fc00U) != 0xe20c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMULL_ASIMDDIFF_L;
  inst.iclass = InstName::SMULL;
  return true;
}

static bool TryExtractLSRV_32_DP_2SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractLSR_LSRV_32_DP_2SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000010010000000000
  if ((bits & 0xffe0fc00U) != 0x1ac02400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::LSRV_32_DP_2SRC;
  inst.iclass = InstName::LSRV;
  return true;
}

static bool TryExtractLSRV_64_DP_2SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractLSR_LSRV_64_DP_2SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000010010000000000
  if ((bits & 0xffe0fc00U) != 0x9ac02400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t op2 : 2;
      uint32_t opcode2 : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::LSRV_64_DP_2SRC;
  inst.iclass = InstName::LSRV;
  return true;
}

static bool TryExtractURSQRTE_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101000011100100000000000
  if ((bits & 0xbfbffc00U) != 0x2ea1c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::URSQRTE_ASIMDMISC_R;
  inst.iclass = InstName::URSQRTE;
  return true;
}

static bool TryExtractFCCMPE_H_FLOATCCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   00011110111000000000010000010000
  if ((bits & 0xffe00c10U) != 0x1ee00410U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t op : 1;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCCMPE_H_FLOATCCMP;
  inst.iclass = InstName::FCCMPE;
  return true;
}

static bool TryExtractFCCMPE_S_FLOATCCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   00011110001000000000010000010000
  if ((bits & 0xffe00c10U) != 0x1e200410U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t op : 1;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCCMPE_S_FLOATCCMP;
  inst.iclass = InstName::FCCMPE;
  return true;
}

static bool TryExtractFCCMPE_D_FLOATCCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   00011110011000000000010000010000
  if ((bits & 0xffe00c10U) != 0x1e600410U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t op : 1;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCCMPE_D_FLOATCCMP;
  inst.iclass = InstName::FCCMPE;
  return true;
}

static bool TryExtractFMAXP_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110010000000011010000000000
  if ((bits & 0xbfe0fc00U) != 0x2e403400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXP_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMAXP;
  return true;
}

static bool TryExtractFMAXP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110001000001111010000000000
  if ((bits & 0xbfa0fc00U) != 0x2e20f400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXP_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMAXP;
  return true;
}

static bool TryExtractMUL_MADD_32A_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011011000000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x1b007c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t op31 : 3;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.op31 = static_cast<uint8_t>(enc.op31);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MUL_MADD_32A_DP_3SRC;
  inst.iclass = InstName::MADD;
  return true;
}

static bool TryExtractMUL_MADD_64A_DP_3SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011011000000000111110000000000
  if ((bits & 0xffe0fc00U) != 0x9b007c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t op31 : 3;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.op31 = static_cast<uint8_t>(enc.op31);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MUL_MADD_64A_DP_3SRC;
  inst.iclass = InstName::MADD;
  return true;
}

static bool TryExtractSTTR_32_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000000000000000100000000000
  if ((bits & 0xffe00c00U) != 0xb8000800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STTR_32_LDST_UNPRIV;
  inst.iclass = InstName::STTR;
  return true;
}

static bool TryExtractSTTR_64_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000000000000000100000000000
  if ((bits & 0xffe00c00U) != 0xf8000800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STTR_64_LDST_UNPRIV;
  inst.iclass = InstName::STTR;
  return true;
}

static bool TryExtractFCMGT_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110111110001100100000000000
  if ((bits & 0xfffffc00U) != 0x5ef8c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMGT_ASISDMISCFP16_FZ;
  inst.iclass = InstName::FCMGT;
  return true;
}

static bool TryExtractFCMGT_ASISDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110101000001100100000000000
  if ((bits & 0xffbffc00U) != 0x5ea0c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMGT_ASISDMISC_FZ;
  inst.iclass = InstName::FCMGT;
  return true;
}

static bool TryExtractFCMGT_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110111110001100100000000000
  if ((bits & 0xbffffc00U) != 0xef8c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMGT_ASIMDMISCFP16_FZ;
  inst.iclass = InstName::FCMGT;
  return true;
}

static bool TryExtractFCMGT_ASIMDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000001100100000000000
  if ((bits & 0xbfbffc00U) != 0xea0c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMGT_ASIMDMISC_FZ;
  inst.iclass = InstName::FCMGT;
  return true;
}

static bool TryExtractBSL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110011000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0x2e601c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opc2 = static_cast<uint8_t>(enc.opc2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::BSL_ASIMDSAME_ONLY;
  inst.iclass = InstName::BSL;
  return true;
}

static bool TryExtractUQSUB_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000000010110000000000
  if ((bits & 0xff20fc00U) != 0x7e202c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQSUB_ASISDSAME_ONLY;
  inst.iclass = InstName::UQSUB;
  return true;
}

static bool TryExtractUQSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000010110000000000
  if ((bits & 0xbf20fc00U) != 0x2e202c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQSUB_ASIMDSAME_ONLY;
  inst.iclass = InstName::UQSUB;
  return true;
}

static bool TryExtractWFI_HI_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010101000000110010000001111111
  if ((bits & 0xffffffffU) != 0xd503207fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::WFI_HI_SYSTEM;
  inst.iclass = InstName::WFI;
  return true;
}

static bool TryExtractLDXRH_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01001000010111110111110000000000
  if ((bits & 0xfffffc00U) != 0x485f7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDXRH_LR32_LDSTEXCL;
  inst.iclass = InstName::LDXRH;
  return true;
}

static bool TryExtractFMAXNMV_ASIMDALL_ONLY_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110001100001100100000000000
  if ((bits & 0xbffffc00U) != 0xe30c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXNMV_ASIMDALL_ONLY_H;
  inst.iclass = InstName::FMAXNMV;
  return true;
}

static bool TryExtractFMAXNMV_ASIMDALL_ONLY_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110001100001100100000000000
  if ((bits & 0xbfbffc00U) != 0x2e30c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMAXNMV_ASIMDALL_ONLY_SD;
  inst.iclass = InstName::FMAXNMV;
  return true;
}

static bool TryExtractSTLXR_SR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10001000000000001111110000000000
  if ((bits & 0xffe0fc00U) != 0x8800fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLXR_SR32_LDSTEXCL;
  inst.iclass = InstName::STLXR;
  return true;
}

static bool TryExtractSTLXR_SR64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11001000000000001111110000000000
  if ((bits & 0xffe0fc00U) != 0xc800fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLXR_SR64_LDSTEXCL;
  inst.iclass = InstName::STLXR;
  return true;
}

static bool TryExtractSTLRB_SL32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00001000100111111111110000000000
  if ((bits & 0xfffffc00U) != 0x89ffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLRB_SL32_LDSTEXCL;
  inst.iclass = InstName::STLRB;
  return true;
}

static bool TryExtractST3_ASISDLSE_R3(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100000000000100000000000000
  if ((bits & 0xbffff000U) != 0xc004000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSE_R3;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSEP_I3_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001100100111110100000000000000
  if ((bits & 0xbffff000U) != 0xc9f4000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSEP_I3_I;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractST3_ASISDLSEP_R3_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001100100000000100000000000000
  if ((bits & 0xbfe0f000U) != 0xc804000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST3_ASISDLSEP_R3_R;
  inst.iclass = InstName::ST3;
  return true;
}

static bool TryExtractSQRDMULH_ASISDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000001111010000000000
  //   --------------------------------
  //   01011111000000001101000000000000
  if ((bits & 0xff00f400U) != 0x5f00d000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQRDMULH_ASISDELEM_R;
  inst.iclass = InstName::SQRDMULH;
  return true;
}

static bool TryExtractSQRDMULH_ASIMDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00001111000000001101000000000000
  if ((bits & 0xbf00f400U) != 0xf00d000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQRDMULH_ASIMDELEM_R;
  inst.iclass = InstName::SQRDMULH;
  return true;
}

static bool TryExtractSXTW_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10010011010000000111110000000000
  if ((bits & 0xfffffc00U) != 0x93407c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SXTW_SBFM_64M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractUSHR_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000000000010000000000
  if ((bits & 0xff80fc00U) != 0x7f000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::USHR_ASISDSHF_R;
  inst.iclass = InstName::USHR;
  return true;
}

static bool TryExtractUSHR_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000000000010000000000
  if ((bits & 0xbf80fc00U) != 0x2f000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::USHR_ASIMDSHF_R;
  inst.iclass = InstName::USHR;
  return true;
}

static bool TryExtractB_ONLY_BRANCH_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111100000000000000000000000000
  //   --------------------------------
  //   00010100000000000000000000000000
  if ((bits & 0xfc000000U) != 0x14000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t imm26 : 26;
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 0
      uint32_t op : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm26.uimm = static_cast<uint64_t>(enc.imm26);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::B_ONLY_BRANCH_IMM;
  inst.iclass = InstName::B;
  return true;
}

static bool TryExtractFCMEQ_ASISDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110111110001101100000000000
  if ((bits & 0xfffffc00U) != 0x5ef8d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMEQ_ASISDMISCFP16_FZ;
  inst.iclass = InstName::FCMEQ;
  return true;
}

static bool TryExtractFCMEQ_ASISDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110101000001101100000000000
  if ((bits & 0xffbffc00U) != 0x5ea0d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMEQ_ASISDMISC_FZ;
  inst.iclass = InstName::FCMEQ;
  return true;
}

static bool TryExtractFCMEQ_ASIMDMISCFP16_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110111110001101100000000000
  if ((bits & 0xbffffc00U) != 0xef8d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMEQ_ASIMDMISCFP16_FZ;
  inst.iclass = InstName::FCMEQ;
  return true;
}

static bool TryExtractFCMEQ_ASIMDMISC_FZ(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000001101100000000000
  if ((bits & 0xbfbffc00U) != 0xea0d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t op : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCMEQ_ASIMDMISC_FZ;
  inst.iclass = InstName::FCMEQ;
  return true;
}

static bool TryExtractFACGE_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111110010000000010110000000000
  if ((bits & 0xffe0fc00U) != 0x7e402c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FACGE_ASISDSAMEFP16_ONLY;
  inst.iclass = InstName::FACGE;
  return true;
}

static bool TryExtractFACGE_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101000001111110000000000
  //   --------------------------------
  //   01111110001000001110110000000000
  if ((bits & 0xffa0fc00U) != 0x7e20ec00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FACGE_ASISDSAME_ONLY;
  inst.iclass = InstName::FACGE;
  return true;
}

static bool TryExtractFACGE_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110010000000010110000000000
  if ((bits & 0xbfe0fc00U) != 0x2e402c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FACGE_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FACGE;
  return true;
}

static bool TryExtractFACGE_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110001000001110110000000000
  if ((bits & 0xbfa0fc00U) != 0x2e20ec00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FACGE_ASIMDSAME_ONLY;
  inst.iclass = InstName::FACGE;
  return true;
}

static bool TryExtractCSEL_32_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00011010100000000000000000000000
  if ((bits & 0xffe00c00U) != 0x1a800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSEL_32_CONDSEL;
  inst.iclass = InstName::CSEL;
  return true;
}

static bool TryExtractCSEL_64_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10011010100000000000000000000000
  if ((bits & 0xffe00c00U) != 0x9a800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSEL_64_CONDSEL;
  inst.iclass = InstName::CSEL;
  return true;
}

static bool TryExtractFCVTAS_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001000000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee40000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAS_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractFCVTAS_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111001000000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee40000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAS_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractFCVTAS_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e240000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAS_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractFCVTAS_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001001000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e240000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAS_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractFCVTAS_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011001000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e640000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAS_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractFCVTAS_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011001000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e640000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTAS_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractLDURSH_32_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000110000000000000000000000
  if ((bits & 0xffe00c00U) != 0x78c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDURSH_32_LDST_UNSCALED;
  inst.iclass = InstName::LDURSH;
  return true;
}

static bool TryExtractLDURSH_64_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000100000000000000000000000
  if ((bits & 0xffe00c00U) != 0x78800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDURSH_64_LDST_UNSCALED;
  inst.iclass = InstName::LDURSH;
  return true;
}

static bool TryExtractLDURSW_64_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000100000000000000000000000
  if ((bits & 0xffe00c00U) != 0xb8800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDURSW_64_LDST_UNSCALED;
  inst.iclass = InstName::LDURSW;
  return true;
}

static bool TryExtractMOVN_32_MOVEWIDE(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_MOVN_32_MOVEWIDE(inst, bits))
    return true;

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   00010010100000000000000000000000
  if ((bits & 0xff800000U) != 0x12800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOVN_32_MOVEWIDE;
  inst.iclass = InstName::MOVN;
  return true;
}

static bool TryExtractMOVN_64_MOVEWIDE(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_MOVN_64_MOVEWIDE(inst, bits))
    return true;

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   10010010100000000000000000000000
  if ((bits & 0xff800000U) != 0x92800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOVN_64_MOVEWIDE;
  inst.iclass = InstName::MOVN;
  return true;
}

static bool TryExtractSXTL_SSHLL_ASIMDSHF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100001111111110000000000
  //   --------------------------------
  //   00001111000000001010010000000000
  if ((bits & 0xbf87fc00U) != 0xf00a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SXTL_SSHLL_ASIMDSHF_L;
  inst.iclass = InstName::SSHLL;
  return true;
}

static bool TryExtractST1_ASISDLSO_B1_1B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101000000000000000000000000
  if ((bits & 0xbfffe000U) != 0xd000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSO_B1_1B;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSO_H1_1H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101000000000100000000000000
  if ((bits & 0xbfffe400U) != 0xd004000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSO_H1_1H;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSO_S1_1S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101000000001000000000000000
  if ((bits & 0xbfffec00U) != 0xd008000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSO_S1_1S;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSO_D1_1D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101000000001000010000000000
  if ((bits & 0xbffffc00U) != 0xd008400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSO_D1_1D;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSOP_B1_I1B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101100111110000000000000000
  if ((bits & 0xbfffe000U) != 0xd9f0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSOP_B1_I1B;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSOP_BX1_R1B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110000000000000
  //   --------------------------------
  //   00001101100000000000000000000000
  if ((bits & 0xbfe0e000U) != 0xd800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSOP_BX1_R1B;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSOP_H1_I1H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101100111110100000000000000
  if ((bits & 0xbfffe400U) != 0xd9f4000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSOP_H1_I1H;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSOP_HX1_R1H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110010000000000
  //   --------------------------------
  //   00001101100000000100000000000000
  if ((bits & 0xbfe0e400U) != 0xd804000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSOP_HX1_R1H;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSOP_S1_I1S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101100111111000000000000000
  if ((bits & 0xbfffec00U) != 0xd9f8000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSOP_S1_I1S;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSOP_SX1_R1S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110110000000000
  //   --------------------------------
  //   00001101100000001000000000000000
  if ((bits & 0xbfe0ec00U) != 0xd808000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSOP_SX1_R1S;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSOP_D1_I1D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101100111111000010000000000
  if ((bits & 0xbffffc00U) != 0xd9f8400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSOP_D1_I1D;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractST1_ASISDLSOP_DX1_R1D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001101100000001000010000000000
  if ((bits & 0xbfe0fc00U) != 0xd808400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST1_ASISDLSOP_DX1_R1D;
  inst.iclass = InstName::ST1;
  return true;
}

static bool TryExtractUZP1_ASIMDPERM_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110000000000001100000000000
  if ((bits & 0xbf20fc00U) != 0xe001800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UZP1_ASIMDPERM_ONLY;
  inst.iclass = InstName::UZP1;
  return true;
}

static bool TryExtractSTUR_B_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100000000000000000000000000
  if ((bits & 0xffe00c00U) != 0x3c000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUR_B_LDST_UNSCALED;
  inst.iclass = InstName::STUR;
  return true;
}

static bool TryExtractSTUR_H_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111100000000000000000000000000
  if ((bits & 0xffe00c00U) != 0x7c000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUR_H_LDST_UNSCALED;
  inst.iclass = InstName::STUR;
  return true;
}

static bool TryExtractSTUR_S_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111100000000000000000000000000
  if ((bits & 0xffe00c00U) != 0xbc000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUR_S_LDST_UNSCALED;
  inst.iclass = InstName::STUR;
  return true;
}

static bool TryExtractSTUR_D_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111100000000000000000000000000
  if ((bits & 0xffe00c00U) != 0xfc000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUR_D_LDST_UNSCALED;
  inst.iclass = InstName::STUR;
  return true;
}

static bool TryExtractSTUR_Q_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100100000000000000000000000
  if ((bits & 0xffe00c00U) != 0x3c800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STUR_Q_LDST_UNSCALED;
  inst.iclass = InstName::STUR;
  return true;
}

static bool TryExtractMLA_ASIMDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00101111000000000000000000000000
  if ((bits & 0xbf00f400U) != 0x2f000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::MLA_ASIMDELEM_R;
  inst.iclass = InstName::MLA;
  return true;
}

static bool TryExtractFCVTPU_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111010010000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee90000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPU_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractFCVTPU_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111010010000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee90000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPU_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractFCVTPU_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001010010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e290000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPU_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractFCVTPU_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001010010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e290000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPU_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractFCVTPU_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011010010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e690000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPU_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractFCVTPU_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011010010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e690000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTPU_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractSTSETH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000001000000011000000011111
  if ((bits & 0xffe0fc1fU) != 0x7820301fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSETH_32S_MEMOP;
  inst.iclass = InstName::STSETH;
  return true;
}

static bool TryExtractSTSETLH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000011000000011000000011111
  if ((bits & 0xffe0fc1fU) != 0x7860301fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSETLH_32S_MEMOP;
  inst.iclass = InstName::STSETLH;
  return true;
}

static bool TryExtractFMINV_ASIMDALL_ONLY_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110101100001111100000000000
  if ((bits & 0xbffffc00U) != 0xeb0f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINV_ASIMDALL_ONLY_H;
  inst.iclass = InstName::FMINV;
  return true;
}

static bool TryExtractFMINV_ASIMDALL_ONLY_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101100001111100000000000
  if ((bits & 0xbfbffc00U) != 0x2eb0f800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINV_ASIMDALL_ONLY_SD;
  inst.iclass = InstName::FMINV;
  return true;
}

static bool TryExtractMOV_ORR_32_LOG_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000001111100000
  //   --------------------------------
  //   00110010000000000000001111100000
  if ((bits & 0xffc003e0U) != 0x320003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::MOV_ORR_32_LOG_IMM;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractMOV_ORR_64_LOG_IMM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000001111100000
  //   --------------------------------
  //   10110010000000000000001111100000
  if ((bits & 0xff8003e0U) != 0xb20003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::MOV_ORR_64_LOG_IMM;
  inst.iclass = InstName::ORR;
  return true;
}

static bool TryExtractDSB_BO_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111000011111111
  //   --------------------------------
  //   11010101000000110011000010011111
  if ((bits & 0xfffff0ffU) != 0xd503309fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t opc : 2;
      uint32_t _7 : 1;  // 1
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::DSB_BO_SYSTEM;
  inst.iclass = InstName::DSB;
  return true;
}

static bool TryExtractFCVTMS_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111100000000000000000000
  if ((bits & 0xfffffc00U) != 0x1ef00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMS_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractFCVTMS_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111100000000000000000000
  if ((bits & 0xfffffc00U) != 0x9ef00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMS_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractFCVTMS_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001100000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e300000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMS_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractFCVTMS_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001100000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e300000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMS_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractFCVTMS_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011100000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e700000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMS_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractFCVTMS_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011100000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e700000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMS_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractSTSMINH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000001000000101000000011111
  if ((bits & 0xffe0fc1fU) != 0x7820501fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMINH_32S_MEMOP;
  inst.iclass = InstName::STSMINH;
  return true;
}

static bool TryExtractSTSMINLH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000011000000101000000011111
  if ((bits & 0xffe0fc1fU) != 0x7860501fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMINLH_32S_MEMOP;
  inst.iclass = InstName::STSMINLH;
  return true;
}

static bool TryExtractST4_ASISDLSO_B4_4B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101001000000010000000000000
  if ((bits & 0xbfffe000U) != 0xd202000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSO_B4_4B;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSO_H4_4H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101001000000110000000000000
  if ((bits & 0xbfffe400U) != 0xd206000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSO_H4_4H;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSO_S4_4S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101001000001010000000000000
  if ((bits & 0xbfffec00U) != 0xd20a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSO_S4_4S;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSO_D4_4D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101001000001010010000000000
  if ((bits & 0xbffffc00U) != 0xd20a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSO_D4_4D;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSOP_B4_I4B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101101111110010000000000000
  if ((bits & 0xbfffe000U) != 0xdbf2000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSOP_B4_I4B;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSOP_BX4_R4B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110000000000000
  //   --------------------------------
  //   00001101101000000010000000000000
  if ((bits & 0xbfe0e000U) != 0xda02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSOP_BX4_R4B;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSOP_H4_I4H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101101111110110000000000000
  if ((bits & 0xbfffe400U) != 0xdbf6000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSOP_H4_I4H;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSOP_HX4_R4H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110010000000000
  //   --------------------------------
  //   00001101101000000110000000000000
  if ((bits & 0xbfe0e400U) != 0xda06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSOP_HX4_R4H;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSOP_S4_I4S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101101111111010000000000000
  if ((bits & 0xbfffec00U) != 0xdbfa000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSOP_S4_I4S;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSOP_SX4_R4S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110110000000000
  //   --------------------------------
  //   00001101101000001010000000000000
  if ((bits & 0xbfe0ec00U) != 0xda0a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSOP_SX4_R4S;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSOP_D4_I4D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101101111111010010000000000
  if ((bits & 0xbffffc00U) != 0xdbfa400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSOP_D4_I4D;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractST4_ASISDLSOP_DX4_R4D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001101101000001010010000000000
  if ((bits & 0xbfe0fc00U) != 0xda0a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ST4_ASISDLSOP_DX4_R4D;
  inst.iclass = InstName::ST4;
  return true;
}

static bool TryExtractLDNP_S_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101100010000000000000000000000
  if ((bits & 0xffc00000U) != 0x2c400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDNP_S_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::LDNP;
  return true;
}

static bool TryExtractLDNP_D_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101100010000000000000000000000
  if ((bits & 0xffc00000U) != 0x6c400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDNP_D_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::LDNP;
  return true;
}

static bool TryExtractLDNP_Q_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101100010000000000000000000000
  if ((bits & 0xffc00000U) != 0xac400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDNP_Q_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::LDNP;
  return true;
}

static bool TryExtractADDS_32S_ADDSUB_EXT(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMN_ADDS_32S_ADDSUB_EXT(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   00101011001000000000000000000000
  if ((bits & 0xffe00000U) != 0x2b200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADDS_32S_ADDSUB_EXT;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractADDS_64S_ADDSUB_EXT(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMN_ADDS_64S_ADDSUB_EXT(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   10101011001000000000000000000000
  if ((bits & 0xffe00000U) != 0xab200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADDS_64S_ADDSUB_EXT;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractCBZ_32_COMPBRANCH(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   00110100000000000000000000000000
  if ((bits & 0xff000000U) != 0x34000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t op : 1;
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CBZ_32_COMPBRANCH;
  inst.iclass = InstName::CBZ;
  return true;
}

static bool TryExtractCBZ_64_COMPBRANCH(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   10110100000000000000000000000000
  if ((bits & 0xff000000U) != 0xb4000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t imm19 : 19;
      uint32_t op : 1;
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CBZ_64_COMPBRANCH;
  inst.iclass = InstName::CBZ;
  return true;
}

static bool TryExtractURSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000000101010000000000
  if ((bits & 0xff20fc00U) != 0x7e205400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::URSHL_ASISDSAME_ONLY;
  inst.iclass = InstName::URSHL;
  return true;
}

static bool TryExtractURSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000101010000000000
  if ((bits & 0xbf20fc00U) != 0x2e205400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::URSHL_ASIMDSAME_ONLY;
  inst.iclass = InstName::URSHL;
  return true;
}

static bool TryExtractSQRSHRUN_ASISDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000001000110000000000
  if ((bits & 0xff80fc00U) != 0x7f008c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQRSHRUN_ASISDSHF_N;
  inst.iclass = InstName::SQRSHRUN;
  return true;
}

static bool TryExtractSQRSHRUN_ASIMDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000001000110000000000
  if ((bits & 0xbf80fc00U) != 0x2f008c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQRSHRUN_ASIMDSHF_N;
  inst.iclass = InstName::SQRSHRUN;
  return true;
}

static bool TryExtractROR_EXTR_32_EXTRACT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00010011100000000000000000000000
  if ((bits & 0xffe08000U) != 0x13800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t Rm : 5;
      uint32_t o0 : 1;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t op21 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.op21 = static_cast<uint8_t>(enc.op21);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::ROR_EXTR_32_EXTRACT;
  inst.iclass = InstName::EXTR;
  return true;
}

static bool TryExtractROR_EXTR_64_EXTRACT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   10010011110000000000000000000000
  if ((bits & 0xffe00000U) != 0x93c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t Rm : 5;
      uint32_t o0 : 1;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t op21 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.op21 = static_cast<uint8_t>(enc.op21);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::ROR_EXTR_64_EXTRACT;
  inst.iclass = InstName::EXTR;
  return true;
}

static bool TryExtractFRINTI_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110111110011001100000000000
  if ((bits & 0xbffffc00U) != 0x2ef99800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTI_ASIMDMISCFP16_R;
  inst.iclass = InstName::FRINTI;
  return true;
}

static bool TryExtractFRINTI_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101000011001100000000000
  if ((bits & 0xbfbffc00U) != 0x2ea19800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTI_ASIMDMISC_R;
  inst.iclass = InstName::FRINTI;
  return true;
}

static bool TryExtractLDXRB_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00001000010111110111110000000000
  if ((bits & 0xfffffc00U) != 0x85f7c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDXRB_LR32_LDSTEXCL;
  inst.iclass = InstName::LDXRB;
  return true;
}

static bool TryExtractSTP_S_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101100100000000000000000000000
  if ((bits & 0xffc00000U) != 0x2c800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_S_LDSTPAIR_POST;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_D_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101100100000000000000000000000
  if ((bits & 0xffc00000U) != 0x6c800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_D_LDSTPAIR_POST;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_Q_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101100100000000000000000000000
  if ((bits & 0xffc00000U) != 0xac800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_Q_LDSTPAIR_POST;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_S_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101101100000000000000000000000
  if ((bits & 0xffc00000U) != 0x2d800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_S_LDSTPAIR_PRE;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_D_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101101100000000000000000000000
  if ((bits & 0xffc00000U) != 0x6d800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_D_LDSTPAIR_PRE;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_Q_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101101100000000000000000000000
  if ((bits & 0xffc00000U) != 0xad800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_Q_LDSTPAIR_PRE;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_S_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101101000000000000000000000000
  if ((bits & 0xffc00000U) != 0x2d000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_S_LDSTPAIR_OFF;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_D_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101101000000000000000000000000
  if ((bits & 0xffc00000U) != 0x6d000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_D_LDSTPAIR_OFF;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_Q_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101101000000000000000000000000
  if ((bits & 0xffc00000U) != 0xad000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_Q_LDSTPAIR_OFF;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractADR_ONLY_PCRELADDR(InstData &inst, uint32_t bits) {

  //   bits
  // & 10011111000000000000000000000000
  //   --------------------------------
  //   00010000000000000000000000000000
  if ((bits & 0x9f000000U) != 0x10000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t immhi : 19;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t immlo : 2;
      uint32_t op : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.immlo.uimm = static_cast<uint64_t>(enc.immlo);
  inst.immhi.uimm = static_cast<uint64_t>(enc.immhi);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.immhi_immlo.uimm = static_cast<uint64_t>(inst.immhi.uimm);
  inst.immhi_immlo.uimm <<= static_cast<uint64_t>(2U);
  inst.immhi_immlo.uimm |= static_cast<uint64_t>(inst.immlo.uimm);
  inst.iform = InstForm::ADR_ONLY_PCRELADDR;
  inst.iclass = InstName::ADR;
  return true;
}

static bool TryExtractLDSMINAB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000101000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x38a05000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINAB_32_MEMOP;
  inst.iclass = InstName::LDSMINAB;
  return true;
}

static bool TryExtractLDSMINALB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000111000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x38e05000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINALB_32_MEMOP;
  inst.iclass = InstName::LDSMINALB;
  return true;
}

static bool TryExtractLDSMINB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000001000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x38205000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINB_32_MEMOP;
  inst.iclass = InstName::LDSMINB;
  return true;
}

static bool TryExtractLDSMINLB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000011000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x38605000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMINLB_32_MEMOP;
  inst.iclass = InstName::LDSMINLB;
  return true;
}

static bool TryExtractUBFIZ_UBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01010011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x53000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::UBFIZ_UBFM_32M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractUBFIZ_UBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   11010011010000000000000000000000
  if ((bits & 0xffc00000U) != 0xd3400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::UBFIZ_UBFM_64M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractLD4_ASISDLSO_B4_4B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101011000000010000000000000
  if ((bits & 0xbfffe000U) != 0xd602000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSO_B4_4B;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSO_H4_4H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101011000000110000000000000
  if ((bits & 0xbfffe400U) != 0xd606000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSO_H4_4H;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSO_S4_4S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101011000001010000000000000
  if ((bits & 0xbfffec00U) != 0xd60a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSO_S4_4S;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSO_D4_4D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101011000001010010000000000
  if ((bits & 0xbffffc00U) != 0xd60a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSO_D4_4D;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSOP_B4_I4B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101111111110010000000000000
  if ((bits & 0xbfffe000U) != 0xdff2000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSOP_B4_I4B;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSOP_BX4_R4B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110000000000000
  //   --------------------------------
  //   00001101111000000010000000000000
  if ((bits & 0xbfe0e000U) != 0xde02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSOP_BX4_R4B;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSOP_H4_I4H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101111111110110000000000000
  if ((bits & 0xbfffe400U) != 0xdff6000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSOP_H4_I4H;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSOP_HX4_R4H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110010000000000
  //   --------------------------------
  //   00001101111000000110000000000000
  if ((bits & 0xbfe0e400U) != 0xde06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSOP_HX4_R4H;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSOP_S4_I4S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101111111111010000000000000
  if ((bits & 0xbfffec00U) != 0xdffa000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSOP_S4_I4S;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSOP_SX4_R4S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110110000000000
  //   --------------------------------
  //   00001101111000001010000000000000
  if ((bits & 0xbfe0ec00U) != 0xde0a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSOP_SX4_R4S;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSOP_D4_I4D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101111111111010010000000000
  if ((bits & 0xbffffc00U) != 0xdffa400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSOP_D4_I4D;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractLD4_ASISDLSOP_DX4_R4D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001101111000001010010000000000
  if ((bits & 0xbfe0fc00U) != 0xde0a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4_ASISDLSOP_DX4_R4D;
  inst.iclass = InstName::LD4;
  return true;
}

static bool TryExtractSTRB_32B_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000001000000000100000000000
  if ((bits & 0xffe00c00U) != 0x38200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STRB_32B_LDST_REGOFF;
  inst.iclass = InstName::STRB;
  return true;
}

static bool TryExtractSTRB_32BL_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001110110000000000
  //   --------------------------------
  //   00111000001000000110100000000000
  if ((bits & 0xffe0ec00U) != 0x38206800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STRB_32BL_LDST_REGOFF;
  inst.iclass = InstName::STRB;
  return true;
}

static bool TryExtractUMAX_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000110010000000000
  if ((bits & 0xbf20fc00U) != 0x2e206400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMAX_ASIMDSAME_ONLY;
  inst.iclass = InstName::UMAX;
  return true;
}

static bool TryExtractCRC32B_32C_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x1ac04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t sz : 2;
      uint32_t C : 1;
      uint32_t opcode2 : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.C = static_cast<uint8_t>(enc.C);
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CRC32B_32C_DP_2SRC;
  inst.iclass = InstName::CRC32B;
  return true;
}

static bool TryExtractCRC32H_32C_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000100010000000000
  if ((bits & 0xffe0fc00U) != 0x1ac04400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t sz : 2;
      uint32_t C : 1;
      uint32_t opcode2 : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.C = static_cast<uint8_t>(enc.C);
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CRC32H_32C_DP_2SRC;
  inst.iclass = InstName::CRC32H;
  return true;
}

static bool TryExtractCRC32W_32C_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000100100000000000
  if ((bits & 0xffe0fc00U) != 0x1ac04800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t sz : 2;
      uint32_t C : 1;
      uint32_t opcode2 : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.C = static_cast<uint8_t>(enc.C);
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CRC32W_32C_DP_2SRC;
  inst.iclass = InstName::CRC32W;
  return true;
}

static bool TryExtractCRC32X_64C_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000100110000000000
  if ((bits & 0xffe0fc00U) != 0x9ac04c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t sz : 2;
      uint32_t C : 1;
      uint32_t opcode2 : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.C = static_cast<uint8_t>(enc.C);
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CRC32X_64C_DP_2SRC;
  inst.iclass = InstName::CRC32X;
  return true;
}

static bool TryExtractURSHR_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000000010010000000000
  if ((bits & 0xff80fc00U) != 0x7f002400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::URSHR_ASISDSHF_R;
  inst.iclass = InstName::URSHR;
  return true;
}

static bool TryExtractURSHR_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000000010010000000000
  if ((bits & 0xbf80fc00U) != 0x2f002400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::URSHR_ASIMDSHF_R;
  inst.iclass = InstName::URSHR;
  return true;
}

static bool TryExtractPRFM_P_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   11111001100000000000000000000000
  if ((bits & 0xffc00000U) != 0xf9800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::PRFM_P_LDST_POS;
  inst.iclass = InstName::PRFM;
  return true;
}

static bool TryExtractSUBS_32S_ADDSUB_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMP_SUBS_32S_ADDSUB_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   01110001000000000000000000000000
  if ((bits & 0xff000000U) != 0x71000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SUBS_32S_ADDSUB_IMM;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractSUBS_64S_ADDSUB_IMM(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMP_SUBS_64S_ADDSUB_IMM(inst, bits))
    return true;

  //   bits
  // & 11111111000000000000000000000000
  //   --------------------------------
  //   11110001000000000000000000000000
  if ((bits & 0xff000000U) != 0xf1000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SUBS_64S_ADDSUB_IMM;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractSUBS_32S_ADDSUB_EXT(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMP_SUBS_32S_ADDSUB_EXT(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   01101011001000000000000000000000
  if ((bits & 0xffe00000U) != 0x6b200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SUBS_32S_ADDSUB_EXT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractSUBS_64S_ADDSUB_EXT(InstData &inst, uint32_t bits) {
  if (false && TryExtractCMP_SUBS_64S_ADDSUB_EXT(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   11101011001000000000000000000000
  if ((bits & 0xffe00000U) != 0xeb200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SUBS_64S_ADDSUB_EXT;
  inst.iclass = InstName::SUBS;
  return true;
}

static bool TryExtractSYSL_RC_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111110000000000000000000
  //   --------------------------------
  //   11010101001010000000000000000000
  if ((bits & 0xfff80000U) != 0xd5280000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::SYSL_RC_SYSTEM;
  inst.iclass = InstName::SYSL;
  return true;
}

static bool TryExtractSMSUBL_64WA_DP_3SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractSMNEGL_SMSUBL_64WA_DP_3SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   10011011001000001000000000000000
  if ((bits & 0xffe08000U) != 0x9b208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SMSUBL_64WA_DP_3SRC;
  inst.iclass = InstName::SMSUBL;
  return true;
}

static bool TryExtractURSRA_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000000011010000000000
  if ((bits & 0xff80fc00U) != 0x7f003400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::URSRA_ASISDSHF_R;
  inst.iclass = InstName::URSRA;
  return true;
}

static bool TryExtractURSRA_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000000011010000000000
  if ((bits & 0xbf80fc00U) != 0x2f003400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::URSRA_ASIMDSHF_R;
  inst.iclass = InstName::URSRA;
  return true;
}

static bool TryExtractLDURH_32_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000010000000000000000000000
  if ((bits & 0xffe00c00U) != 0x78400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDURH_32_LDST_UNSCALED;
  inst.iclass = InstName::LDURH;
  return true;
}

static bool TryExtractSUB_32_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractNEG_SUB_32_ADDSUB_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   01001011000000000000000000000000
  if ((bits & 0xff200000U) != 0x4b000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::SUB_32_ADDSUB_SHIFT;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractSUB_64_ADDSUB_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractNEG_SUB_64_ADDSUB_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   11001011000000000000000000000000
  if ((bits & 0xff200000U) != 0xcb000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::SUB_64_ADDSUB_SHIFT;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractSRI_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000000100010000000000
  if ((bits & 0xff80fc00U) != 0x7f004400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SRI_ASISDSHF_R;
  inst.iclass = InstName::SRI;
  return true;
}

static bool TryExtractSRI_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000000100010000000000
  if ((bits & 0xbf80fc00U) != 0x2f004400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::SRI_ASIMDSHF_R;
  inst.iclass = InstName::SRI;
  return true;
}

static bool TryExtractUMAXP_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001010010000000000
  if ((bits & 0xbf20fc00U) != 0x2e20a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMAXP_ASIMDSAME_ONLY;
  inst.iclass = InstName::UMAXP;
  return true;
}

static bool TryExtractIC_SYS_CR_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111110001111000000000000
  //   --------------------------------
  //   11010101000010000111000000000000
  if ((bits & 0xfff8f000U) != 0xd5087000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::IC_SYS_CR_SYSTEM;
  inst.iclass = InstName::SYS;
  return true;
}

static bool TryExtractLDTRSH_32_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000110000000000100000000000
  if ((bits & 0xffe00c00U) != 0x78c00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDTRSH_32_LDST_UNPRIV;
  inst.iclass = InstName::LDTRSH;
  return true;
}

static bool TryExtractLDTRSH_64_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000100000000000100000000000
  if ((bits & 0xffe00c00U) != 0x78800800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDTRSH_64_LDST_UNPRIV;
  inst.iclass = InstName::LDTRSH;
  return true;
}

static bool TryExtractSADALP_ASIMDMISC_P(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000000110100000000000
  if ((bits & 0xbf3ffc00U) != 0xe206800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SADALP_ASIMDMISC_P;
  inst.iclass = InstName::SADALP;
  return true;
}

static bool TryExtractLDTRH_32_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000010000000000100000000000
  if ((bits & 0xffe00c00U) != 0x78400800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDTRH_32_LDST_UNPRIV;
  inst.iclass = InstName::LDTRH;
  return true;
}

static bool TryExtractSMAX_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000110010000000000
  if ((bits & 0xbf20fc00U) != 0xe206400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMAX_ASIMDSAME_ONLY;
  inst.iclass = InstName::SMAX;
  return true;
}

static bool TryExtractFCVTPU_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01111110111110011010100000000000
  if ((bits & 0xfffffc00U) != 0x7ef9a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTPU_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractFCVTPU_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110101000011010100000000000
  if ((bits & 0xffbffc00U) != 0x7ea1a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTPU_ASISDMISC_R;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractFCVTPU_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110111110011010100000000000
  if ((bits & 0xbffffc00U) != 0x2ef9a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTPU_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractFCVTPU_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110101000011010100000000000
  if ((bits & 0xbfbffc00U) != 0x2ea1a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTPU_ASIMDMISC_R;
  inst.iclass = InstName::FCVTPU;
  return true;
}

static bool TryExtractRET_64R_BRANCH_REG(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000011111
  //   --------------------------------
  //   11010110010111110000000000000000
  if ((bits & 0xfffffc1fU) != 0xd65f0000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t op4 : 5;
      uint32_t Rn : 5;
      uint32_t op3 : 6;
      uint32_t op2 : 5;
      uint32_t op : 2;
      uint32_t opc : 2;
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.op4 = static_cast<uint8_t>(enc.op4);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.op3 = static_cast<uint8_t>(enc.op3);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::RET_64R_BRANCH_REG;
  inst.iclass = InstName::RET;
  return true;
}

static bool TryExtractUQRSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000000101110000000000
  if ((bits & 0xff20fc00U) != 0x7e205c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQRSHL_ASISDSAME_ONLY;
  inst.iclass = InstName::UQRSHL;
  return true;
}

static bool TryExtractUQRSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000101110000000000
  if ((bits & 0xbf20fc00U) != 0x2e205c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UQRSHL_ASIMDSAME_ONLY;
  inst.iclass = InstName::UQRSHL;
  return true;
}

static bool TryExtractLDRB_32_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000010000000000010000000000
  if ((bits & 0xffe00c00U) != 0x38400400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRB_32_LDST_IMMPOST;
  inst.iclass = InstName::LDRB;
  return true;
}

static bool TryExtractLDRB_32_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000010000000000110000000000
  if ((bits & 0xffe00c00U) != 0x38400c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRB_32_LDST_IMMPRE;
  inst.iclass = InstName::LDRB;
  return true;
}

static bool TryExtractLDRB_32_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00111001010000000000000000000000
  if ((bits & 0xffc00000U) != 0x39400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRB_32_LDST_POS;
  inst.iclass = InstName::LDRB;
  return true;
}

static bool TryExtractFCVTXN_ASISDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110001000010110100000000000
  if ((bits & 0xffbffc00U) != 0x7e216800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCVTXN_ASISDMISC_N;
  inst.iclass = InstName::FCVTXN;
  return true;
}

static bool TryExtractFCVTXN_ASIMDMISC_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00101110001000010110100000000000
  if ((bits & 0xbfbffc00U) != 0x2e216800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCVTXN_ASIMDMISC_N;
  inst.iclass = InstName::FCVTXN;
  return true;
}

static bool TryExtractMSR_SI_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111110001111000000011111
  //   --------------------------------
  //   11010101000000000100000000011111
  if ((bits & 0xfff8f01fU) != 0xd500401fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::MSR_SI_SYSTEM;
  inst.iclass = InstName::MSR;
  return true;
}

static bool TryExtractUABDL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000111000000000000
  if ((bits & 0xbf20fc00U) != 0x2e207000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t op : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UABDL_ASIMDDIFF_L;
  inst.iclass = InstName::UABDL;
  return true;
}

static bool TryExtractMSR_SR_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111100000000000000000000
  //   --------------------------------
  //   11010101000100000000000000000000
  if ((bits & 0xfff00000U) != 0xd5100000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t o0 : 1;
      uint32_t _20 : 1;  // 1
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::MSR_SR_SYSTEM;
  inst.iclass = InstName::MSR;
  return true;
}

static bool TryExtractLDRH_32_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000011000000000100000000000
  if ((bits & 0xffe00c00U) != 0x78600800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRH_32_LDST_REGOFF;
  inst.iclass = InstName::LDRH;
  return true;
}

static bool TryExtractUQSHL_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000000111010000000000
  if ((bits & 0xff80fc00U) != 0x7f007400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UQSHL_ASISDSHF_R;
  inst.iclass = InstName::UQSHL;
  return true;
}

static bool TryExtractUQSHL_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000000111010000000000
  if ((bits & 0xbf80fc00U) != 0x2f007400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t op : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UQSHL_ASIMDSHF_R;
  inst.iclass = InstName::UQSHL;
  return true;
}

static bool TryExtractFMINNMP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110101100001100100000000000
  if ((bits & 0xfffffc00U) != 0x5eb0c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINNMP_ASISDPAIR_ONLY_H;
  inst.iclass = InstName::FMINNMP;
  return true;
}

static bool TryExtractFMINNMP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110101100001100100000000000
  if ((bits & 0xffbffc00U) != 0x7eb0c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINNMP_ASISDPAIR_ONLY_SD;
  inst.iclass = InstName::FMINNMP;
  return true;
}

static bool TryExtractUMADDL_64WA_DP_3SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractUMULL_UMADDL_64WA_DP_3SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   10011011101000000000000000000000
  if ((bits & 0xffe08000U) != 0x9ba00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::UMADDL_64WA_DP_3SRC;
  inst.iclass = InstName::UMADDL;
  return true;
}

static bool TryExtractFMOV_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000000100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FMOV_H_FLOATDP1;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000000100000000000000
  if ((bits & 0xfffffc00U) != 0x1e204000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FMOV_S_FLOATDP1;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractFMOV_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000000100000000000000
  if ((bits & 0xfffffc00U) != 0x1e604000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FMOV_D_FLOATDP1;
  inst.iclass = InstName::FMOV;
  return true;
}

static bool TryExtractSRHADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000001010000000000
  if ((bits & 0xbf20fc00U) != 0xe201400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SRHADD_ASIMDSAME_ONLY;
  inst.iclass = InstName::SRHADD;
  return true;
}

static bool TryExtractNGC_SBC_32_ADDSUB_CARRY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111111111100000
  //   --------------------------------
  //   01011010000000000000001111100000
  if ((bits & 0xffe0ffe0U) != 0x5a0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::NGC_SBC_32_ADDSUB_CARRY;
  inst.iclass = InstName::SBC;
  return true;
}

static bool TryExtractNGC_SBC_64_ADDSUB_CARRY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111111111100000
  //   --------------------------------
  //   11011010000000000000001111100000
  if ((bits & 0xffe0ffe0U) != 0xda0003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::NGC_SBC_64_ADDSUB_CARRY;
  inst.iclass = InstName::SBC;
  return true;
}

static bool TryExtractSBFIZ_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00010011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x13000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SBFIZ_SBFM_32M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractSBFIZ_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10010011010000000000000000000000
  if ((bits & 0xffc00000U) != 0x93400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SBFIZ_SBFM_64M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractUMSUBL_64WA_DP_3SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractUMNEGL_UMSUBL_64WA_DP_3SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   10011011101000001000000000000000
  if ((bits & 0xffe08000U) != 0x9ba08000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::UMSUBL_64WA_DP_3SRC;
  inst.iclass = InstName::UMSUBL;
  return true;
}

static bool TryExtractFCVTMU_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111100010000000000000000
  if ((bits & 0xfffffc00U) != 0x1ef10000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMU_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractFCVTMU_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111100010000000000000000
  if ((bits & 0xfffffc00U) != 0x9ef10000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMU_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractFCVTMU_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001100010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e310000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMU_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractFCVTMU_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001100010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e310000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMU_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractFCVTMU_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011100010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e710000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMU_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractFCVTMU_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011100010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e710000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTMU_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTMU;
  return true;
}

static bool TryExtractLDP_S_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101100110000000000000000000000
  if ((bits & 0xffc00000U) != 0x2cc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_S_LDSTPAIR_POST;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_D_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101100110000000000000000000000
  if ((bits & 0xffc00000U) != 0x6cc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_D_LDSTPAIR_POST;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_Q_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101100110000000000000000000000
  if ((bits & 0xffc00000U) != 0xacc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_Q_LDSTPAIR_POST;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_S_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101101110000000000000000000000
  if ((bits & 0xffc00000U) != 0x2dc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_S_LDSTPAIR_PRE;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_D_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101101110000000000000000000000
  if ((bits & 0xffc00000U) != 0x6dc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_D_LDSTPAIR_PRE;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_Q_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101101110000000000000000000000
  if ((bits & 0xffc00000U) != 0xadc00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_Q_LDSTPAIR_PRE;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_S_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101101010000000000000000000000
  if ((bits & 0xffc00000U) != 0x2d400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_S_LDSTPAIR_OFF;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_D_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01101101010000000000000000000000
  if ((bits & 0xffc00000U) != 0x6d400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_D_LDSTPAIR_OFF;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractLDP_Q_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101101010000000000000000000000
  if ((bits & 0xffc00000U) != 0xad400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::LDP_Q_LDSTPAIR_OFF;
  inst.iclass = InstName::LDP;
  return true;
}

static bool TryExtractSBC_32_ADDSUB_CARRY(InstData &inst, uint32_t bits) {
  if (false && TryExtractNGC_SBC_32_ADDSUB_CARRY(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011010000000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x5a000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SBC_32_ADDSUB_CARRY;
  inst.iclass = InstName::SBC;
  return true;
}

static bool TryExtractSBC_64_ADDSUB_CARRY(InstData &inst, uint32_t bits) {
  if (false && TryExtractNGC_SBC_64_ADDSUB_CARRY(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11011010000000000000000000000000
  if ((bits & 0xffe0fc00U) != 0xda000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SBC_64_ADDSUB_CARRY;
  inst.iclass = InstName::SBC;
  return true;
}

static bool TryExtractFCVTZU_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111110010000000000000000
  if ((bits & 0xfffffc00U) != 0x1ef90000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111110010000000000000000
  if ((bits & 0xfffffc00U) != 0x9ef90000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001110010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e390000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001110010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e390000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011110010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e790000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractFCVTZU_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011110010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e790000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZU_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTZU;
  return true;
}

static bool TryExtractCINV_CSINV_32_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01011010100000000000000000000000
  if ((bits & 0xffe00c00U) != 0x5a800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  if (!(inst.Rm != 0x1f))
    return false;
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  if (!(inst.Rn != 0x1f))
    return false;
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CINV_CSINV_32_CONDSEL;
  inst.iclass = InstName::CSINV;
  return true;
}

static bool TryExtractCINV_CSINV_64_CONDSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11011010100000000000000000000000
  if ((bits & 0xffe00c00U) != 0xda800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  if (!(inst.cond != 0xe))
    return false;
  if (!(inst.cond != 0xf))
    return false;
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  if (!(inst.Rm != 0x1f))
    return false;
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  if (!(inst.Rn != 0x1f))
    return false;
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CINV_CSINV_64_CONDSEL;
  inst.iclass = InstName::CSINV;
  return true;
}

static bool TryExtractSTR_32_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000001000000000100000000000
  if ((bits & 0xffe00c00U) != 0xb8200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_32_LDST_REGOFF;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_64_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000001000000000100000000000
  if ((bits & 0xffe00c00U) != 0xf8200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_64_LDST_REGOFF;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractFDIV_H_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110111000000001100000000000
  if ((bits & 0xffe0fc00U) != 0x1ee01800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FDIV_H_FLOATDP2;
  inst.iclass = InstName::FDIV;
  return true;
}

static bool TryExtractFDIV_S_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110001000000001100000000000
  if ((bits & 0xffe0fc00U) != 0x1e201800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FDIV_S_FLOATDP2;
  inst.iclass = InstName::FDIV;
  return true;
}

static bool TryExtractFDIV_D_FLOATDP2(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011110011000000001100000000000
  if ((bits & 0xffe0fc00U) != 0x1e601800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FDIV_D_FLOATDP2;
  inst.iclass = InstName::FDIV;
  return true;
}

static bool TryExtractURECPE_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000011100100000000000
  if ((bits & 0xbfbffc00U) != 0xea1c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::URECPE_ASIMDMISC_R;
  inst.iclass = InstName::URECPE;
  return true;
}

static bool TryExtractISB_BI_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111000011111111
  //   --------------------------------
  //   11010101000000110011000011011111
  if ((bits & 0xfffff0ffU) != 0xd50330dfU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t opc : 2;
      uint32_t _7 : 1;  // 1
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::ISB_BI_SYSTEM;
  inst.iclass = InstName::ISB;
  return true;
}

static bool TryExtractRSUBHN_ASIMDDIFF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000110000000000000
  if ((bits & 0xbf20fc00U) != 0x2e206000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::RSUBHN_ASIMDDIFF_N;
  inst.iclass = InstName::RSUBHN;
  return true;
}

static bool TryExtractSMULL_ASIMDELEM_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00001111000000001010000000000000
  if ((bits & 0xbf00f400U) != 0xf00a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SMULL_ASIMDELEM_L;
  inst.iclass = InstName::SMULL;
  return true;
}

static bool TryExtractSUQADD_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01011110001000000011100000000000
  if ((bits & 0xff3ffc00U) != 0x5e203800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SUQADD_ASISDMISC_R;
  inst.iclass = InstName::SUQADD;
  return true;
}

static bool TryExtractSUQADD_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000000011100000000000
  if ((bits & 0xbf3ffc00U) != 0xe203800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SUQADD_ASIMDMISC_R;
  inst.iclass = InstName::SUQADD;
  return true;
}

static bool TryExtractLDRSH_32_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000111000000000100000000000
  if ((bits & 0xffe00c00U) != 0x78e00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSH_32_LDST_REGOFF;
  inst.iclass = InstName::LDRSH;
  return true;
}

static bool TryExtractLDRSH_64_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111000101000000000100000000000
  if ((bits & 0xffe00c00U) != 0x78a00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSH_64_LDST_REGOFF;
  inst.iclass = InstName::LDRSH;
  return true;
}

static bool TryExtractADRP_ONLY_PCRELADDR(InstData &inst, uint32_t bits) {

  //   bits
  // & 10011111000000000000000000000000
  //   --------------------------------
  //   10010000000000000000000000000000
  if ((bits & 0x9f000000U) != 0x90000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t immhi : 19;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t immlo : 2;
      uint32_t op : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.immlo.uimm = static_cast<uint64_t>(enc.immlo);
  inst.immhi.uimm = static_cast<uint64_t>(enc.immhi);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.immhi_immlo.uimm = static_cast<uint64_t>(inst.immhi.uimm);
  inst.immhi_immlo.uimm <<= static_cast<uint64_t>(2U);
  inst.immhi_immlo.uimm |= static_cast<uint64_t>(inst.immlo.uimm);
  inst.iform = InstForm::ADRP_ONLY_PCRELADDR;
  inst.iclass = InstName::ADRP;
  return true;
}

static bool TryExtractDUP_ASIMDINS_DR_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000000110000000000
  if ((bits & 0xbfe0fc00U) != 0xe000c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::DUP_ASIMDINS_DR_R;
  inst.iclass = InstName::DUP;
  return true;
}

static bool TryExtractFABS_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000001100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee0c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FABS_H_FLOATDP1;
  inst.iclass = InstName::FABS;
  return true;
}

static bool TryExtractFABS_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000001100000000000000
  if ((bits & 0xfffffc00U) != 0x1e20c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FABS_S_FLOATDP1;
  inst.iclass = InstName::FABS;
  return true;
}

static bool TryExtractFABS_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000001100000000000000
  if ((bits & 0xfffffc00U) != 0x1e60c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FABS_D_FLOATDP1;
  inst.iclass = InstName::FABS;
  return true;
}

static bool TryExtractREV32_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000000000100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o0 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::REV32_ASIMDMISC_R;
  inst.iclass = InstName::REV32;
  return true;
}

static bool TryExtractAT_SYS_CR_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111110001111111000000000
  //   --------------------------------
  //   11010101000010000111100000000000
  if ((bits & 0xfff8fe00U) != 0xd5087800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::AT_SYS_CR_SYSTEM;
  inst.iclass = InstName::SYS;
  return true;
}

static bool TryExtractUQRSHRN_ASISDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000001001110000000000
  if ((bits & 0xff80fc00U) != 0x7f009c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UQRSHRN_ASISDSHF_N;
  inst.iclass = InstName::UQRSHRN;
  return true;
}

static bool TryExtractUQRSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000001001110000000000
  if ((bits & 0xbf80fc00U) != 0x2f009c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UQRSHRN_ASIMDSHF_N;
  inst.iclass = InstName::UQRSHRN;
  return true;
}

static bool TryExtractUBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {
  if (false && TryExtractUXTH_UBFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractUXTB_UBFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractLSR_UBFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractLSL_UBFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractUBFIZ_UBFM_32M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractUBFX_UBFM_32M_BITFIELD(inst, bits))
    return true;

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   01010011000000000000000000000000
  if ((bits & 0xffc00000U) != 0x53000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::UBFM_32M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractUBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {
  if (false && TryExtractLSR_UBFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractUBFX_UBFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractUBFIZ_UBFM_64M_BITFIELD(inst, bits))
    return true;
  if (false && TryExtractLSL_UBFM_64M_BITFIELD(inst, bits))
    return true;

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   11010011010000000000000000000000
  if ((bits & 0xffc00000U) != 0xd3400000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::UBFM_64M_BITFIELD;
  inst.iclass = InstName::UBFM;
  return true;
}

static bool TryExtractSTNP_32_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101000000000000000000000000000
  if ((bits & 0xffc00000U) != 0x28000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STNP_32_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::STNP;
  return true;
}

static bool TryExtractSTNP_64_LDSTNAPAIR_OFFS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101000000000000000000000000000
  if ((bits & 0xffc00000U) != 0xa8000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STNP_64_LDSTNAPAIR_OFFS;
  inst.iclass = InstName::STNP;
  return true;
}

static bool TryExtractLDARB_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00001000110111111111110000000000
  if ((bits & 0xfffffc00U) != 0x8dffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDARB_LR32_LDSTEXCL;
  inst.iclass = InstName::LDARB;
  return true;
}

static bool TryExtractSRSRA_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000000011010000000000
  if ((bits & 0xff80fc00U) != 0x5f003400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SRSRA_ASISDSHF_R;
  inst.iclass = InstName::SRSRA;
  return true;
}

static bool TryExtractSRSRA_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000000011010000000000
  if ((bits & 0xbf80fc00U) != 0xf003400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SRSRA_ASIMDSHF_R;
  inst.iclass = InstName::SRSRA;
  return true;
}

static bool TryExtractCMGE_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000000011110000000000
  if ((bits & 0xff20fc00U) != 0x5e203c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t eq : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.eq = static_cast<uint8_t>(enc.eq);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMGE_ASISDSAME_ONLY;
  inst.iclass = InstName::CMGE;
  return true;
}

static bool TryExtractCMGE_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000011110000000000
  if ((bits & 0xbf20fc00U) != 0xe203c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t eq : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.eq = static_cast<uint8_t>(enc.eq);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMGE_ASIMDSAME_ONLY;
  inst.iclass = InstName::CMGE;
  return true;
}

static bool TryExtractFADD_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110010000000001010000000000
  if ((bits & 0xbfe0fc00U) != 0xe401400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FADD_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FADD;
  return true;
}

static bool TryExtractFADD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110001000001101010000000000
  if ((bits & 0xbfa0fc00U) != 0xe20d400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FADD_ASIMDSAME_ONLY;
  inst.iclass = InstName::FADD;
  return true;
}

static bool TryExtractSQRDMLAH_ASISDSAME2_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110000000001000010000000000
  if ((bits & 0xff20fc00U) != 0x7e008400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMLAH_ASISDSAME2_ONLY;
  inst.iclass = InstName::SQRDMLAH;
  return true;
}

static bool TryExtractSQRDMLAH_ASIMDSAME2_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110000000001000010000000000
  if ((bits & 0xbf20fc00U) != 0x2e008400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQRDMLAH_ASIMDSAME2_ONLY;
  inst.iclass = InstName::SQRDMLAH;
  return true;
}

static bool TryExtractORN_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110111000000001110000000000
  if ((bits & 0xbfe0fc00U) != 0xee01c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::ORN_ASIMDSAME_ONLY;
  inst.iclass = InstName::ORN;
  return true;
}

static bool TryExtractSTSETB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000001000000011000000011111
  if ((bits & 0xffe0fc1fU) != 0x3820301fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSETB_32S_MEMOP;
  inst.iclass = InstName::STSETB;
  return true;
}

static bool TryExtractSTSETLB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000011000000011000000011111
  if ((bits & 0xffe0fc1fU) != 0x3860301fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSETLB_32S_MEMOP;
  inst.iclass = InstName::STSETLB;
  return true;
}

static bool TryExtractADC_32_ADDSUB_CARRY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010000000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x1a000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADC_32_ADDSUB_CARRY;
  inst.iclass = InstName::ADC;
  return true;
}

static bool TryExtractADC_64_ADDSUB_CARRY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010000000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x9a000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t opcode2 : 6;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::ADC_64_ADDSUB_CARRY;
  inst.iclass = InstName::ADC;
  return true;
}

static bool TryExtractBFC_BFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000001111100000
  //   --------------------------------
  //   00110011000000000000001111100000
  if ((bits & 0xffc003e0U) != 0x330003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::BFC_BFM_32M_BITFIELD;
  inst.iclass = InstName::BFM;
  return true;
}

static bool TryExtractBFC_BFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000001111100000
  //   --------------------------------
  //   10110011010000000000001111100000
  if ((bits & 0xffc003e0U) != 0xb34003e0U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::BFC_BFM_64M_BITFIELD;
  inst.iclass = InstName::BFM;
  return true;
}

static bool TryExtractLD2R_ASISDLSO_R2(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001101011000001100000000000000
  if ((bits & 0xbffff000U) != 0xd60c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2R_ASISDLSO_R2;
  inst.iclass = InstName::LD2R;
  return true;
}

static bool TryExtractLD2R_ASISDLSOP_R2_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001101111111111100000000000000
  if ((bits & 0xbffff000U) != 0xdffc000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2R_ASISDLSOP_R2_I;
  inst.iclass = InstName::LD2R;
  return true;
}

static bool TryExtractLD2R_ASISDLSOP_RX2_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001101111000001100000000000000
  if ((bits & 0xbfe0f000U) != 0xde0c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD2R_ASISDLSOP_RX2_R;
  inst.iclass = InstName::LD2R;
  return true;
}

static bool TryExtractCSINC_32_CONDSEL(InstData &inst, uint32_t bits) {
  if (false && TryExtractCSET_CSINC_32_CONDSEL(inst, bits))
    return true;
  if (false && TryExtractCINC_CSINC_32_CONDSEL(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00011010100000000000010000000000
  if ((bits & 0xffe00c00U) != 0x1a800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSINC_32_CONDSEL;
  inst.iclass = InstName::CSINC;
  return true;
}

static bool TryExtractCSINC_64_CONDSEL(InstData &inst, uint32_t bits) {
  if (false && TryExtractCSET_CSINC_64_CONDSEL(inst, bits))
    return true;
  if (false && TryExtractCINC_CSINC_64_CONDSEL(inst, bits))
    return true;

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10011010100000000000010000000000
  if ((bits & 0xffe00c00U) != 0x9a800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o2 : 1;
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CSINC_64_CONDSEL;
  inst.iclass = InstName::CSINC;
  return true;
}

static bool TryExtractFMLS_ASISDELEM_RH_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000001111010000000000
  //   --------------------------------
  //   01011111000000000101000000000000
  if ((bits & 0xffc0f400U) != 0x5f005000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FMLS_ASISDELEM_RH_H;
  inst.iclass = InstName::FMLS;
  return true;
}

static bool TryExtractFMLS_ASISDELEM_R_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111010000000000
  //   --------------------------------
  //   01011111100000000101000000000000
  if ((bits & 0xff80f400U) != 0x5f805000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.iform = InstForm::FMLS_ASISDELEM_R_SD;
  inst.iclass = InstName::FMLS;
  return true;
}

static bool TryExtractFMLS_ASIMDELEM_RH_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111110000001111010000000000
  //   --------------------------------
  //   00001111000000000101000000000000
  if ((bits & 0xbfc0f400U) != 0xf005000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FMLS_ASIMDELEM_RH_H;
  inst.iclass = InstName::FMLS;
  return true;
}

static bool TryExtractFMLS_ASIMDELEM_R_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111010000000000
  //   --------------------------------
  //   00001111100000000101000000000000
  if ((bits & 0xbf80f400U) != 0xf805000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t o2 : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.iform = InstForm::FMLS_ASIMDELEM_R_SD;
  inst.iclass = InstName::FMLS;
  return true;
}

static bool TryExtractSHA256H2_QQV_CRYPTOSHA3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110000000000101000000000000
  if ((bits & 0xffe0fc00U) != 0x5e005000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t P : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.P = static_cast<uint8_t>(enc.P);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.iform = InstForm::SHA256H2_QQV_CRYPTOSHA3;
  inst.iclass = InstName::SHA256H2;
  return true;
}

static bool TryExtractRBIT_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00101110011000000101100000000000
  if ((bits & 0xbffffc00U) != 0x2e605800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::RBIT_ASIMDMISC_R;
  inst.iclass = InstName::RBIT;
  return true;
}

static bool TryExtractRSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000001000110000000000
  if ((bits & 0xbf80fc00U) != 0xf008c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::RSHRN_ASIMDSHF_N;
  inst.iclass = InstName::RSHRN;
  return true;
}

static bool TryExtractUMOV_ASIMDINS_W_W(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_UMOV_ASIMDINS_W_W(inst, bits))
    return true;

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00001110000000000011110000000000
  if ((bits & 0xffe0fc00U) != 0xe003c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UMOV_ASIMDINS_W_W;
  inst.iclass = InstName::UMOV;
  return true;
}

static bool TryExtractUMOV_ASIMDINS_X_X(InstData &inst, uint32_t bits) {
  if (false && TryExtractMOV_UMOV_ASIMDINS_X_X(inst, bits))
    return true;

  //   bits
  // & 11111111111011111111110000000000
  //   --------------------------------
  //   01001110000010000011110000000000
  if ((bits & 0xffeffc00U) != 0x4e083c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t imm5 : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t op : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm5.uimm = static_cast<uint64_t>(enc.imm5);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UMOV_ASIMDINS_X_X;
  inst.iclass = InstName::UMOV;
  return true;
}

static bool TryExtractFCVTZS_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111110000000000000000000
  if ((bits & 0xfffffc00U) != 0x1ef80000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111110000000000000000000
  if ((bits & 0xfffffc00U) != 0x9ef80000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001110000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e380000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001110000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e380000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011110000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e780000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractFCVTZS_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011110000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e780000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTZS_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTZS;
  return true;
}

static bool TryExtractNOP_HI_SYSTEM(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111111111111111
  //   --------------------------------
  //   11010101000000110010000000011111
  if ((bits & 0xffffffffU) != 0xd503201fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::NOP_HI_SYSTEM;
  inst.iclass = InstName::NOP;
  return true;
}

static bool TryExtractFCVTMS_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110011110011011100000000000
  if ((bits & 0xfffffc00U) != 0x5e79b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTMS_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractFCVTMS_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110001000011011100000000000
  if ((bits & 0xffbffc00U) != 0x5e21b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTMS_ASISDMISC_R;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractFCVTMS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110011110011011100000000000
  if ((bits & 0xbffffc00U) != 0xe79b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTMS_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractFCVTMS_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110001000011011100000000000
  if ((bits & 0xbfbffc00U) != 0xe21b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTMS_ASIMDMISC_R;
  inst.iclass = InstName::FCVTMS;
  return true;
}

static bool TryExtractFRINTA_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111001100100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee64000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTA_H_FLOATDP1;
  inst.iclass = InstName::FRINTA;
  return true;
}

static bool TryExtractFRINTA_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001001100100000000000000
  if ((bits & 0xfffffc00U) != 0x1e264000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTA_S_FLOATDP1;
  inst.iclass = InstName::FRINTA;
  return true;
}

static bool TryExtractFRINTA_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011001100100000000000000
  if ((bits & 0xfffffc00U) != 0x1e664000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t rmode : 3;
      uint32_t _18 : 1;  // 1
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FRINTA_D_FLOATDP1;
  inst.iclass = InstName::FRINTA;
  return true;
}

static bool TryExtractFCSEL_H_FLOATSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00011110111000000000110000000000
  if ((bits & 0xffe00c00U) != 0x1ee00c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FCSEL_H_FLOATSEL;
  inst.iclass = InstName::FCSEL;
  return true;
}

static bool TryExtractFCSEL_S_FLOATSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00011110001000000000110000000000
  if ((bits & 0xffe00c00U) != 0x1e200c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FCSEL_S_FLOATSEL;
  inst.iclass = InstName::FCSEL;
  return true;
}

static bool TryExtractFCSEL_D_FLOATSEL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00011110011000000000110000000000
  if ((bits & 0xffe00c00U) != 0x1e600c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FCSEL_D_FLOATSEL;
  inst.iclass = InstName::FCSEL;
  return true;
}

static bool TryExtractSUBHN_ASIMDDIFF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000110000000000000
  if ((bits & 0xbf20fc00U) != 0xe206000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SUBHN_ASIMDDIFF_N;
  inst.iclass = InstName::SUBHN;
  return true;
}

static bool TryExtractLDRSB_32_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000110000000000010000000000
  if ((bits & 0xffe00c00U) != 0x38c00400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_32_LDST_IMMPOST;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractLDRSB_64_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000100000000000010000000000
  if ((bits & 0xffe00c00U) != 0x38800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_64_LDST_IMMPOST;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractLDRSB_32_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000110000000000110000000000
  if ((bits & 0xffe00c00U) != 0x38c00c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_32_LDST_IMMPRE;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractLDRSB_64_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000100000000000110000000000
  if ((bits & 0xffe00c00U) != 0x38800c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_64_LDST_IMMPRE;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractLDRSB_32_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00111001110000000000000000000000
  if ((bits & 0xffc00000U) != 0x39c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_32_LDST_POS;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractLDRSB_64_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00111001100000000000000000000000
  if ((bits & 0xffc00000U) != 0x39800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_64_LDST_POS;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractFACGT_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111110110000000010110000000000
  if ((bits & 0xffe0fc00U) != 0x7ec02c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FACGT_ASISDSAMEFP16_ONLY;
  inst.iclass = InstName::FACGT;
  return true;
}

static bool TryExtractFACGT_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101000001111110000000000
  //   --------------------------------
  //   01111110101000001110110000000000
  if ((bits & 0xffa0fc00U) != 0x7ea0ec00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FACGT_ASISDSAME_ONLY;
  inst.iclass = InstName::FACGT;
  return true;
}

static bool TryExtractFACGT_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110110000000010110000000000
  if ((bits & 0xbfe0fc00U) != 0x2ec02c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FACGT_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FACGT;
  return true;
}

static bool TryExtractFACGT_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110101000001110110000000000
  if ((bits & 0xbfa0fc00U) != 0x2ea0ec00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t ac : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t E : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.ac = static_cast<uint8_t>(enc.ac);
  inst.E = static_cast<uint8_t>(enc.E);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FACGT_ASIMDSAME_ONLY;
  inst.iclass = InstName::FACGT;
  return true;
}

static bool TryExtractNEG_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01111110001000001011100000000000
  if ((bits & 0xff3ffc00U) != 0x7e20b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::NEG_ASISDMISC_R;
  inst.iclass = InstName::NEG;
  return true;
}

static bool TryExtractNEG_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001000001011100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e20b800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::NEG_ASIMDMISC_R;
  inst.iclass = InstName::NEG;
  return true;
}

static bool TryExtractUMLAL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001000000000000000
  if ((bits & 0xbf20fc00U) != 0x2e208000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMLAL_ASIMDDIFF_L;
  inst.iclass = InstName::UMLAL;
  return true;
}

static bool TryExtractREV16_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000000001100000000000
  if ((bits & 0xbf3ffc00U) != 0xe201800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o0 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::REV16_ASIMDMISC_R;
  inst.iclass = InstName::REV16;
  return true;
}

static bool TryExtractPMULL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001110000000000000
  if ((bits & 0xbf20fc00U) != 0xe20e000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::PMULL_ASIMDDIFF_L;
  inst.iclass = InstName::PMULL;
  return true;
}

static bool TryExtractFMLS_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110110000000000110000000000
  if ((bits & 0xbfe0fc00U) != 0xec00c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FMLS_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMLS;
  return true;
}

static bool TryExtractFMLS_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110101000001100110000000000
  if ((bits & 0xbfa0fc00U) != 0xea0cc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t op : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FMLS_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMLS;
  return true;
}

static bool TryExtractEOR_32_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   01001010000000000000000000000000
  if ((bits & 0xff200000U) != 0x4a000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::EOR_32_LOG_SHIFT;
  inst.iclass = InstName::EOR;
  return true;
}

static bool TryExtractEOR_64_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   11001010000000000000000000000000
  if ((bits & 0xff200000U) != 0xca000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::EOR_64_LOG_SHIFT;
  inst.iclass = InstName::EOR;
  return true;
}

static bool TryExtractLDSMAXA_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000101000000100000000000000
  if ((bits & 0xffe0fc00U) != 0xb8a04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXA_32_MEMOP;
  inst.iclass = InstName::LDSMAXA;
  return true;
}

static bool TryExtractLDSMAXAL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000111000000100000000000000
  if ((bits & 0xffe0fc00U) != 0xb8e04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXAL_32_MEMOP;
  inst.iclass = InstName::LDSMAXAL;
  return true;
}

static bool TryExtractLDSMAX_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000001000000100000000000000
  if ((bits & 0xffe0fc00U) != 0xb8204000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAX_32_MEMOP;
  inst.iclass = InstName::LDSMAX;
  return true;
}

static bool TryExtractLDSMAXL_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10111000011000000100000000000000
  if ((bits & 0xffe0fc00U) != 0xb8604000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXL_32_MEMOP;
  inst.iclass = InstName::LDSMAXL;
  return true;
}

static bool TryExtractLDSMAXA_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000101000000100000000000000
  if ((bits & 0xffe0fc00U) != 0xf8a04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXA_64_MEMOP;
  inst.iclass = InstName::LDSMAXA;
  return true;
}

static bool TryExtractLDSMAXAL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000111000000100000000000000
  if ((bits & 0xffe0fc00U) != 0xf8e04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXAL_64_MEMOP;
  inst.iclass = InstName::LDSMAXAL;
  return true;
}

static bool TryExtractLDSMAX_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000001000000100000000000000
  if ((bits & 0xffe0fc00U) != 0xf8204000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAX_64_MEMOP;
  inst.iclass = InstName::LDSMAX;
  return true;
}

static bool TryExtractLDSMAXL_64_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   11111000011000000100000000000000
  if ((bits & 0xffe0fc00U) != 0xf8604000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXL_64_MEMOP;
  inst.iclass = InstName::LDSMAXL;
  return true;
}

static bool TryExtractSYS_CR_SYSTEM(InstData &inst, uint32_t bits) {
  if (false && TryExtractAT_SYS_CR_SYSTEM(inst, bits))
    return true;
  if (false && TryExtractTLBI_SYS_CR_SYSTEM(inst, bits))
    return true;
  if (TryExtractDC_SYS_CR_SYSTEM(inst, bits))
    return true;
  if (false && TryExtractIC_SYS_CR_SYSTEM(inst, bits))
    return true;

  //   bits
  // & 11111111111110000000000000000000
  //   --------------------------------
  //   11010101000010000000000000000000
  if ((bits & 0xfff80000U) != 0xd5080000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t op2 : 3;
      uint32_t CRm : 4;
      uint32_t CRn : 4;
      uint32_t op1 : 3;
      uint32_t op0 : 2;
      uint32_t L : 1;
      uint32_t _22 : 1;  // 0
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 1
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.op0 = static_cast<uint8_t>(enc.op0);
  inst.op1 = static_cast<uint8_t>(enc.op1);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.CRn = static_cast<uint8_t>(enc.CRn);
  inst.CRm = static_cast<uint8_t>(enc.CRm);
  inst.iform = InstForm::SYS_CR_SYSTEM;
  inst.iclass = InstName::SYS;
  return true;
}

static bool TryExtractSQABS_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001111111111110000000000
  //   --------------------------------
  //   01011110001000000111100000000000
  if ((bits & 0xff3ffc00U) != 0x5e207800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQABS_ASISDMISC_R;
  inst.iclass = InstName::SQABS;
  return true;
}

static bool TryExtractSQABS_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00001110001000000111100000000000
  if ((bits & 0xbf3ffc00U) != 0xe207800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQABS_ASIMDMISC_R;
  inst.iclass = InstName::SQABS;
  return true;
}

static bool TryExtractLDAR_LR32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10001000110111111111110000000000
  if ((bits & 0xfffffc00U) != 0x88dffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDAR_LR32_LDSTEXCL;
  inst.iclass = InstName::LDAR;
  return true;
}

static bool TryExtractLDAR_LR64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11001000110111111111110000000000
  if ((bits & 0xfffffc00U) != 0xc8dffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::LDAR_LR64_LDSTEXCL;
  inst.iclass = InstName::LDAR;
  return true;
}

static bool TryExtractSTADDH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000001000000000000000011111
  if ((bits & 0xffe0fc1fU) != 0x7820001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STADDH_32S_MEMOP;
  inst.iclass = InstName::STADDH;
  return true;
}

static bool TryExtractSTADDLH_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   01111000011000000000000000011111
  if ((bits & 0xffe0fc1fU) != 0x7860001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STADDLH_32S_MEMOP;
  inst.iclass = InstName::STADDLH;
  return true;
}

static bool TryExtractLDRSW_64_LDST_IMMPOST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000100000000000010000000000
  if ((bits & 0xffe00c00U) != 0xb8800400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSW_64_LDST_IMMPOST;
  inst.iclass = InstName::LDRSW;
  return true;
}

static bool TryExtractLDRSW_64_LDST_IMMPRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111000100000000000110000000000
  if ((bits & 0xffe00c00U) != 0xb8800c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSW_64_LDST_IMMPRE;
  inst.iclass = InstName::LDRSW;
  return true;
}

static bool TryExtractLDRSW_64_LDST_POS(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10111001100000000000000000000000
  if ((bits & 0xffc00000U) != 0xb9800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t imm12 : 12;
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.imm12.uimm = static_cast<uint64_t>(enc.imm12);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSW_64_LDST_POS;
  inst.iclass = InstName::LDRSW;
  return true;
}

static bool TryExtractFCVTAS_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110011110011100100000000000
  if ((bits & 0xfffffc00U) != 0x5e79c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t size : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FCVTAS_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractFCVTAS_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110001000011100100000000000
  if ((bits & 0xffbffc00U) != 0x5e21c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCVTAS_ASISDMISC_R;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractFCVTAS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110011110011100100000000000
  if ((bits & 0xbffffc00U) != 0xe79c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FCVTAS_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractFCVTAS_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110001000011100100000000000
  if ((bits & 0xbfbffc00U) != 0xe21c800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FCVTAS_ASIMDMISC_R;
  inst.iclass = InstName::FCVTAS;
  return true;
}

static bool TryExtractUQSHRN_ASISDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000001001010000000000
  if ((bits & 0xff80fc00U) != 0x7f009400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UQSHRN_ASISDSHF_N;
  inst.iclass = InstName::UQSHRN;
  return true;
}

static bool TryExtractUQSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000001001010000000000
  if ((bits & 0xbf80fc00U) != 0x2f009400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UQSHRN_ASIMDSHF_N;
  inst.iclass = InstName::UQSHRN;
  return true;
}

static bool TryExtractEXT_ASIMDEXT_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001000010000000000
  //   --------------------------------
  //   00101110000000000000000000000000
  if ((bits & 0xbfe08400U) != 0x2e000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t imm4 : 4;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t op2 : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.op2 = static_cast<uint8_t>(enc.op2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.iform = InstForm::EXT_ASIMDEXT_ONLY;
  inst.iclass = InstName::EXT;
  return true;
}

static bool TryExtractUSHL_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01111110001000000100010000000000
  if ((bits & 0xff20fc00U) != 0x7e204400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::USHL_ASISDSAME_ONLY;
  inst.iclass = InstName::USHL;
  return true;
}

static bool TryExtractUSHL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000100010000000000
  if ((bits & 0xbf20fc00U) != 0x2e204400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t S : 1;
      uint32_t R : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::USHL_ASIMDSAME_ONLY;
  inst.iclass = InstName::USHL;
  return true;
}

static bool TryExtractFADDP_ASISDPAIR_ONLY_H(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110001100001101100000000000
  if ((bits & 0xfffffc00U) != 0x5e30d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FADDP_ASISDPAIR_ONLY_H;
  inst.iclass = InstName::FADDP;
  return true;
}

static bool TryExtractFADDP_ASISDPAIR_ONLY_SD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01111110001100001101100000000000
  if ((bits & 0xffbffc00U) != 0x7e30d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FADDP_ASISDPAIR_ONLY_SD;
  inst.iclass = InstName::FADDP;
  return true;
}

static bool TryExtractSSHR_ASISDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000000000010000000000
  if ((bits & 0xff80fc00U) != 0x5f000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SSHR_ASISDSHF_R;
  inst.iclass = InstName::SSHR;
  return true;
}

static bool TryExtractSSHR_ASIMDSHF_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000000000010000000000
  if ((bits & 0xbf80fc00U) != 0xf000400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t o0 : 1;
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SSHR_ASIMDSHF_R;
  inst.iclass = InstName::SSHR;
  return true;
}

static bool TryExtractSHSUB_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000000010010000000000
  if ((bits & 0xbf20fc00U) != 0xe202400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHSUB_ASIMDSAME_ONLY;
  inst.iclass = InstName::SHSUB;
  return true;
}

static bool TryExtractCMN_ADDS_32S_ADDSUB_EXT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   00101011001000000000000000011111
  if ((bits & 0xffe0001fU) != 0x2b20001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMN_ADDS_32S_ADDSUB_EXT;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractCMN_ADDS_64S_ADDSUB_EXT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000011111
  //   --------------------------------
  //   10101011001000000000000000011111
  if ((bits & 0xffe0001fU) != 0xab20001fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::CMN_ADDS_64S_ADDSUB_EXT;
  inst.iclass = InstName::ADDS;
  return true;
}

static bool TryExtractFMINNM_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001110110000000000010000000000
  if ((bits & 0xbfe0fc00U) != 0xec00400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t Op3 : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Op3 = static_cast<uint8_t>(enc.Op3);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FMINNM_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FMINNM;
  return true;
}

static bool TryExtractFMINNM_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00001110101000001100010000000000
  if ((bits & 0xbfa0fc00U) != 0xea0c400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o1 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FMINNM_ASIMDSAME_ONLY;
  inst.iclass = InstName::FMINNM;
  return true;
}

static bool TryExtractUMLSL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000001010000000000000
  if ((bits & 0xbf20fc00U) != 0x2e20a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UMLSL_ASIMDDIFF_L;
  inst.iclass = InstName::UMLSL;
  return true;
}

static bool TryExtractUSHLL_ASIMDSHF_L(InstData &inst, uint32_t bits) {
  if (false && TryExtractUXTL_USHLL_ASIMDSHF_L(inst, bits))
    return true;

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000001010010000000000
  if ((bits & 0xbf80fc00U) != 0x2f00a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::USHLL_ASIMDSHF_L;
  inst.iclass = InstName::USHLL;
  return true;
}

static bool TryExtractSTLR_SL32_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10001000100111111111110000000000
  if ((bits & 0xfffffc00U) != 0x889ffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLR_SL32_LDSTEXCL;
  inst.iclass = InstName::STLR;
  return true;
}

static bool TryExtractSTLR_SL64_LDSTEXCL(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   11001000100111111111110000000000
  if ((bits & 0xfffffc00U) != 0xc89ffc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t o0 : 1;
      uint32_t Rs : 5;
      uint32_t o1 : 1;
      uint32_t L : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::STLR_SL64_LDSTEXCL;
  inst.iclass = InstName::STLR;
  return true;
}

static bool TryExtractEON_32_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   01001010001000000000000000000000
  if ((bits & 0xff200000U) != 0x4a200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::EON_32_LOG_SHIFT;
  inst.iclass = InstName::EON;
  return true;
}

static bool TryExtractEON_64_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   11001010001000000000000000000000
  if ((bits & 0xff200000U) != 0xca200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::EON_64_LOG_SHIFT;
  inst.iclass = InstName::EON;
  return true;
}

static bool TryExtractSTSMAXB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000001000000100000000011111
  if ((bits & 0xffe0fc1fU) != 0x3820401fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMAXB_32S_MEMOP;
  inst.iclass = InstName::STSMAXB;
  return true;
}

static bool TryExtractSTSMAXLB_32S_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000011111
  //   --------------------------------
  //   00111000011000000100000000011111
  if ((bits & 0xffe0fc1fU) != 0x3860401fU) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STSMAXLB_32S_MEMOP;
  inst.iclass = InstName::STSMAXLB;
  return true;
}

static bool TryExtractFCVTNS_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000000000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNS_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractFCVTNS_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111000000000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNS_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractFCVTNS_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNS_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractFCVTNS_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001000000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNS_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractFCVTNS_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000000000000000000000
  if ((bits & 0xfffffc00U) != 0x1e600000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNS_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractFCVTNS_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011000000000000000000000
  if ((bits & 0xfffffc00U) != 0x9e600000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNS_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractSQSHRN_ASISDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01011111000000001001010000000000
  if ((bits & 0xff80fc00U) != 0x5f009400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQSHRN_ASISDSHF_N;
  inst.iclass = InstName::SQSHRN;
  return true;
}

static bool TryExtractSQSHRN_ASIMDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00001111000000001001010000000000
  if ((bits & 0xbf80fc00U) != 0xf009400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 1
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQSHRN_ASIMDSHF_N;
  inst.iclass = InstName::SQSHRN;
  return true;
}

static bool TryExtractLDTRB_32_LDST_UNPRIV(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000010000000000100000000000
  if ((bits & 0xffe00c00U) != 0x38400800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDTRB_32_LDST_UNPRIV;
  inst.iclass = InstName::LDTRB;
  return true;
}

static bool TryExtractLDRSB_32B_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000111000000000100000000000
  if ((bits & 0xffe00c00U) != 0x38e00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_32B_LDST_REGOFF;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractLDRSB_32BL_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001110110000000000
  //   --------------------------------
  //   00111000111000000110100000000000
  if ((bits & 0xffe0ec00U) != 0x38e06800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_32BL_LDST_REGOFF;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractLDRSB_64B_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000101000000000100000000000
  if ((bits & 0xffe00c00U) != 0x38a00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_64B_LDST_REGOFF;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractLDRSB_64BL_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001110110000000000
  //   --------------------------------
  //   00111000101000000110100000000000
  if ((bits & 0xffe0ec00U) != 0x38a06800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDRSB_64BL_LDST_REGOFF;
  inst.iclass = InstName::LDRSB;
  return true;
}

static bool TryExtractSXTH_SBFM_32M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00010011000000000011110000000000
  if ((bits & 0xfffffc00U) != 0x13003c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SXTH_SBFM_32M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractSXTH_SBFM_64M_BITFIELD(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10010011010000000011110000000000
  if ((bits & 0xfffffc00U) != 0x93403c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imms : 6;
      uint32_t immr : 6;
      uint32_t N : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.immr.uimm = static_cast<uint64_t>(enc.immr);
  inst.imms.uimm = static_cast<uint64_t>(enc.imms);
  inst.iform = InstForm::SXTH_SBFM_64M_BITFIELD;
  inst.iclass = InstName::SBFM;
  return true;
}

static bool TryExtractLDURSB_32_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000110000000000000000000000
  if ((bits & 0xffe00c00U) != 0x38c00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDURSB_32_LDST_UNSCALED;
  inst.iclass = InstName::LDURSB;
  return true;
}

static bool TryExtractLDURSB_64_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111000100000000000000000000000
  if ((bits & 0xffe00c00U) != 0x38800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDURSB_64_LDST_UNSCALED;
  inst.iclass = InstName::LDURSB;
  return true;
}

static bool TryExtractSHA256H_QQV_CRYPTOSHA3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110000000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x5e004000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t P : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.P = static_cast<uint8_t>(enc.P);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.iform = InstForm::SHA256H_QQV_CRYPTOSHA3;
  inst.iclass = InstName::SHA256H;
  return true;
}

static bool TryExtractLD4R_ASISDLSO_R4(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001101011000001110000000000000
  if ((bits & 0xbffff000U) != 0xd60e000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4R_ASISDLSO_R4;
  inst.iclass = InstName::LD4R;
  return true;
}

static bool TryExtractLD4R_ASISDLSOP_R4_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001101111111111110000000000000
  if ((bits & 0xbffff000U) != 0xdffe000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4R_ASISDLSOP_R4_I;
  inst.iclass = InstName::LD4R;
  return true;
}

static bool TryExtractLD4R_ASISDLSOP_RX4_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001101111000001110000000000000
  if ((bits & 0xbfe0f000U) != 0xde0e000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD4R_ASISDLSOP_RX4_R;
  inst.iclass = InstName::LD4R;
  return true;
}

static bool TryExtractFCVTNS_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110011110011010100000000000
  if ((bits & 0xfffffc00U) != 0x5e79a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTNS_ASISDMISCFP16_R;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractFCVTNS_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110001000011010100000000000
  if ((bits & 0xffbffc00U) != 0x5e21a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTNS_ASISDMISC_R;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractFCVTNS_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110011110011010100000000000
  if ((bits & 0xbffffc00U) != 0xe79a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTNS_ASIMDMISCFP16_R;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractFCVTNS_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110001000011010100000000000
  if ((bits & 0xbfbffc00U) != 0xe21a800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 1
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FCVTNS_ASIMDMISC_R;
  inst.iclass = InstName::FCVTNS;
  return true;
}

static bool TryExtractFDIV_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110010000000011110000000000
  if ((bits & 0xbfe0fc00U) != 0x2e403c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FDIV_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FDIV;
  return true;
}

static bool TryExtractFDIV_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110001000001111110000000000
  if ((bits & 0xbfa0fc00U) != 0x2e20fc00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FDIV_ASIMDSAME_ONLY;
  inst.iclass = InstName::FDIV;
  return true;
}

static bool TryExtractFRECPE_ASISDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   01011110111110011101100000000000
  if ((bits & 0xfffffc00U) != 0x5ef9d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t size : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::FRECPE_ASISDMISCFP16_R;
  inst.iclass = InstName::FRECPE;
  return true;
}

static bool TryExtractFRECPE_ASISDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101111111111110000000000
  //   --------------------------------
  //   01011110101000011101100000000000
  if ((bits & 0xffbffc00U) != 0x5ea1d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRECPE_ASISDMISC_R;
  inst.iclass = InstName::FRECPE;
  return true;
}

static bool TryExtractFRECPE_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110111110011101100000000000
  if ((bits & 0xbffffc00U) != 0xef9d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.iform = InstForm::FRECPE_ASIMDMISCFP16_R;
  inst.iclass = InstName::FRECPE;
  return true;
}

static bool TryExtractFRECPE_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110101000011101100000000000
  if ((bits & 0xbfbffc00U) != 0xea1d800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FRECPE_ASIMDMISC_R;
  inst.iclass = InstName::FRECPE;
  return true;
}

static bool TryExtractLD1R_ASISDLSO_R1(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001101010000001100000000000000
  if ((bits & 0xbffff000U) != 0xd40c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1R_ASISDLSO_R1;
  inst.iclass = InstName::LD1R;
  return true;
}

static bool TryExtractLD1R_ASISDLSOP_R1_I(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111000000000000
  //   --------------------------------
  //   00001101110111111100000000000000
  if ((bits & 0xbffff000U) != 0xddfc000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1R_ASISDLSOP_R1_I;
  inst.iclass = InstName::LD1R;
  return true;
}

static bool TryExtractLD1R_ASISDLSOP_RX1_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111000000000000
  //   --------------------------------
  //   00001101110000001100000000000000
  if ((bits & 0xbfe0f000U) != 0xdc0c000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD1R_ASISDLSOP_RX1_R;
  inst.iclass = InstName::LD1R;
  return true;
}

static bool TryExtractMUL_ASIMDELEM_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111000000001111010000000000
  //   --------------------------------
  //   00001111000000001000000000000000
  if ((bits & 0xbf00f400U) != 0xf008000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t H : 1;
      uint32_t opcode : 4;
      uint32_t Rm : 4;
      uint32_t M : 1;
      uint32_t L : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.H = static_cast<uint8_t>(enc.H);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::MUL_ASIMDELEM_R;
  inst.iclass = InstName::MUL;
  return true;
}

static bool TryExtractUADDLV_ASIMDALL_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001111111111110000000000
  //   --------------------------------
  //   00101110001100000011100000000000
  if ((bits & 0xbf3ffc00U) != 0x2e303800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UADDLV_ASIMDALL_ONLY;
  inst.iclass = InstName::UADDLV;
  return true;
}

static bool TryExtractFNEG_H_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000010100000000000000
  if ((bits & 0xfffffc00U) != 0x1ee14000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FNEG_H_FLOATDP1;
  inst.iclass = InstName::FNEG;
  return true;
}

static bool TryExtractFNEG_S_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000010100000000000000
  if ((bits & 0xfffffc00U) != 0x1e214000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FNEG_S_FLOATDP1;
  inst.iclass = InstName::FNEG;
  return true;
}

static bool TryExtractFNEG_D_FLOATDP1(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000010100000000000000
  if ((bits & 0xfffffc00U) != 0x1e614000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.iform = InstForm::FNEG_D_FLOATDP1;
  inst.iclass = InstName::FNEG;
  return true;
}

static bool TryExtractUSUBL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000010000000000000
  if ((bits & 0xbf20fc00U) != 0x2e202000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::USUBL_ASIMDDIFF_L;
  inst.iclass = InstName::USUBL;
  return true;
}

static bool TryExtractSHA1C_QSV_CRYPTOSHA3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01011110000000000000000000000000
  if ((bits & 0xffe0fc00U) != 0x5e000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SHA1C_QSV_CRYPTOSHA3;
  inst.iclass = InstName::SHA1C;
  return true;
}

static bool TryExtractSQDMLSL_ASISDDIFF_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000001011000000000000
  if ((bits & 0xff20fc00U) != 0x5e20b000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMLSL_ASISDDIFF_ONLY;
  inst.iclass = InstName::SQDMLSL;
  return true;
}

static bool TryExtractSQDMLSL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001011000000000000
  if ((bits & 0xbf20fc00U) != 0xe20b000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMLSL_ASIMDDIFF_L;
  inst.iclass = InstName::SQDMLSL;
  return true;
}

static bool TryExtractPRFUM_P_LDST_UNSCALED(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111000100000000000000000000000
  if ((bits & 0xffe00c00U) != 0xf8800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t imm9 : 9;
      uint32_t _21 : 1;  // 0
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.imm9.uimm = static_cast<uint64_t>(enc.imm9);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::PRFUM_P_LDST_UNSCALED;
  inst.iclass = InstName::PRFUM;
  return true;
}

static bool TryExtractLDSMAXAB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000101000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x38a04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXAB_32_MEMOP;
  inst.iclass = InstName::LDSMAXAB;
  return true;
}

static bool TryExtractLDSMAXALB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000111000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x38e04000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXALB_32_MEMOP;
  inst.iclass = InstName::LDSMAXALB;
  return true;
}

static bool TryExtractLDSMAXB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000001000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x38204000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXB_32_MEMOP;
  inst.iclass = InstName::LDSMAXB;
  return true;
}

static bool TryExtractLDSMAXLB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000011000000100000000000000
  if ((bits & 0xffe0fc00U) != 0x38604000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDSMAXLB_32_MEMOP;
  inst.iclass = InstName::LDSMAXLB;
  return true;
}

static bool TryExtractFABD_ASISDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   01111110110000000001010000000000
  if ((bits & 0xffe0fc00U) != 0x7ec01400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FABD_ASISDSAMEFP16_ONLY;
  inst.iclass = InstName::FABD;
  return true;
}

static bool TryExtractFABD_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111101000001111110000000000
  //   --------------------------------
  //   01111110101000001101010000000000
  if ((bits & 0xffa0fc00U) != 0x7ea0d400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FABD_ASISDSAME_ONLY;
  inst.iclass = InstName::FABD;
  return true;
}

static bool TryExtractFABD_ASIMDSAMEFP16_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00101110110000000001010000000000
  if ((bits & 0xbfe0fc00U) != 0x2ec01400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 3;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t a : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.a = static_cast<uint8_t>(enc.a);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FABD_ASIMDSAMEFP16_ONLY;
  inst.iclass = InstName::FABD;
  return true;
}

static bool TryExtractFABD_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101000001111110000000000
  //   --------------------------------
  //   00101110101000001101010000000000
  if ((bits & 0xbfa0fc00U) != 0x2ea0d400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.iform = InstForm::FABD_ASIMDSAME_ONLY;
  inst.iclass = InstName::FABD;
  return true;
}

static bool TryExtractB_ONLY_CONDBRANCH(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111000000000000000000010000
  //   --------------------------------
  //   01010100000000000000000000000000
  if ((bits & 0xff000010U) != 0x54000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t cond : 4;
      uint32_t o0 : 1;
      uint32_t imm19 : 19;
      uint32_t o1 : 1;
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 0
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.imm19.uimm = static_cast<uint64_t>(enc.imm19);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::B_ONLY_CONDBRANCH;
  inst.iclass = InstName::B;
  return true;
}

static bool TryExtractFCVTNU_32H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110111000010000000000000000
  if ((bits & 0xfffffc00U) != 0x1ee10000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNU_32H_FLOAT2INT;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractFCVTNU_64H_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110111000010000000000000000
  if ((bits & 0xfffffc00U) != 0x9ee10000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNU_64H_FLOAT2INT;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractFCVTNU_32S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110001000010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e210000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNU_32S_FLOAT2INT;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractFCVTNU_64S_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110001000010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e210000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNU_64S_FLOAT2INT;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractFCVTNU_32D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   00011110011000010000000000000000
  if ((bits & 0xfffffc00U) != 0x1e610000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNU_32D_FLOAT2INT;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractFCVTNU_64D_FLOAT2INT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111111111111110000000000
  //   --------------------------------
  //   10011110011000010000000000000000
  if ((bits & 0xfffffc00U) != 0x9e610000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t opcode : 3;
      uint32_t rmode : 2;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.rmode = static_cast<uint8_t>(enc.rmode);
  inst.iform = InstForm::FCVTNU_64D_FLOAT2INT;
  inst.iclass = InstName::FCVTNU;
  return true;
}

static bool TryExtractMUL_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001001110000000000
  if ((bits & 0xbf20fc00U) != 0xe209c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::MUL_ASIMDSAME_ONLY;
  inst.iclass = InstName::MUL;
  return true;
}

static bool TryExtractUDIV_32_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00011010110000000000100000000000
  if ((bits & 0xffe0fc00U) != 0x1ac00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o1 : 1;
      uint32_t opcode2 : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UDIV_32_DP_2SRC;
  inst.iclass = InstName::UDIV;
  return true;
}

static bool TryExtractUDIV_64_DP_2SRC(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   10011010110000000000100000000000
  if ((bits & 0xffe0fc00U) != 0x9ac00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t o1 : 1;
      uint32_t opcode2 : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t _22 : 1;  // 1
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opcode2 = static_cast<uint8_t>(enc.opcode2);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::UDIV_64_DP_2SRC;
  inst.iclass = InstName::UDIV;
  return true;
}

static bool TryExtractCMTST_ASISDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000001000110000000000
  if ((bits & 0xff20fc00U) != 0x5e208c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMTST_ASISDSAME_ONLY;
  inst.iclass = InstName::CMTST;
  return true;
}

static bool TryExtractCMTST_ASIMDSAME_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001000110000000000
  if ((bits & 0xbf20fc00U) != 0xe208c00U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t opcode : 5;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CMTST_ASIMDSAME_ONLY;
  inst.iclass = InstName::CMTST;
  return true;
}

static bool TryExtractUADDL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00101110001000000000000000000000
  if ((bits & 0xbf20fc00U) != 0x2e200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t _12 : 1;  // 0
      uint32_t o1 : 1;
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::UADDL_ASIMDDIFF_L;
  inst.iclass = InstName::UADDL;
  return true;
}

static bool TryExtractMOV_MOVN_32_MOVEWIDE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   00010010100000000000000000000000
  if ((bits & 0xff800000U) != 0x12800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOV_MOVN_32_MOVEWIDE;
  inst.iclass = InstName::MOVN;
  return true;
}

static bool TryExtractMOV_MOVN_64_MOVEWIDE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   10010010100000000000000000000000
  if ((bits & 0xff800000U) != 0x92800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOV_MOVN_64_MOVEWIDE;
  inst.iclass = InstName::MOVN;
  return true;
}

static bool TryExtractTRN2_ASIMDPERM_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110000000000110100000000000
  if ((bits & 0xbf20fc00U) != 0xe006800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 1
      uint32_t op : 1;
      uint32_t _15 : 1;  // 0
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 0
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::TRN2_ASIMDPERM_ONLY;
  inst.iclass = InstName::TRN2;
  return true;
}

static bool TryExtractMOVK_32_MOVEWIDE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   01110010100000000000000000000000
  if ((bits & 0xff800000U) != 0x72800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOVK_32_MOVEWIDE;
  inst.iclass = InstName::MOVK;
  return true;
}

static bool TryExtractMOVK_64_MOVEWIDE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000000000000000000000
  //   --------------------------------
  //   11110010100000000000000000000000
  if ((bits & 0xff800000U) != 0xf2800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t imm16 : 16;
      uint32_t hw : 2;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 0
      uint32_t _28 : 1;  // 1
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.hw = static_cast<uint8_t>(enc.hw);
  inst.imm16.uimm = static_cast<uint64_t>(enc.imm16);
  inst.iform = InstForm::MOVK_64_MOVEWIDE;
  inst.iclass = InstName::MOVK;
  return true;
}

static bool TryExtractSMADDL_64WA_DP_3SRC(InstData &inst, uint32_t bits) {
  if (false && TryExtractSMULL_SMADDL_64WA_DP_3SRC(inst, bits))
    return true;

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   10011011001000000000000000000000
  if ((bits & 0xffe08000U) != 0x9b200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 0
      uint32_t U : 1;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t op54 : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.op54 = static_cast<uint8_t>(enc.op54);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::SMADDL_64WA_DP_3SRC;
  inst.iclass = InstName::SMADDL;
  return true;
}

static bool TryExtractAND_32_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   00001010000000000000000000000000
  if ((bits & 0xff200000U) != 0xa000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::AND_32_LOG_SHIFT;
  inst.iclass = InstName::AND;
  return true;
}

static bool TryExtractAND_64_LOG_SHIFT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   10001010000000000000000000000000
  if ((bits & 0xff200000U) != 0x8a000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::AND_64_LOG_SHIFT;
  inst.iclass = InstName::AND;
  return true;
}

static bool TryExtractSQSHRUN_ASISDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111100000001111110000000000
  //   --------------------------------
  //   01111111000000001000010000000000
  if ((bits & 0xff80fc00U) != 0x7f008400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQSHRUN_ASISDSHF_N;
  inst.iclass = InstName::SQSHRUN;
  return true;
}

static bool TryExtractSQSHRUN_ASIMDSHF_N(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111100000001111110000000000
  //   --------------------------------
  //   00101111000000001000010000000000
  if ((bits & 0xbf80fc00U) != 0x2f008400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t op : 1;
      uint32_t _12 : 1;  // 0
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t immb : 3;
      uint32_t immh : 4;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.immh.uimm = static_cast<uint64_t>(enc.immh);
  if (!(inst.immh.uimm != 0x0))
    return false;
  inst.immb.uimm = static_cast<uint64_t>(enc.immb);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SQSHRUN_ASIMDSHF_N;
  inst.iclass = InstName::SQSHRUN;
  return true;
}

static bool TryExtractSQDMULL_ASISDDIFF_ONLY(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111001000001111110000000000
  //   --------------------------------
  //   01011110001000001101000000000000
  if ((bits & 0xff20fc00U) != 0x5e20d000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t U : 1;
      uint32_t _30 : 1;  // 1
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMULL_ASISDDIFF_ONLY;
  inst.iclass = InstName::SQDMULL;
  return true;
}

static bool TryExtractSQDMULL_ASIMDDIFF_L(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111001000001111110000000000
  //   --------------------------------
  //   00001110001000001101000000000000
  if ((bits & 0xbf20fc00U) != 0xe20d000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opcode : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t size : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::SQDMULL_ASIMDDIFF_L;
  inst.iclass = InstName::SQDMULL;
  return true;
}

static bool TryExtractFNMADD_H_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111111000000000000000000000
  if ((bits & 0xffe08000U) != 0x1fe00000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FNMADD_H_FLOATDP3;
  inst.iclass = InstName::FNMADD;
  return true;
}

static bool TryExtractFNMADD_S_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111001000000000000000000000
  if ((bits & 0xffe08000U) != 0x1f200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FNMADD_S_FLOATDP3;
  inst.iclass = InstName::FNMADD;
  return true;
}

static bool TryExtractFNMADD_D_FLOATDP3(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001000000000000000
  //   --------------------------------
  //   00011111011000000000000000000000
  if ((bits & 0xffe08000U) != 0x1f600000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t Ra : 5;
      uint32_t o0 : 1;
      uint32_t Rm : 5;
      uint32_t o1 : 1;
      uint32_t type : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.M = static_cast<uint8_t>(enc.M);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Ra = static_cast<uint8_t>(enc.Ra);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.o0 = static_cast<uint8_t>(enc.o0);
  inst.iform = InstForm::FNMADD_D_FLOATDP3;
  inst.iclass = InstName::FNMADD;
  return true;
}

static bool TryExtractFCCMP_H_FLOATCCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   00011110111000000000010000000000
  if ((bits & 0xffe00c10U) != 0x1ee00400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t op : 1;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCCMP_H_FLOATCCMP;
  inst.iclass = InstName::FCCMP;
  return true;
}

static bool TryExtractFCCMP_S_FLOATCCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   00011110001000000000010000000000
  if ((bits & 0xffe00c10U) != 0x1e200400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t op : 1;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCCMP_S_FLOATCCMP;
  inst.iclass = InstName::FCCMP;
  return true;
}

static bool TryExtractFCCMP_D_FLOATCCMP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000010000
  //   --------------------------------
  //   00011110011000000000010000000000
  if ((bits & 0xffe00c10U) != 0x1e600400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t nzcv : 4;
      uint32_t op : 1;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 1
      uint32_t _11 : 1;  // 0
      uint32_t cond : 4;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t type : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t S : 1;
      uint32_t _30 : 1;  // 0
      uint32_t M : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.nzcv = static_cast<uint8_t>(enc.nzcv);
  inst.M = static_cast<uint8_t>(enc.M);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.cond = static_cast<uint8_t>(enc.cond);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.type = static_cast<uint8_t>(enc.type);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::FCCMP_D_FLOATCCMP;
  inst.iclass = InstName::FCCMP;
  return true;
}

static bool TryExtractLD3_ASISDLSO_B3_3B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101010000000010000000000000
  if ((bits & 0xbfffe000U) != 0xd402000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSO_B3_3B;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSO_H3_3H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101010000000110000000000000
  if ((bits & 0xbfffe400U) != 0xd406000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSO_H3_3H;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSO_S3_3S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101010000001010000000000000
  if ((bits & 0xbfffec00U) != 0xd40a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSO_S3_3S;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSO_D3_3D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101010000001010010000000000
  if ((bits & 0xbffffc00U) != 0xd40a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t _16 : 1;  // 0
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSO_D3_3D;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSOP_B3_I3B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110000000000000
  //   --------------------------------
  //   00001101110111110010000000000000
  if ((bits & 0xbfffe000U) != 0xddf2000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSOP_B3_I3B;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSOP_BX3_R3B(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110000000000000
  //   --------------------------------
  //   00001101110000000010000000000000
  if ((bits & 0xbfe0e000U) != 0xdc02000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSOP_BX3_R3B;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSOP_H3_I3H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110010000000000
  //   --------------------------------
  //   00001101110111110110000000000000
  if ((bits & 0xbfffe400U) != 0xddf6000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSOP_H3_I3H;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSOP_HX3_R3H(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110010000000000
  //   --------------------------------
  //   00001101110000000110000000000000
  if ((bits & 0xbfe0e400U) != 0xdc06000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSOP_HX3_R3H;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSOP_S3_I3S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111110110000000000
  //   --------------------------------
  //   00001101110111111010000000000000
  if ((bits & 0xbfffec00U) != 0xddfa000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSOP_S3_I3S;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSOP_SX3_R3S(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001110110000000000
  //   --------------------------------
  //   00001101110000001010000000000000
  if ((bits & 0xbfe0ec00U) != 0xdc0a000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSOP_SX3_R3S;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSOP_D3_I3D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001101110111111010010000000000
  if ((bits & 0xbffffc00U) != 0xddfa400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSOP_D3_I3D;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractLD3_ASISDLSOP_DX3_R3D(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111000001111110000000000
  //   --------------------------------
  //   00001101110000001010010000000000
  if ((bits & 0xbfe0fc00U) != 0xdc0a400U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t size : 2;
      uint32_t S : 1;
      uint32_t opcode : 3;
      uint32_t Rm : 5;
      uint32_t R : 1;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 0
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opcode = static_cast<uint8_t>(enc.opcode);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LD3_ASISDLSOP_DX3_R3D;
  inst.iclass = InstName::LD3;
  return true;
}

static bool TryExtractFRINTN_ASIMDMISCFP16_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111111111111111110000000000
  //   --------------------------------
  //   00001110011110011000100000000000
  if ((bits & 0xbffffc00U) != 0xe798800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 1
      uint32_t _20 : 1;  // 1
      uint32_t _21 : 1;  // 1
      uint32_t _22 : 1;  // 1
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTN_ASIMDMISCFP16_R;
  inst.iclass = InstName::FRINTN;
  return true;
}

static bool TryExtractFRINTN_ASIMDMISC_R(InstData &inst, uint32_t bits) {

  //   bits
  // & 10111111101111111111110000000000
  //   --------------------------------
  //   00001110001000011000100000000000
  if ((bits & 0xbfbffc00U) != 0xe218800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t o1 : 1;
      uint32_t _13 : 1;  // 0
      uint32_t _14 : 1;  // 0
      uint32_t _15 : 1;  // 1
      uint32_t _16 : 1;  // 1
      uint32_t _17 : 1;  // 0
      uint32_t _18 : 1;  // 0
      uint32_t _19 : 1;  // 0
      uint32_t _20 : 1;  // 0
      uint32_t _21 : 1;  // 1
      uint32_t sz : 1;
      uint32_t o2 : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 1
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t U : 1;
      uint32_t Q : 1;
      uint32_t _31 : 1;  // 0
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.sz = static_cast<uint8_t>(enc.sz);
  inst.Q = static_cast<uint8_t>(enc.Q);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.U = static_cast<uint8_t>(enc.U);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o2 = static_cast<uint8_t>(enc.o2);
  inst.o1 = static_cast<uint8_t>(enc.o1);
  inst.iform = InstForm::FRINTN_ASIMDMISC_R;
  inst.iclass = InstName::FRINTN;
  return true;
}

static bool TryExtractSUB_32_ADDSUB_EXT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   01001011001000000000000000000000
  if ((bits & 0xffe00000U) != 0x4b200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SUB_32_ADDSUB_EXT;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractSUB_64_ADDSUB_EXT(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000000000000000
  //   --------------------------------
  //   11001011001000000000000000000000
  if ((bits & 0xffe00000U) != 0xcb200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm3 : 3;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opt : 2;
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t S : 1;
      uint32_t op : 1;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.opt = static_cast<uint8_t>(enc.opt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm3.uimm = static_cast<uint64_t>(enc.imm3);
  inst.op = static_cast<uint8_t>(enc.op);
  inst.iform = InstForm::SUB_64_ADDSUB_EXT;
  inst.iclass = InstName::SUB;
  return true;
}

static bool TryExtractSTR_B_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100001000000000100000000000
  if ((bits & 0xffe00c00U) != 0x3c200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_B_LDST_REGOFF;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_BL_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001110110000000000
  //   --------------------------------
  //   00111100001000000110100000000000
  if ((bits & 0xffe0ec00U) != 0x3c206800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_BL_LDST_REGOFF;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_H_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   01111100001000000000100000000000
  if ((bits & 0xffe00c00U) != 0x7c200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_H_LDST_REGOFF;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_S_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   10111100001000000000100000000000
  if ((bits & 0xffe00c00U) != 0xbc200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_S_LDST_REGOFF;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_D_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   11111100001000000000100000000000
  if ((bits & 0xffe00c00U) != 0xfc200800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_D_LDST_REGOFF;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTR_Q_LDST_REGOFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000000000110000000000
  //   --------------------------------
  //   00111100101000000000100000000000
  if ((bits & 0xffe00c00U) != 0x3ca00800U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 1
      uint32_t S : 1;
      uint32_t option : 3;
      uint32_t Rm : 5;
      uint32_t _21 : 1;  // 1
      uint32_t opc : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.option = static_cast<uint8_t>(enc.option);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.S = static_cast<uint8_t>(enc.S);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::STR_Q_LDST_REGOFF;
  inst.iclass = InstName::STR;
  return true;
}

static bool TryExtractSTP_32_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101000100000000000000000000000
  if ((bits & 0xffc00000U) != 0x28800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_32_LDSTPAIR_POST;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_64_LDSTPAIR_POST(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101000100000000000000000000000
  if ((bits & 0xffc00000U) != 0xa8800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_64_LDSTPAIR_POST;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_32_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101001100000000000000000000000
  if ((bits & 0xffc00000U) != 0x29800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_32_LDSTPAIR_PRE;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_64_LDSTPAIR_PRE(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101001100000000000000000000000
  if ((bits & 0xffc00000U) != 0xa9800000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 1
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_64_LDSTPAIR_PRE;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_32_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   00101001000000000000000000000000
  if ((bits & 0xffc00000U) != 0x29000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_32_LDSTPAIR_OFF;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractSTP_64_LDSTPAIR_OFF(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111110000000000000000000000
  //   --------------------------------
  //   10101001000000000000000000000000
  if ((bits & 0xffc00000U) != 0xa9000000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t Rt2 : 5;
      uint32_t imm7 : 7;
      uint32_t L : 1;
      uint32_t _23 : 1;  // 0
      uint32_t _24 : 1;  // 1
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t _29 : 1;  // 1
      uint32_t opc : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rt2 = static_cast<uint8_t>(enc.Rt2);
  inst.L = static_cast<uint8_t>(enc.L);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.imm7.uimm = static_cast<uint64_t>(enc.imm7);
  inst.iform = InstForm::STP_64_LDSTPAIR_OFF;
  inst.iclass = InstName::STP;
  return true;
}

static bool TryExtractORN_32_LOG_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractMVN_ORN_32_LOG_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   00101010001000000000000000000000
  if ((bits & 0xff200000U) != 0x2a200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ORN_32_LOG_SHIFT;
  inst.iclass = InstName::ORN;
  return true;
}

static bool TryExtractORN_64_LOG_SHIFT(InstData &inst, uint32_t bits) {
  if (false && TryExtractMVN_ORN_64_LOG_SHIFT(inst, bits))
    return true;

  //   bits
  // & 11111111001000000000000000000000
  //   --------------------------------
  //   10101010001000000000000000000000
  if ((bits & 0xff200000U) != 0xaa200000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rd : 5;
      uint32_t Rn : 5;
      uint32_t imm6 : 6;
      uint32_t Rm : 5;
      uint32_t N : 1;
      uint32_t shift : 2;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 1
      uint32_t _26 : 1;  // 0
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 0
      uint32_t opc : 2;
      uint32_t sf : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.shift = static_cast<uint8_t>(enc.shift);
  inst.N = static_cast<uint8_t>(enc.N);
  inst.Rd = static_cast<uint8_t>(enc.Rd);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.imm6.uimm = static_cast<uint64_t>(enc.imm6);
  inst.iform = InstForm::ORN_64_LOG_SHIFT;
  inst.iclass = InstName::ORN;
  return true;
}

static bool TryExtractLDCLRAB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000101000000001000000000000
  if ((bits & 0xffe0fc00U) != 0x38a01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRAB_32_MEMOP;
  inst.iclass = InstName::LDCLRAB;
  return true;
}

static bool TryExtractLDCLRALB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000111000000001000000000000
  if ((bits & 0xffe0fc00U) != 0x38e01000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRALB_32_MEMOP;
  inst.iclass = InstName::LDCLRALB;
  return true;
}

static bool TryExtractLDCLRB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000001000000001000000000000
  if ((bits & 0xffe0fc00U) != 0x38201000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRB_32_MEMOP;
  inst.iclass = InstName::LDCLRB;
  return true;
}

static bool TryExtractLDCLRLB_32_MEMOP(InstData &inst, uint32_t bits) {

  //   bits
  // & 11111111111000001111110000000000
  //   --------------------------------
  //   00111000011000000001000000000000
  if ((bits & 0xffe0fc00U) != 0x38601000U) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t Rn : 5;
      uint32_t _10 : 1;  // 0
      uint32_t _11 : 1;  // 0
      uint32_t opc : 3;
      uint32_t o3 : 1;
      uint32_t Rs : 5;
      uint32_t _21 : 1;  // 1
      uint32_t R : 1;
      uint32_t A : 1;
      uint32_t _24 : 1;  // 0
      uint32_t _25 : 1;  // 0
      uint32_t V : 1;
      uint32_t _27 : 1;  // 1
      uint32_t _28 : 1;  // 1
      uint32_t _29 : 1;  // 1
      uint32_t size : 2;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.A = static_cast<uint8_t>(enc.A);
  inst.Rs = static_cast<uint8_t>(enc.Rs);
  inst.V = static_cast<uint8_t>(enc.V);
  inst.R = static_cast<uint8_t>(enc.R);
  inst.opc = static_cast<uint8_t>(enc.opc);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.o3 = static_cast<uint8_t>(enc.o3);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::LDCLRLB_32_MEMOP;
  inst.iclass = InstName::LDCLRLB;
  return true;
}

static bool TryExtractCNTB_X64_BITCOUNT(InstData &inst, uint32_t bits) {

  //   bits
  // & 1111'1111'1111'0000'1111'1100'0000'0000
  //   ---------------------------------------
  //   0000'0100'0010'0000'1110'0000'0000'0000
  if ((bits & 0xfff0fc00) != 0x0420e000) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t pattern : 5;
      uint32_t _10 : 1;
      uint32_t _11 : 1;
      uint32_t _12 : 1;
      uint32_t _13 : 1;
      uint32_t _14 : 1;
      uint32_t _15 : 1;
      uint32_t imm4 : 4;
      uint32_t _20 : 1;
      uint32_t _21 : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;
      uint32_t _25 : 1;
      uint32_t _26 : 1;
      uint32_t _27 : 1;
      uint32_t _28 : 1;
      uint32_t _29 : 1;
      uint32_t _30 : 1;
      uint32_t _31 : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.pattern = static_cast<uint8_t>(enc.pattern);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CNTB_X64_BITCOUNT;
  inst.iclass = InstName::CNTX;
  return true;
}

static bool TryExtractCNTD_X64_BITCOUNT(InstData &inst, uint32_t bits) {

  //   bits
  // & 1111'1111'1111'0000'1111'1100'0000'0000
  //   ---------------------------------------
  //   0000'0100'1110'0000'1110'0000'0000'0000
  if ((bits & 0xfff0fc00) != 0x04e0e000) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t pattern : 5;
      uint32_t _10 : 1;
      uint32_t _11 : 1;
      uint32_t _12 : 1;
      uint32_t _13 : 1;
      uint32_t _14 : 1;
      uint32_t _15 : 1;
      uint32_t imm4 : 4;
      uint32_t _20 : 1;
      uint32_t _21 : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;
      uint32_t _25 : 1;
      uint32_t _26 : 1;
      uint32_t _27 : 1;
      uint32_t _28 : 1;
      uint32_t _29 : 1;
      uint32_t _30 : 1;
      uint32_t _31 : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.pattern = static_cast<uint8_t>(enc.pattern);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CNTD_X64_BITCOUNT;
  inst.iclass = InstName::CNTX;
  return true;
}

static bool TryExtractCNTH_X64_BITCOUNT(InstData &inst, uint32_t bits) {

  //   bits
  // & 1111'1111'1111'0000'1111'1100'0000'0000
  //   ---------------------------------------
  //   0000'0100'0110'0000'1110'0000'0000'0000
  if ((bits & 0xfff0fc00) != 0x0460e000) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t pattern : 5;
      uint32_t _10 : 1;
      uint32_t _11 : 1;
      uint32_t _12 : 1;
      uint32_t _13 : 1;
      uint32_t _14 : 1;
      uint32_t _15 : 1;
      uint32_t imm4 : 4;
      uint32_t _20 : 1;
      uint32_t _21 : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;
      uint32_t _25 : 1;
      uint32_t _26 : 1;
      uint32_t _27 : 1;
      uint32_t _28 : 1;
      uint32_t _29 : 1;
      uint32_t _30 : 1;
      uint32_t _31 : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.pattern = static_cast<uint8_t>(enc.pattern);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CNTH_X64_BITCOUNT;
  inst.iclass = InstName::CNTX;
  return true;
}

static bool TryExtractCNTW_X64_BITCOUNT(InstData &inst, uint32_t bits) {

  //   bits
  // & 1111'1111'1111'0000'1111'1100'0000'0000
  //   ---------------------------------------
  //   0000'0100'1010'0000'1110'0000'0000'0000
  if ((bits & 0xfff0fc00) != 0x04a0e000) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Rt : 5;
      uint32_t pattern : 5;
      uint32_t _10 : 1;
      uint32_t _11 : 1;
      uint32_t _12 : 1;
      uint32_t _13 : 1;
      uint32_t _14 : 1;
      uint32_t _15 : 1;
      uint32_t imm4 : 4;
      uint32_t _20 : 1;
      uint32_t _21 : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;
      uint32_t _25 : 1;
      uint32_t _26 : 1;
      uint32_t _27 : 1;
      uint32_t _28 : 1;
      uint32_t _29 : 1;
      uint32_t _30 : 1;
      uint32_t _31 : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Rt = static_cast<uint8_t>(enc.Rt);
  inst.pattern = static_cast<uint8_t>(enc.pattern);
  inst.imm4.uimm = static_cast<uint64_t>(enc.imm4);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::CNTW_X64_BITCOUNT;
  inst.iclass = InstName::CNTX;
  return true;
}

static bool TryExtractWHILELO_PREDICATE(InstData &inst, uint32_t bits) {

  //   bits
  // & 1111'1111'0010'0000'1110'1100'0001'0000
  //   ---------------------------------------
  //   0010'0101'0010'0000'0000'1100'0000'0000
  if ((bits & 0xff20ec10) != 0x25200c00) {
    return false;
  }
  union {
    uint32_t flat;
    struct {
      uint32_t Pd : 4;
      uint32_t _4 : 1;
      uint32_t Rn : 5;
      uint32_t _10 : 1;
      uint32_t _11 : 1;
      uint32_t sf : 1;
      uint32_t _13 : 1;
      uint32_t _14 : 1;
      uint32_t _15 : 1;
      uint32_t Rm : 5;
      uint32_t _21 : 1;
      uint32_t size : 2;
      uint32_t _24 : 1;
      uint32_t _25 : 1;
      uint32_t _26 : 1;
      uint32_t _27 : 1;
      uint32_t _28 : 1;
      uint32_t _29 : 1;
      uint32_t _30 : 1;
      uint32_t _31 : 1;
    } __attribute__((packed));
  } __attribute__((packed)) enc;
  static_assert(sizeof(enc) == 4, " ");
  enc.flat = bits;
  inst.Pd = static_cast<uint8_t>(enc.Pd);
  inst.Rn = static_cast<uint8_t>(enc.Rn);
  inst.sf = static_cast<uint8_t>(enc.sf);
  inst.Rm = static_cast<uint8_t>(enc.Rm);
  inst.size = static_cast<uint8_t>(enc.size);
  inst.iform = InstForm::WHILELO_PREDICATE;
  inst.iclass = InstName::WHILE;
  return true;
}

// 00000000000000000000000000000000
static bool TryExtract0(InstData &inst, uint32_t bits) {
  return false;
}

// 00000100000000000000000000000000
static bool TryExtract1(InstData &inst, uint32_t bits) {
  return false || TryExtractCNTB_X64_BITCOUNT(inst, bits) ||
         TryExtractCNTD_X64_BITCOUNT(inst, bits) || TryExtractCNTH_X64_BITCOUNT(inst, bits) ||
         TryExtractCNTW_X64_BITCOUNT(inst, bits) || TryExtractWHILELO_PREDICATE(inst, bits);
}

// 00001000000000000000000000000000
static bool TryExtract2(InstData &inst, uint32_t bits) {
  return false || TryExtractLDLARB_LR32_LDSTEXCL(inst, bits) ||
         TryExtractLDAXR_LR32_LDSTEXCL(inst, bits) || TryExtractSTLLR_SL64_LDSTEXCL(inst, bits) ||
         TryExtractSTLRH_SL32_LDSTEXCL(inst, bits) || TryExtractLDXR_LR64_LDSTEXCL(inst, bits) ||
         TryExtractLDLARH_LR32_LDSTEXCL(inst, bits) || TryExtractSTLLRB_SL32_LDSTEXCL(inst, bits) ||
         TryExtractLDAXR_LR64_LDSTEXCL(inst, bits) || TryExtractSTLLRH_SL32_LDSTEXCL(inst, bits) ||
         TryExtractLDAR_LR32_LDSTEXCL(inst, bits) || TryExtractSTLRB_SL32_LDSTEXCL(inst, bits) ||
         TryExtractLDARH_LR32_LDSTEXCL(inst, bits) || TryExtractSTLR_SL32_LDSTEXCL(inst, bits) ||
         TryExtractLDAXRH_LR32_LDSTEXCL(inst, bits) || TryExtractLDAXRB_LR32_LDSTEXCL(inst, bits) ||
         TryExtractSTLLR_SL32_LDSTEXCL(inst, bits) || TryExtractLDXRH_LR32_LDSTEXCL(inst, bits) ||
         TryExtractLDAR_LR64_LDSTEXCL(inst, bits) || TryExtractLDLAR_LR32_LDSTEXCL(inst, bits) ||
         TryExtractLDXRB_LR32_LDSTEXCL(inst, bits) || TryExtractLDARB_LR32_LDSTEXCL(inst, bits) ||
         TryExtractLDLAR_LR64_LDSTEXCL(inst, bits) || TryExtractLDXR_LR32_LDSTEXCL(inst, bits) ||
         TryExtractSTLR_SL64_LDSTEXCL(inst, bits) || TryExtractCASALB_C32_LDSTEXCL(inst, bits) ||
         TryExtractSTXR_SR32_LDSTEXCL(inst, bits) || TryExtractCASLH_C32_LDSTEXCL(inst, bits) ||
         TryExtractSTXR_SR64_LDSTEXCL(inst, bits) || TryExtractSTLXR_SR32_LDSTEXCL(inst, bits) ||
         TryExtractLDAXP_LP64_LDSTEXCL(inst, bits) || TryExtractCASAL_C64_LDSTEXCL(inst, bits) ||
         TryExtractCASA_C32_LDSTEXCL(inst, bits) || TryExtractCASAL_C32_LDSTEXCL(inst, bits) ||
         TryExtractCAS_C32_LDSTEXCL(inst, bits) || TryExtractCASA_C64_LDSTEXCL(inst, bits) ||
         TryExtractCASL_C32_LDSTEXCL(inst, bits) || TryExtractCASL_C64_LDSTEXCL(inst, bits) ||
         TryExtractCAS_C64_LDSTEXCL(inst, bits) || TryExtractCASB_C32_LDSTEXCL(inst, bits) ||
         TryExtractCASLB_C32_LDSTEXCL(inst, bits) || TryExtractCASPA_CP32_LDSTEXCL(inst, bits) ||
         TryExtractCASPAL_CP32_LDSTEXCL(inst, bits) || TryExtractCASP_CP32_LDSTEXCL(inst, bits) ||
         TryExtractSTLXRH_SR32_LDSTEXCL(inst, bits) || TryExtractCASPA_CP64_LDSTEXCL(inst, bits) ||
         TryExtractCASPAL_CP64_LDSTEXCL(inst, bits) || TryExtractCASP_CP64_LDSTEXCL(inst, bits) ||
         TryExtractCASPL_CP64_LDSTEXCL(inst, bits) || TryExtractSTXRB_SR32_LDSTEXCL(inst, bits) ||
         TryExtractLDAXP_LP32_LDSTEXCL(inst, bits) || TryExtractSTLXR_SR64_LDSTEXCL(inst, bits) ||
         TryExtractCASH_C32_LDSTEXCL(inst, bits) || TryExtractCASPL_CP32_LDSTEXCL(inst, bits) ||
         TryExtractCASALH_C32_LDSTEXCL(inst, bits) || TryExtractCASAB_C32_LDSTEXCL(inst, bits) ||
         TryExtractSTXRH_SR32_LDSTEXCL(inst, bits) || TryExtractLDXP_LP64_LDSTEXCL(inst, bits) ||
         TryExtractLDXP_LP32_LDSTEXCL(inst, bits) || TryExtractSTLXRB_SR32_LDSTEXCL(inst, bits) ||
         TryExtractCASAH_C32_LDSTEXCL(inst, bits) || TryExtractSTLXP_SP32_LDSTEXCL(inst, bits) ||
         TryExtractSTLXP_SP64_LDSTEXCL(inst, bits) || TryExtractSTXP_SP64_LDSTEXCL(inst, bits) ||
         TryExtractSTXP_SP32_LDSTEXCL(inst, bits) || TryExtractSUB_64_ADDSUB_EXT(inst, bits) ||
         TryExtractSUB_32_ADDSUB_EXT(inst, bits) || TryExtractSUBS_32S_ADDSUB_EXT(inst, bits) ||
         TryExtractADD_32_ADDSUB_EXT(inst, bits) || TryExtractADD_64_ADDSUB_EXT(inst, bits) ||
         TryExtractADDS_64S_ADDSUB_EXT(inst, bits) || TryExtractADDS_32S_ADDSUB_EXT(inst, bits) ||
         TryExtractSUBS_64S_ADDSUB_EXT(inst, bits) ||
         TryExtractSTNP_32_LDSTNAPAIR_OFFS(inst, bits) ||
         TryExtractSTNP_64_LDSTNAPAIR_OFFS(inst, bits) ||
         TryExtractLDNP_32_LDSTNAPAIR_OFFS(inst, bits) ||
         TryExtractLDNP_64_LDSTNAPAIR_OFFS(inst, bits) ||
         TryExtractLDP_32_LDSTPAIR_POST(inst, bits) || TryExtractLDP_64_LDSTPAIR_POST(inst, bits) ||
         TryExtractLDP_32_LDSTPAIR_PRE(inst, bits) || TryExtractLDP_64_LDSTPAIR_PRE(inst, bits) ||
         TryExtractLDP_32_LDSTPAIR_OFF(inst, bits) || TryExtractLDP_64_LDSTPAIR_OFF(inst, bits) ||
         TryExtractSTP_64_LDSTPAIR_PRE(inst, bits) || TryExtractSTP_32_LDSTPAIR_PRE(inst, bits) ||
         TryExtractSTP_64_LDSTPAIR_OFF(inst, bits) || TryExtractSTP_32_LDSTPAIR_OFF(inst, bits) ||
         TryExtractLDPSW_64_LDSTPAIR_POST(inst, bits) ||
         TryExtractLDPSW_64_LDSTPAIR_PRE(inst, bits) ||
         TryExtractLDPSW_64_LDSTPAIR_OFF(inst, bits) ||
         TryExtractSTP_32_LDSTPAIR_POST(inst, bits) || TryExtractSTP_64_LDSTPAIR_POST(inst, bits) ||
         TryExtractSUB_64_ADDSUB_SHIFT(inst, bits) || TryExtractEOR_64_LOG_SHIFT(inst, bits) ||
         TryExtractADDS_32_ADDSUB_SHIFT(inst, bits) || TryExtractADDS_64_ADDSUB_SHIFT(inst, bits) ||
         TryExtractSUBS_32_ADDSUB_SHIFT(inst, bits) || TryExtractBIC_32_LOG_SHIFT(inst, bits) ||
         TryExtractANDS_64_LOG_SHIFT(inst, bits) || TryExtractANDS_32_LOG_SHIFT(inst, bits) ||
         TryExtractAND_64_LOG_SHIFT(inst, bits) || TryExtractORN_32_LOG_SHIFT(inst, bits) ||
         TryExtractAND_32_LOG_SHIFT(inst, bits) || TryExtractEON_32_LOG_SHIFT(inst, bits) ||
         TryExtractORR_64_LOG_SHIFT(inst, bits) || TryExtractBICS_32_LOG_SHIFT(inst, bits) ||
         TryExtractEON_64_LOG_SHIFT(inst, bits) || TryExtractORN_64_LOG_SHIFT(inst, bits) ||
         TryExtractBICS_64_LOG_SHIFT(inst, bits) || TryExtractSUBS_64_ADDSUB_SHIFT(inst, bits) ||
         TryExtractBIC_64_LOG_SHIFT(inst, bits) || TryExtractADD_64_ADDSUB_SHIFT(inst, bits) ||
         TryExtractADD_32_ADDSUB_SHIFT(inst, bits) || TryExtractORR_32_LOG_SHIFT(inst, bits) ||
         TryExtractEOR_32_LOG_SHIFT(inst, bits) || TryExtractSUB_32_ADDSUB_SHIFT(inst, bits);
}

// 00001100000000000000000000000000
static bool TryExtract3(InstData &inst, uint32_t bits) {
  return false || TryExtractAESIMC_B_CRYPTOAES(inst, bits) ||
         TryExtractAESE_B_CRYPTOAES(inst, bits) || TryExtractAESD_B_CRYPTOAES(inst, bits) ||
         TryExtractAESMC_B_CRYPTOAES(inst, bits) || TryExtractFCVTPU_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFRSQRTE_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFRINTI_ASIMDMISCFP16_R(inst, bits) || TryExtractNOT_ASIMDMISC_R(inst, bits) ||
         TryExtractST2_ASISDLSO_D2_2D(inst, bits) || TryExtractST4_ASISDLSO_D4_4D(inst, bits) ||
         TryExtractST2_ASISDLSOP_D2_I2D(inst, bits) || TryExtractST3_ASISDLSO_D3_3D(inst, bits) ||
         TryExtractST3_ASISDLSOP_D3_I3D(inst, bits) ||
         TryExtractFCVTZU_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFCMLE_ASIMDMISCFP16_FZ(inst, bits) ||
         TryExtractST4_ASISDLSOP_D4_I4D(inst, bits) ||
         TryExtractFMINNMV_ASIMDALL_ONLY_H(inst, bits) ||
         TryExtractFMINV_ASIMDALL_ONLY_H(inst, bits) ||
         TryExtractUCVTF_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFMAXNMV_ASIMDALL_ONLY_H(inst, bits) ||
         TryExtractFCVTZS_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFRINTP_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFNEG_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFCMLT_ASIMDMISCFP16_FZ(inst, bits) ||
         TryExtractFABS_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFCVTMU_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractLD4_ASISDLSOP_D4_I4D(inst, bits) ||
         TryExtractSCVTF_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFCMGE_ASIMDMISCFP16_FZ(inst, bits) || TryExtractUMOV_ASIMDINS_X_X(inst, bits) ||
         TryExtractFRINTA_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractLD2_ASISDLSOP_D2_I2D(inst, bits) ||
         TryExtractFCVTMS_ASIMDMISCFP16_R(inst, bits) || TryExtractLD1_ASISDLSO_D1_1D(inst, bits) ||
         TryExtractFCVTPS_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFCMGT_ASIMDMISCFP16_FZ(inst, bits) ||
         TryExtractLD1_ASISDLSOP_D1_I1D(inst, bits) ||
         TryExtractFMAXV_ASIMDALL_ONLY_H(inst, bits) || TryExtractST1_ASISDLSO_D1_1D(inst, bits) ||
         TryExtractFRINTM_ASIMDMISCFP16_R(inst, bits) || TryExtractLD3_ASISDLSO_D3_3D(inst, bits) ||
         TryExtractST1_ASISDLSOP_D1_I1D(inst, bits) ||
         TryExtractFRINTZ_ASIMDMISCFP16_R(inst, bits) || TryExtractLD2_ASISDLSO_D2_2D(inst, bits) ||
         TryExtractFCVTNS_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFRECPE_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFCMEQ_ASIMDMISCFP16_FZ(inst, bits) ||
         TryExtractFRINTN_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFCVTAS_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFCVTAU_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFCVTNU_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFSQRT_ASIMDMISCFP16_R(inst, bits) ||
         TryExtractFRINTX_ASIMDMISCFP16_R(inst, bits) || TryExtractRBIT_ASIMDMISC_R(inst, bits) ||
         TryExtractLD3_ASISDLSOP_D3_I3D(inst, bits) || TryExtractLD4_ASISDLSO_D4_4D(inst, bits) ||
         TryExtractFRSQRTE_ASIMDMISC_R(inst, bits) || TryExtractFCMGE_ASIMDMISC_FZ(inst, bits) ||
         TryExtractST2_ASISDLSO_S2_2S(inst, bits) || TryExtractST4_ASISDLSO_S4_4S(inst, bits) ||
         TryExtractST2_ASISDLSOP_S2_I2S(inst, bits) || TryExtractFRINTZ_ASIMDMISC_R(inst, bits) ||
         TryExtractST3_ASISDLSOP_S3_I3S(inst, bits) || TryExtractFCMLE_ASIMDMISC_FZ(inst, bits) ||
         TryExtractFRINTM_ASIMDMISC_R(inst, bits) || TryExtractST4_ASISDLSOP_S4_I4S(inst, bits) ||
         TryExtractFCVTL_ASIMDMISC_L(inst, bits) ||
         TryExtractFMINNMV_ASIMDALL_ONLY_SD(inst, bits) ||
         TryExtractFMAXNMV_ASIMDALL_ONLY_SD(inst, bits) ||
         TryExtractUCVTF_ASIMDMISC_R(inst, bits) || TryExtractFMINV_ASIMDALL_ONLY_SD(inst, bits) ||
         TryExtractLD4_ASISDLSOP_S4_I4S(inst, bits) || TryExtractFCVTN_ASIMDMISC_N(inst, bits) ||
         TryExtractST1_ASISDLSOP_S1_I1S(inst, bits) || TryExtractFCVTXN_ASIMDMISC_N(inst, bits) ||
         TryExtractFRINTP_ASIMDMISC_R(inst, bits) || TryExtractLD4_ASISDLSO_S4_4S(inst, bits) ||
         TryExtractFRINTA_ASIMDMISC_R(inst, bits) || TryExtractFCVTZS_ASIMDMISC_R(inst, bits) ||
         TryExtractFCVTPU_ASIMDMISC_R(inst, bits) || TryExtractFCVTMS_ASIMDMISC_R(inst, bits) ||
         TryExtractST3_ASISDLSO_S3_3S(inst, bits) || TryExtractFNEG_ASIMDMISC_R(inst, bits) ||
         TryExtractST1_ASISDLSO_S1_1S(inst, bits) || TryExtractFRINTI_ASIMDMISC_R(inst, bits) ||
         TryExtractFCMLT_ASIMDMISC_FZ(inst, bits) || TryExtractFABS_ASIMDMISC_R(inst, bits) ||
         TryExtractURSQRTE_ASIMDMISC_R(inst, bits) || TryExtractSCVTF_ASIMDMISC_R(inst, bits) ||
         TryExtractLD1_ASISDLSO_S1_1S(inst, bits) || TryExtractFCVTAS_ASIMDMISC_R(inst, bits) ||
         TryExtractFCVTZU_ASIMDMISC_R(inst, bits) || TryExtractFCMGT_ASIMDMISC_FZ(inst, bits) ||
         TryExtractFCVTPS_ASIMDMISC_R(inst, bits) || TryExtractFSQRT_ASIMDMISC_R(inst, bits) ||
         TryExtractLD3_ASISDLSO_S3_3S(inst, bits) || TryExtractLD2_ASISDLSO_S2_2S(inst, bits) ||
         TryExtractFRINTN_ASIMDMISC_R(inst, bits) || TryExtractLD2_ASISDLSOP_S2_I2S(inst, bits) ||
         TryExtractFCVTNS_ASIMDMISC_R(inst, bits) || TryExtractFCMEQ_ASIMDMISC_FZ(inst, bits) ||
         TryExtractURECPE_ASIMDMISC_R(inst, bits) || TryExtractFCVTAU_ASIMDMISC_R(inst, bits) ||
         TryExtractFCVTNU_ASIMDMISC_R(inst, bits) || TryExtractFMAXV_ASIMDALL_ONLY_SD(inst, bits) ||
         TryExtractFRECPE_ASIMDMISC_R(inst, bits) || TryExtractFRINTX_ASIMDMISC_R(inst, bits) ||
         TryExtractFCVTMU_ASIMDMISC_R(inst, bits) || TryExtractLD1_ASISDLSOP_S1_I1S(inst, bits) ||
         TryExtractLD3_ASISDLSOP_S3_I3S(inst, bits) || TryExtractCMEQ_ASIMDMISC_Z(inst, bits) ||
         TryExtractCMLT_ASIMDMISC_Z(inst, bits) || TryExtractST2_ASISDLSE_R2(inst, bits) ||
         TryExtractST3_ASISDLSOP_H3_I3H(inst, bits) || TryExtractLD4R_ASISDLSO_R4(inst, bits) ||
         TryExtractST2_ASISDLSEP_I2_I(inst, bits) || TryExtractREV16_ASIMDMISC_R(inst, bits) ||
         TryExtractSQXTUN_ASIMDMISC_N(inst, bits) || TryExtractLD1_ASISDLSE_R4_4V(inst, bits) ||
         TryExtractMOVI_ASIMDIMM_D_DS(inst, bits) || TryExtractUADDLV_ASIMDALL_ONLY(inst, bits) ||
         TryExtractLD1_ASISDLSEP_I1_I1(inst, bits) || TryExtractLD1R_ASISDLSO_R1(inst, bits) ||
         TryExtractSHLL_ASIMDMISC_S(inst, bits) || TryExtractSUQADD_ASIMDMISC_R(inst, bits) ||
         TryExtractST4_ASISDLSO_H4_4H(inst, bits) || TryExtractST2_ASISDLSO_H2_2H(inst, bits) ||
         TryExtractSADDLP_ASIMDMISC_P(inst, bits) || TryExtractST2_ASISDLSOP_H2_I2H(inst, bits) ||
         TryExtractSMINV_ASIMDALL_ONLY(inst, bits) || TryExtractCMGT_ASIMDMISC_Z(inst, bits) ||
         TryExtractST4_ASISDLSOP_H4_I4H(inst, bits) || TryExtractNEG_ASIMDMISC_R(inst, bits) ||
         TryExtractCLS_ASIMDMISC_R(inst, bits) || TryExtractUQXTN_ASIMDMISC_N(inst, bits) ||
         TryExtractUSQADD_ASIMDMISC_R(inst, bits) || TryExtractLD2R_ASISDLSOP_R2_I(inst, bits) ||
         TryExtractLD3R_ASISDLSO_R3(inst, bits) || TryExtractLD3R_ASISDLSOP_R3_I(inst, bits) ||
         TryExtractCNT_ASIMDMISC_R(inst, bits) || TryExtractST3_ASISDLSEP_I3_I(inst, bits) ||
         TryExtractLD2R_ASISDLSO_R2(inst, bits) || TryExtractLD4_ASISDLSO_H4_4H(inst, bits) ||
         TryExtractLD4_ASISDLSOP_H4_I4H(inst, bits) || TryExtractSQABS_ASIMDMISC_R(inst, bits) ||
         TryExtractST3_ASISDLSE_R3(inst, bits) || TryExtractLD1_ASISDLSEP_I4_I4(inst, bits) ||
         TryExtractLD1_ASISDLSEP_I3_I3(inst, bits) || TryExtractABS_ASIMDMISC_R(inst, bits) ||
         TryExtractUMINV_ASIMDALL_ONLY(inst, bits) || TryExtractMOVI_ASIMDIMM_D2_D(inst, bits) ||
         TryExtractST1_ASISDLSE_R1_1V(inst, bits) || TryExtractST1_ASISDLSE_R2_2V(inst, bits) ||
         TryExtractST1_ASISDLSE_R3_3V(inst, bits) || TryExtractST1_ASISDLSE_R4_4V(inst, bits) ||
         TryExtractCLZ_ASIMDMISC_R(inst, bits) || TryExtractST1_ASISDLSEP_I1_I1(inst, bits) ||
         TryExtractST1_ASISDLSEP_I2_I2(inst, bits) || TryExtractST1_ASISDLSEP_I3_I3(inst, bits) ||
         TryExtractST1_ASISDLSEP_I4_I4(inst, bits) || TryExtractSQXTN_ASIMDMISC_N(inst, bits) ||
         TryExtractLD4R_ASISDLSOP_R4_I(inst, bits) || TryExtractUMAXV_ASIMDALL_ONLY(inst, bits) ||
         TryExtractSADALP_ASIMDMISC_P(inst, bits) || TryExtractUADDLP_ASIMDMISC_P(inst, bits) ||
         TryExtractLD1_ASISDLSO_H1_1H(inst, bits) || TryExtractLD1_ASISDLSOP_H1_I1H(inst, bits) ||
         TryExtractCMLE_ASIMDMISC_Z(inst, bits) || TryExtractSADDLV_ASIMDALL_ONLY(inst, bits) ||
         TryExtractST1_ASISDLSO_H1_1H(inst, bits) || TryExtractXTN_ASIMDMISC_N(inst, bits) ||
         TryExtractST1_ASISDLSOP_H1_I1H(inst, bits) || TryExtractLD2_ASISDLSO_H2_2H(inst, bits) ||
         TryExtractLD2_ASISDLSOP_H2_I2H(inst, bits) || TryExtractREV32_ASIMDMISC_R(inst, bits) ||
         TryExtractLD3_ASISDLSOP_H3_I3H(inst, bits) || TryExtractUADALP_ASIMDMISC_P(inst, bits) ||
         TryExtractCMGE_ASIMDMISC_Z(inst, bits) || TryExtractFMOV_ASIMDIMM_D2_D(inst, bits) ||
         TryExtractST4_ASISDLSE_R4(inst, bits) || TryExtractLD3_ASISDLSE_R3(inst, bits) ||
         TryExtractADDV_ASIMDALL_ONLY(inst, bits) || TryExtractLD1R_ASISDLSOP_R1_I(inst, bits) ||
         TryExtractLD4_ASISDLSE_R4(inst, bits) || TryExtractLD4_ASISDLSEP_I4_I(inst, bits) ||
         TryExtractLD1_ASISDLSE_R2_2V(inst, bits) || TryExtractLD1_ASISDLSE_R3_3V(inst, bits) ||
         TryExtractSMAXV_ASIMDALL_ONLY(inst, bits) || TryExtractLD1_ASISDLSEP_I2_I2(inst, bits) ||
         TryExtractST4_ASISDLSEP_I4_I(inst, bits) || TryExtractLD2_ASISDLSE_R2(inst, bits) ||
         TryExtractLD3_ASISDLSO_H3_3H(inst, bits) || TryExtractST3_ASISDLSO_H3_3H(inst, bits) ||
         TryExtractLD2_ASISDLSEP_I2_I(inst, bits) || TryExtractLD1_ASISDLSE_R1_1V(inst, bits) ||
         TryExtractLD3_ASISDLSEP_I3_I(inst, bits) || TryExtractREV64_ASIMDMISC_R(inst, bits) ||
         TryExtractSQNEG_ASIMDMISC_R(inst, bits) || TryExtractST4_ASISDLSO_B4_4B(inst, bits) ||
         TryExtractST4_ASISDLSOP_B4_I4B(inst, bits) || TryExtractMOVI_ASIMDIMM_N_B(inst, bits) ||
         TryExtractST2_ASISDLSO_B2_2B(inst, bits) || TryExtractST2_ASISDLSOP_B2_I2B(inst, bits) ||
         TryExtractST3_ASISDLSOP_B3_I3B(inst, bits) || TryExtractFMOV_ASIMDIMM_H_H(inst, bits) ||
         TryExtractFMOV_ASIMDIMM_S_S(inst, bits) || TryExtractLD4_ASISDLSO_B4_4B(inst, bits) ||
         TryExtractLD3_ASISDLSO_B3_3B(inst, bits) || TryExtractLD4_ASISDLSOP_B4_I4B(inst, bits) ||
         TryExtractLD1_ASISDLSO_B1_1B(inst, bits) || TryExtractLD1_ASISDLSOP_B1_I1B(inst, bits) ||
         TryExtractST1_ASISDLSO_B1_1B(inst, bits) || TryExtractST1_ASISDLSOP_B1_I1B(inst, bits) ||
         TryExtractLD2_ASISDLSO_B2_2B(inst, bits) || TryExtractLD2_ASISDLSOP_B2_I2B(inst, bits) ||
         TryExtractST3_ASISDLSO_B3_3B(inst, bits) || TryExtractLD3_ASISDLSOP_B3_I3B(inst, bits) ||
         TryExtractBIC_ASIMDIMM_L_HL(inst, bits) || TryExtractMOVI_ASIMDIMM_L_HL(inst, bits) ||
         TryExtractMOVI_ASIMDIMM_M_SM(inst, bits) || TryExtractSMOV_ASIMDINS_X_X(inst, bits) ||
         TryExtractUMOV_ASIMDINS_W_W(inst, bits) || TryExtractSMOV_ASIMDINS_W_W(inst, bits) ||
         TryExtractMVNI_ASIMDIMM_M_SM(inst, bits) || TryExtractMVNI_ASIMDIMM_L_HL(inst, bits) ||
         TryExtractINS_ASIMDINS_IR_R(inst, bits) || TryExtractORR_ASIMDIMM_L_HL(inst, bits) ||
         TryExtractEOR_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFMAXNM_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractBIC_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFMUL_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFRECPS_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractORR_ASIMDSAME_ONLY(inst, bits) || TryExtractST4_ASISDLSOP_DX4_R4D(inst, bits) ||
         TryExtractFMIN_ASIMDSAMEFP16_ONLY(inst, bits) || TryExtractTBX_ASIMDTBL_L2_2(inst, bits) ||
         TryExtractFMAX_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFACGE_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractMOVI_ASIMDIMM_L_SL(inst, bits) || TryExtractBIC_ASIMDIMM_L_SL(inst, bits) ||
         TryExtractBIF_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFDIV_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractST2_ASISDLSOP_DX2_R2D(inst, bits) ||
         TryExtractFMAXP_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractST3_ASISDLSOP_DX3_R3D(inst, bits) ||
         TryExtractFABD_ASIMDSAMEFP16_ONLY(inst, bits) || TryExtractDUP_ASIMDINS_DR_R(inst, bits) ||
         TryExtractORN_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFMLS_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFMINP_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFMULX_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFMAXNMP_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFRSQRTS_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFADD_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractAND_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFMINNM_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFSUB_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFMLA_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFADDP_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractTBL_ASIMDTBL_L2_2(inst, bits) || TryExtractTBL_ASIMDTBL_L3_3(inst, bits) ||
         TryExtractTBL_ASIMDTBL_L1_1(inst, bits) ||
         TryExtractFMINNMP_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractLD1_ASISDLSOP_DX1_R1D(inst, bits) || TryExtractDUP_ASIMDINS_DV_V(inst, bits) ||
         TryExtractTBL_ASIMDTBL_L4_4(inst, bits) || TryExtractST1_ASISDLSOP_DX1_R1D(inst, bits) ||
         TryExtractLD4_ASISDLSOP_DX4_R4D(inst, bits) ||
         TryExtractLD2_ASISDLSOP_DX2_R2D(inst, bits) || TryExtractMVNI_ASIMDIMM_L_SL(inst, bits) ||
         TryExtractFCMGT_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFCMGE_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractBIT_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFCMEQ_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractTBX_ASIMDTBL_L3_3(inst, bits) || TryExtractTBX_ASIMDTBL_L1_1(inst, bits) ||
         TryExtractTBX_ASIMDTBL_L4_4(inst, bits) ||
         TryExtractFACGT_ASIMDSAMEFP16_ONLY(inst, bits) ||
         TryExtractBSL_ASIMDSAME_ONLY(inst, bits) || TryExtractORR_ASIMDIMM_L_SL(inst, bits) ||
         TryExtractLD3_ASISDLSOP_DX3_R3D(inst, bits) ||
         TryExtractFMAXNM_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractST4_ASISDLSOP_SX4_R4S(inst, bits) ||
         TryExtractFRECPS_ASIMDSAME_ONLY(inst, bits) || TryExtractFMAX_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractLD3_ASISDLSOP_SX3_R3S(inst, bits) || TryExtractFABD_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractST2_ASISDLSOP_SX2_R2S(inst, bits) ||
         TryExtractST3_ASISDLSOP_SX3_R3S(inst, bits) || TryExtractFDIV_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFMAXNMP_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFACGT_ASIMDSAME_ONLY(inst, bits) || TryExtractFCMGE_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFMINP_ASIMDSAME_ONLY(inst, bits) || TryExtractFMLA_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFCMGT_ASIMDSAME_ONLY(inst, bits) || TryExtractFMAXP_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFMLS_ASIMDSAME_ONLY(inst, bits) || TryExtractFMIN_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFMULX_ASIMDSAME_ONLY(inst, bits) || TryExtractFMUL_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractLD4_ASISDLSOP_SX4_R4S(inst, bits) || TryExtractFSUB_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFADDP_ASIMDSAME_ONLY(inst, bits) || TryExtractFADD_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFACGE_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractLD1_ASISDLSOP_SX1_R1S(inst, bits) ||
         TryExtractFMINNM_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractST1_ASISDLSOP_SX1_R1S(inst, bits) ||
         TryExtractLD2_ASISDLSOP_SX2_R2S(inst, bits) ||
         TryExtractFCMEQ_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFRSQRTS_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractFMINNMP_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSRSHL_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSQDMULH_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSQSUB_ASIMDSAME_ONLY(inst, bits) || TryExtractZIP2_ASIMDPERM_ONLY(inst, bits) ||
         TryExtractURSHL_ASIMDSAME_ONLY(inst, bits) || TryExtractSMINP_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractADD_ASIMDSAME_ONLY(inst, bits) || TryExtractSQSHRN_ASIMDSHF_N(inst, bits) ||
         TryExtractSQSHLU_ASIMDSHF_R(inst, bits) || TryExtractPMUL_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractUMULL_ASIMDDIFF_L(inst, bits) || TryExtractSQDMLSL_ASIMDDIFF_L(inst, bits) ||
         TryExtractUHSUB_ASIMDSAME_ONLY(inst, bits) || TryExtractLD1_ASISDLSEP_R1_R1(inst, bits) ||
         TryExtractSSHL_ASIMDSAME_ONLY(inst, bits) || TryExtractUADDL_ASIMDDIFF_L(inst, bits) ||
         TryExtractUMAXP_ASIMDSAME_ONLY(inst, bits) || TryExtractSADDW_ASIMDDIFF_W(inst, bits) ||
         TryExtractLD1R_ASISDLSOP_RX1_R(inst, bits) || TryExtractCMTST_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractUSHL_ASIMDSAME_ONLY(inst, bits) || TryExtractURHADD_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractST2_ASISDLSOP_HX2_R2H(inst, bits) ||
         TryExtractST3_ASISDLSOP_HX3_R3H(inst, bits) ||
         TryExtractUQRSHL_ASIMDSAME_ONLY(inst, bits) || TryExtractUMLAL_ASIMDDIFF_L(inst, bits) ||
         TryExtractSHSUB_ASIMDSAME_ONLY(inst, bits) || TryExtractSHADD_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractCMEQ_ASIMDSAME_ONLY(inst, bits) || TryExtractSMLAL_ASIMDDIFF_L(inst, bits) ||
         TryExtractSQSHRUN_ASIMDSHF_N(inst, bits) || TryExtractST4_ASISDLSOP_HX4_R4H(inst, bits) ||
         TryExtractUABD_ASIMDSAME_ONLY(inst, bits) || TryExtractUSRA_ASIMDSHF_R(inst, bits) ||
         TryExtractSRSRA_ASIMDSHF_R(inst, bits) || TryExtractMLS_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractMLA_ASIMDSAME_ONLY(inst, bits) || TryExtractSQSHL_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSQRSHRUN_ASIMDSHF_N(inst, bits) || TryExtractUZP2_ASIMDPERM_ONLY(inst, bits) ||
         TryExtractLD4_ASISDLSEP_R4_R(inst, bits) || TryExtractLD3R_ASISDLSOP_RX3_R(inst, bits) ||
         TryExtractTRN2_ASIMDPERM_ONLY(inst, bits) || TryExtractUSUBL_ASIMDDIFF_L(inst, bits) ||
         TryExtractUQSUB_ASIMDSAME_ONLY(inst, bits) || TryExtractSQRSHRN_ASIMDSHF_N(inst, bits) ||
         TryExtractST3_ASISDLSEP_R3_R(inst, bits) || TryExtractCMGT_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSRI_ASIMDSHF_R(inst, bits) || TryExtractSABD_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSABDL_ASIMDDIFF_L(inst, bits) || TryExtractSADDL_ASIMDDIFF_L(inst, bits) ||
         TryExtractSSUBL_ASIMDDIFF_L(inst, bits) || TryExtractUABDL_ASIMDDIFF_L(inst, bits) ||
         TryExtractLD1_ASISDLSEP_R3_R3(inst, bits) || TryExtractUADDW_ASIMDDIFF_W(inst, bits) ||
         TryExtractLD1_ASISDLSEP_R4_R4(inst, bits) || TryExtractSSUBW_ASIMDDIFF_W(inst, bits) ||
         TryExtractSQRDMLSH_ASIMDSAME2_ONLY(inst, bits) ||
         TryExtractUQSHRN_ASIMDSHF_N(inst, bits) || TryExtractSMULL_ASIMDDIFF_L(inst, bits) ||
         TryExtractURSHR_ASIMDSHF_R(inst, bits) || TryExtractSUBHN_ASIMDDIFF_N(inst, bits) ||
         TryExtractLD4_ASISDLSOP_HX4_R4H(inst, bits) || TryExtractST2_ASISDLSEP_R2_R(inst, bits) ||
         TryExtractSQSHL_ASIMDSHF_R(inst, bits) || TryExtractFCVTZU_ASIMDSHF_C(inst, bits) ||
         TryExtractRSHRN_ASIMDSHF_N(inst, bits) || TryExtractFMUL_ASIMDELEM_RH_H(inst, bits) ||
         TryExtractUSHR_ASIMDSHF_R(inst, bits) || TryExtractCMHI_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSCVTF_ASIMDSHF_C(inst, bits) || TryExtractSMAXP_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractADDP_ASIMDSAME_ONLY(inst, bits) || TryExtractST1_ASISDLSEP_R1_R1(inst, bits) ||
         TryExtractST1_ASISDLSEP_R2_R2(inst, bits) || TryExtractST1_ASISDLSEP_R3_R3(inst, bits) ||
         TryExtractST1_ASISDLSEP_R4_R4(inst, bits) || TryExtractSMAX_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSQDMLAL_ASIMDDIFF_L(inst, bits) || TryExtractUQADD_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSMLSL_ASIMDDIFF_L(inst, bits) || TryExtractFMLA_ASIMDELEM_RH_H(inst, bits) ||
         TryExtractUCVTF_ASIMDSHF_C(inst, bits) || TryExtractSSRA_ASIMDSHF_R(inst, bits) ||
         TryExtractUMAX_ASIMDSAME_ONLY(inst, bits) || TryExtractTRN1_ASIMDPERM_ONLY(inst, bits) ||
         TryExtractSRHADD_ASIMDSAME_ONLY(inst, bits) || TryExtractSUB_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSQRDMULH_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractLD4R_ASISDLSOP_RX4_R(inst, bits) || TryExtractFMULX_ASIMDELEM_RH_H(inst, bits) ||
         TryExtractLD1_ASISDLSOP_HX1_R1H(inst, bits) || TryExtractUSUBW_ASIMDDIFF_W(inst, bits) ||
         TryExtractZIP1_ASIMDPERM_ONLY(inst, bits) || TryExtractUMLSL_ASIMDDIFF_L(inst, bits) ||
         TryExtractSABA_ASIMDSAME_ONLY(inst, bits) || TryExtractSHRN_ASIMDSHF_N(inst, bits) ||
         TryExtractSQDMULL_ASIMDDIFF_L(inst, bits) || TryExtractLD2R_ASISDLSOP_RX2_R(inst, bits) ||
         TryExtractST1_ASISDLSOP_HX1_R1H(inst, bits) ||
         TryExtractUQSHL_ASIMDSAME_ONLY(inst, bits) || TryExtractFMLS_ASIMDELEM_RH_H(inst, bits) ||
         TryExtractLD2_ASISDLSOP_HX2_R2H(inst, bits) || TryExtractUABAL_ASIMDDIFF_L(inst, bits) ||
         TryExtractCMGE_ASIMDSAME_ONLY(inst, bits) || TryExtractFCVTZS_ASIMDSHF_C(inst, bits) ||
         TryExtractLD1_ASISDLSEP_R2_R2(inst, bits) || TryExtractSRSHR_ASIMDSHF_R(inst, bits) ||
         TryExtractCMHS_ASIMDSAME_ONLY(inst, bits) || TryExtractUHADD_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractSSHR_ASIMDSHF_R(inst, bits) || TryExtractSQRSHL_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractUMIN_ASIMDSAME_ONLY(inst, bits) || TryExtractRADDHN_ASIMDDIFF_N(inst, bits) ||
         TryExtractSMIN_ASIMDSAME_ONLY(inst, bits) || TryExtractLD3_ASISDLSEP_R3_R(inst, bits) ||
         TryExtractUZP1_ASIMDPERM_ONLY(inst, bits) || TryExtractUABA_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractPMULL_ASIMDDIFF_L(inst, bits) || TryExtractSQADD_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractUQSHL_ASIMDSHF_R(inst, bits) || TryExtractUSHLL_ASIMDSHF_L(inst, bits) ||
         TryExtractUQRSHRN_ASIMDSHF_N(inst, bits) || TryExtractSHL_ASIMDSHF_R(inst, bits) ||
         TryExtractMUL_ASIMDSAME_ONLY(inst, bits) || TryExtractURSRA_ASIMDSHF_R(inst, bits) ||
         TryExtractRSUBHN_ASIMDDIFF_N(inst, bits) || TryExtractLD2_ASISDLSEP_R2_R(inst, bits) ||
         TryExtractSSHLL_ASIMDSHF_L(inst, bits) || TryExtractST4_ASISDLSEP_R4_R(inst, bits) ||
         TryExtractUMINP_ASIMDSAME_ONLY(inst, bits) ||
         TryExtractLD3_ASISDLSOP_HX3_R3H(inst, bits) || TryExtractADDHN_ASIMDDIFF_N(inst, bits) ||
         TryExtractSABAL_ASIMDDIFF_L(inst, bits) ||
         TryExtractSQRDMLAH_ASIMDSAME2_ONLY(inst, bits) || TryExtractSLI_ASIMDSHF_R(inst, bits) ||
         TryExtractST4_ASISDLSOP_BX4_R4B(inst, bits) || TryExtractINS_ASIMDINS_IV_V(inst, bits) ||
         TryExtractST2_ASISDLSOP_BX2_R2B(inst, bits) ||
         TryExtractST3_ASISDLSOP_BX3_R3B(inst, bits) ||
         TryExtractST1_ASISDLSOP_BX1_R1B(inst, bits) || TryExtractFMLS_ASIMDELEM_R_SD(inst, bits) ||
         TryExtractFMUL_ASIMDELEM_R_SD(inst, bits) || TryExtractLD4_ASISDLSOP_BX4_R4B(inst, bits) ||
         TryExtractFMLA_ASIMDELEM_R_SD(inst, bits) || TryExtractLD2_ASISDLSOP_BX2_R2B(inst, bits) ||
         TryExtractLD1_ASISDLSOP_BX1_R1B(inst, bits) ||
         TryExtractLD3_ASISDLSOP_BX3_R3B(inst, bits) ||
         TryExtractFMULX_ASIMDELEM_R_SD(inst, bits) || TryExtractSQDMULL_ASIMDELEM_L(inst, bits) ||
         TryExtractUMLSL_ASIMDELEM_L(inst, bits) || TryExtractUMULL_ASIMDELEM_L(inst, bits) ||
         TryExtractMLS_ASIMDELEM_R(inst, bits) || TryExtractSQRDMLSH_ASIMDELEM_R(inst, bits) ||
         TryExtractSMLAL_ASIMDELEM_L(inst, bits) || TryExtractMUL_ASIMDELEM_R(inst, bits) ||
         TryExtractSQRDMULH_ASIMDELEM_R(inst, bits) || TryExtractSQRDMLAH_ASIMDELEM_R(inst, bits) ||
         TryExtractSMULL_ASIMDELEM_L(inst, bits) || TryExtractSMLSL_ASIMDELEM_L(inst, bits) ||
         TryExtractSQDMLSL_ASIMDELEM_L(inst, bits) || TryExtractEXT_ASIMDEXT_ONLY(inst, bits) ||
         TryExtractMLA_ASIMDELEM_R(inst, bits) || TryExtractSQDMLAL_ASIMDELEM_L(inst, bits) ||
         TryExtractUMLAL_ASIMDELEM_L(inst, bits) || TryExtractSQDMULH_ASIMDELEM_R(inst, bits) ||
         TryExtractLDNP_Q_LDSTNAPAIR_OFFS(inst, bits) ||
         TryExtractSTP_S_LDSTPAIR_POST(inst, bits) || TryExtractLDP_D_LDSTPAIR_OFF(inst, bits) ||
         TryExtractLDP_S_LDSTPAIR_POST(inst, bits) || TryExtractLDP_D_LDSTPAIR_POST(inst, bits) ||
         TryExtractLDP_Q_LDSTPAIR_POST(inst, bits) || TryExtractLDP_S_LDSTPAIR_PRE(inst, bits) ||
         TryExtractLDP_Q_LDSTPAIR_PRE(inst, bits) || TryExtractLDP_S_LDSTPAIR_OFF(inst, bits) ||
         TryExtractLDP_Q_LDSTPAIR_OFF(inst, bits) || TryExtractLDP_D_LDSTPAIR_PRE(inst, bits) ||
         TryExtractSTP_Q_LDSTPAIR_POST(inst, bits) ||
         TryExtractSTNP_D_LDSTNAPAIR_OFFS(inst, bits) ||
         TryExtractLDNP_D_LDSTNAPAIR_OFFS(inst, bits) || TryExtractSTP_Q_LDSTPAIR_OFF(inst, bits) ||
         TryExtractSTP_Q_LDSTPAIR_PRE(inst, bits) || TryExtractSTP_S_LDSTPAIR_OFF(inst, bits) ||
         TryExtractSTP_D_LDSTPAIR_OFF(inst, bits) || TryExtractSTNP_Q_LDSTNAPAIR_OFFS(inst, bits) ||
         TryExtractSTNP_S_LDSTNAPAIR_OFFS(inst, bits) ||
         TryExtractSTP_D_LDSTPAIR_POST(inst, bits) || TryExtractSTP_S_LDSTPAIR_PRE(inst, bits) ||
         TryExtractSTP_D_LDSTPAIR_PRE(inst, bits) || TryExtractLDNP_S_LDSTNAPAIR_OFFS(inst, bits);
}

// 00010000000000000000000000000000
static bool TryExtract4(InstData &inst, uint32_t bits) {
  return false || TryExtractEXTR_32_EXTRACT(inst, bits) || TryExtractEXTR_64_EXTRACT(inst, bits) ||
         TryExtractEOR_32_LOG_IMM(inst, bits) || TryExtractBFM_32M_BITFIELD(inst, bits) ||
         TryExtractSBFM_32M_BITFIELD(inst, bits) || TryExtractUBFM_64M_BITFIELD(inst, bits) ||
         TryExtractBFM_64M_BITFIELD(inst, bits) || TryExtractAND_32_LOG_IMM(inst, bits) ||
         TryExtractSBFM_64M_BITFIELD(inst, bits) || TryExtractANDS_32S_LOG_IMM(inst, bits) ||
         TryExtractUBFM_32M_BITFIELD(inst, bits) || TryExtractORR_32_LOG_IMM(inst, bits) ||
         TryExtractORR_64_LOG_IMM(inst, bits) || TryExtractMOVN_64_MOVEWIDE(inst, bits) ||
         TryExtractMOVZ_64_MOVEWIDE(inst, bits) || TryExtractMOVK_32_MOVEWIDE(inst, bits) ||
         TryExtractAND_64_LOG_IMM(inst, bits) || TryExtractMOVZ_32_MOVEWIDE(inst, bits) ||
         TryExtractMOVN_32_MOVEWIDE(inst, bits) || TryExtractMOVK_64_MOVEWIDE(inst, bits) ||
         TryExtractANDS_64S_LOG_IMM(inst, bits) || TryExtractEOR_64_LOG_IMM(inst, bits) ||
         TryExtractADD_32_ADDSUB_IMM(inst, bits) || TryExtractSUB_32_ADDSUB_IMM(inst, bits) ||
         TryExtractADDS_32S_ADDSUB_IMM(inst, bits) || TryExtractSUBS_64S_ADDSUB_IMM(inst, bits) ||
         TryExtractSUBS_32S_ADDSUB_IMM(inst, bits) || TryExtractSUB_64_ADDSUB_IMM(inst, bits) ||
         TryExtractADDS_64S_ADDSUB_IMM(inst, bits) || TryExtractADD_64_ADDSUB_IMM(inst, bits) ||
         TryExtractADR_ONLY_PCRELADDR(inst, bits) || TryExtractADRP_ONLY_PCRELADDR(inst, bits);
}

// 00010100000000000000000000000000
static bool TryExtract5(InstData &inst, uint32_t bits) {
  return false || TryExtractWFI_HI_SYSTEM(inst, bits) ||
         TryExtractERET_64E_BRANCH_REG(inst, bits) || TryExtractESB_HI_SYSTEM(inst, bits) ||
         TryExtractDRPS_64E_BRANCH_REG(inst, bits) || TryExtractWFE_HI_SYSTEM(inst, bits) ||
         TryExtractNOP_HI_SYSTEM(inst, bits) || TryExtractSEV_HI_SYSTEM(inst, bits) ||
         TryExtractPSB_HC_SYSTEM(inst, bits) || TryExtractYIELD_HI_SYSTEM(inst, bits) ||
         TryExtractSEVL_HI_SYSTEM(inst, bits) || TryExtractHINT_1(inst, bits) ||
         TryExtractHINT_3(inst, bits) || TryExtractDSB_BO_SYSTEM(inst, bits) ||
         TryExtractISB_BI_SYSTEM(inst, bits) || TryExtractCLREX_BN_SYSTEM(inst, bits) ||
         TryExtractDMB_BO_SYSTEM(inst, bits) || TryExtractBLR_64_BRANCH_REG(inst, bits) ||
         TryExtractBR_64_BRANCH_REG(inst, bits) || TryExtractRET_64R_BRANCH_REG(inst, bits) ||
         TryExtractHINT_2(inst, bits) || TryExtractMSR_SI_SYSTEM(inst, bits) ||
         TryExtractDCPS3_DC_EXCEPTION(inst, bits) || TryExtractDCPS2_DC_EXCEPTION(inst, bits) ||
         TryExtractBRK_EX_EXCEPTION(inst, bits) || TryExtractHVC_EX_EXCEPTION(inst, bits) ||
         TryExtractDCPS1_DC_EXCEPTION(inst, bits) || TryExtractHLT_EX_EXCEPTION(inst, bits) ||
         TryExtractSMC_EX_EXCEPTION(inst, bits) || TryExtractSVC_EX_EXCEPTION(inst, bits) ||
         TryExtractSYS_CR_SYSTEM(inst, bits) || TryExtractSYSL_RC_SYSTEM(inst, bits) ||
         TryExtractMRS_RS_SYSTEM(inst, bits) || TryExtractMSR_SR_SYSTEM(inst, bits) ||
         TryExtractB_ONLY_CONDBRANCH(inst, bits) || TryExtractCBZ_64_COMPBRANCH(inst, bits) ||
         TryExtractCBNZ_32_COMPBRANCH(inst, bits) || TryExtractCBZ_32_COMPBRANCH(inst, bits) ||
         TryExtractCBNZ_64_COMPBRANCH(inst, bits) || TryExtractTBZ_ONLY_TESTBRANCH(inst, bits) ||
         TryExtractTBNZ_ONLY_TESTBRANCH(inst, bits) || TryExtractBL_ONLY_BRANCH_IMM(inst, bits) ||
         TryExtractB_ONLY_BRANCH_IMM(inst, bits);
}

// 00011000000000000000000000000000
static bool TryExtract6(InstData &inst, uint32_t bits) {
  return false || TryExtractSTADD_32S_MEMOP(inst, bits) ||
         TryExtractSTUMINLH_32S_MEMOP(inst, bits) || TryExtractSTUMAXLB_32S_MEMOP(inst, bits) ||
         TryExtractREV_64_DP_1SRC(inst, bits) || TryExtractREV_32_DP_1SRC(inst, bits) ||
         TryExtractSTSMAXH_32S_MEMOP(inst, bits) || TryExtractCLZ_32_DP_1SRC(inst, bits) ||
         TryExtractSTUMINH_32S_MEMOP(inst, bits) || TryExtractSTSMAXLH_32S_MEMOP(inst, bits) ||
         TryExtractCLS_32_DP_1SRC(inst, bits) || TryExtractSTUMINB_32S_MEMOP(inst, bits) ||
         TryExtractSTEORLH_32S_MEMOP(inst, bits) || TryExtractSTEORH_32S_MEMOP(inst, bits) ||
         TryExtractSTADD_64S_MEMOP(inst, bits) || TryExtractSTSMAXL_64S_MEMOP(inst, bits) ||
         TryExtractSTUMINLB_32S_MEMOP(inst, bits) || TryExtractCLS_64_DP_1SRC(inst, bits) ||
         TryExtractSTCLRL_64S_MEMOP(inst, bits) || TryExtractSTSETB_32S_MEMOP(inst, bits) ||
         TryExtractSTCLRH_32S_MEMOP(inst, bits) || TryExtractSTADDB_32S_MEMOP(inst, bits) ||
         TryExtractSTUMIN_32S_MEMOP(inst, bits) || TryExtractSTADDL_32S_MEMOP(inst, bits) ||
         TryExtractSTUMINL_64S_MEMOP(inst, bits) || TryExtractSTUMIN_64S_MEMOP(inst, bits) ||
         TryExtractSTADDL_64S_MEMOP(inst, bits) || TryExtractSTUMAXH_32S_MEMOP(inst, bits) ||
         TryExtractREV16_32_DP_1SRC(inst, bits) || TryExtractSTSET_32S_MEMOP(inst, bits) ||
         TryExtractSTSETL_32S_MEMOP(inst, bits) || TryExtractSTSETL_64S_MEMOP(inst, bits) ||
         TryExtractSTSMINH_32S_MEMOP(inst, bits) || TryExtractSTSMINLH_32S_MEMOP(inst, bits) ||
         TryExtractSTUMAXB_32S_MEMOP(inst, bits) || TryExtractSTUMINL_32S_MEMOP(inst, bits) ||
         TryExtractSTCLRLB_32S_MEMOP(inst, bits) || TryExtractSTSMINL_64S_MEMOP(inst, bits) ||
         TryExtractSTCLR_32S_MEMOP(inst, bits) || TryExtractSTCLRB_32S_MEMOP(inst, bits) ||
         TryExtractSTSMAXB_32S_MEMOP(inst, bits) || TryExtractSTSMINL_32S_MEMOP(inst, bits) ||
         TryExtractSTEORLB_32S_MEMOP(inst, bits) || TryExtractSTEORB_32S_MEMOP(inst, bits) ||
         TryExtractSTEORL_32S_MEMOP(inst, bits) || TryExtractSTCLRLH_32S_MEMOP(inst, bits) ||
         TryExtractSTSMAX_64S_MEMOP(inst, bits) || TryExtractSTADDLH_32S_MEMOP(inst, bits) ||
         TryExtractCLZ_64_DP_1SRC(inst, bits) || TryExtractSTADDH_32S_MEMOP(inst, bits) ||
         TryExtractSTSMAX_32S_MEMOP(inst, bits) || TryExtractSTSMAXL_32S_MEMOP(inst, bits) ||
         TryExtractSTSMINLB_32S_MEMOP(inst, bits) || TryExtractSTSMINB_32S_MEMOP(inst, bits) ||
         TryExtractSTUMAXLH_32S_MEMOP(inst, bits) || TryExtractSTADDLB_32S_MEMOP(inst, bits) ||
         TryExtractREV32_64_DP_1SRC(inst, bits) || TryExtractSTSMAXLB_32S_MEMOP(inst, bits) ||
         TryExtractRBIT_64_DP_1SRC(inst, bits) || TryExtractSTSETLB_32S_MEMOP(inst, bits) ||
         TryExtractSTEOR_32S_MEMOP(inst, bits) || TryExtractRBIT_32_DP_1SRC(inst, bits) ||
         TryExtractSTCLR_64S_MEMOP(inst, bits) || TryExtractSTCLRL_32S_MEMOP(inst, bits) ||
         TryExtractSTSETLH_32S_MEMOP(inst, bits) || TryExtractSTSET_64S_MEMOP(inst, bits) ||
         TryExtractSTUMAX_32S_MEMOP(inst, bits) || TryExtractSTUMAXL_32S_MEMOP(inst, bits) ||
         TryExtractSTEOR_64S_MEMOP(inst, bits) || TryExtractSTEORL_64S_MEMOP(inst, bits) ||
         TryExtractSTUMAX_64S_MEMOP(inst, bits) || TryExtractSTSMIN_64S_MEMOP(inst, bits) ||
         TryExtractSTUMAXL_64S_MEMOP(inst, bits) || TryExtractSTSMIN_32S_MEMOP(inst, bits) ||
         TryExtractSTSETH_32S_MEMOP(inst, bits) || TryExtractREV16_64_DP_1SRC(inst, bits) ||
         TryExtractLSLV_32_DP_2SRC(inst, bits) || TryExtractLDSMAXALB_32_MEMOP(inst, bits) ||
         TryExtractSBC_64_ADDSUB_CARRY(inst, bits) || TryExtractLDSMAXAB_32_MEMOP(inst, bits) ||
         TryExtractLDUMINALB_32_MEMOP(inst, bits) || TryExtractLSLV_64_DP_2SRC(inst, bits) ||
         TryExtractLDADDALB_32_MEMOP(inst, bits) || TryExtractLDSMAXB_32_MEMOP(inst, bits) ||
         TryExtractLDADDAB_32_MEMOP(inst, bits) || TryExtractLDSETALB_32_MEMOP(inst, bits) ||
         TryExtractLDSETLB_32_MEMOP(inst, bits) || TryExtractLDSETB_32_MEMOP(inst, bits) ||
         TryExtractLDUMAXA_64_MEMOP(inst, bits) || TryExtractLDSMINA_32_MEMOP(inst, bits) ||
         TryExtractSWPAB_32_MEMOP(inst, bits) || TryExtractLDEORB_32_MEMOP(inst, bits) ||
         TryExtractSWPALH_32_MEMOP(inst, bits) || TryExtractLDSMINAL_32_MEMOP(inst, bits) ||
         TryExtractADC_32_ADDSUB_CARRY(inst, bits) || TryExtractLDEORLB_32_MEMOP(inst, bits) ||
         TryExtractLDEORH_32_MEMOP(inst, bits) || TryExtractLDSMINL_32_MEMOP(inst, bits) ||
         TryExtractLDEORA_32_MEMOP(inst, bits) || TryExtractLDEORAL_32_MEMOP(inst, bits) ||
         TryExtractLDEOR_32_MEMOP(inst, bits) || TryExtractLDEORL_32_MEMOP(inst, bits) ||
         TryExtractLDEORA_64_MEMOP(inst, bits) || TryExtractLDEORAL_64_MEMOP(inst, bits) ||
         TryExtractSDIV_64_DP_2SRC(inst, bits) || TryExtractLDEOR_64_MEMOP(inst, bits) ||
         TryExtractLDEORL_64_MEMOP(inst, bits) || TryExtractUDIV_32_DP_2SRC(inst, bits) ||
         TryExtractLDSMAXALH_32_MEMOP(inst, bits) || TryExtractLDEORLH_32_MEMOP(inst, bits) ||
         TryExtractLDUMAXAL_64_MEMOP(inst, bits) || TryExtractLDSMAXAL_32_MEMOP(inst, bits) ||
         TryExtractLDEORAB_32_MEMOP(inst, bits) || TryExtractADC_64_ADDSUB_CARRY(inst, bits) ||
         TryExtractLDEORALB_32_MEMOP(inst, bits) || TryExtractSWPALB_32_MEMOP(inst, bits) ||
         TryExtractLDADDLB_32_MEMOP(inst, bits) || TryExtractSWPL_32_MEMOP(inst, bits) ||
         TryExtractSWPL_64_MEMOP(inst, bits) || TryExtractSWPAL_64_MEMOP(inst, bits) ||
         TryExtractSWP_32_MEMOP(inst, bits) || TryExtractUMULH_64_DP_3SRC(inst, bits) ||
         TryExtractSWPA_64_MEMOP(inst, bits) || TryExtractSWPLB_32_MEMOP(inst, bits) ||
         TryExtractSBC_32_ADDSUB_CARRY(inst, bits) || TryExtractSWP_64_MEMOP(inst, bits) ||
         TryExtractLDSMAXLB_32_MEMOP(inst, bits) || TryExtractLSRV_64_DP_2SRC(inst, bits) ||
         TryExtractLDUMAXA_32_MEMOP(inst, bits) || TryExtractLDUMAX_32_MEMOP(inst, bits) ||
         TryExtractLDUMAXL_32_MEMOP(inst, bits) || TryExtractLDUMAXL_64_MEMOP(inst, bits) ||
         TryExtractLDUMAX_64_MEMOP(inst, bits) || TryExtractLDCLRA_64_MEMOP(inst, bits) ||
         TryExtractLDCLRAL_64_MEMOP(inst, bits) || TryExtractLDUMAXAL_32_MEMOP(inst, bits) ||
         TryExtractLDCLRL_64_MEMOP(inst, bits) || TryExtractRORV_64_DP_2SRC(inst, bits) ||
         TryExtractASRV_32_DP_2SRC(inst, bits) || TryExtractRORV_32_DP_2SRC(inst, bits) ||
         TryExtractLDADDA_32_MEMOP(inst, bits) || TryExtractLDCLRA_32_MEMOP(inst, bits) ||
         TryExtractLDSMAXL_64_MEMOP(inst, bits) || TryExtractLDSMAX_64_MEMOP(inst, bits) ||
         TryExtractLDSMAXAL_64_MEMOP(inst, bits) || TryExtractLDSMAXA_64_MEMOP(inst, bits) ||
         TryExtractLDCLRAL_32_MEMOP(inst, bits) || TryExtractLDUMAXAB_32_MEMOP(inst, bits) ||
         TryExtractLDUMAXALB_32_MEMOP(inst, bits) || TryExtractLDCLR_32_MEMOP(inst, bits) ||
         TryExtractLDUMAXB_32_MEMOP(inst, bits) || TryExtractLDUMAXLB_32_MEMOP(inst, bits) ||
         TryExtractLDUMINB_32_MEMOP(inst, bits) || TryExtractLDCLRL_32_MEMOP(inst, bits) ||
         TryExtractLDUMINAB_32_MEMOP(inst, bits) || TryExtractLDSMIN_32_MEMOP(inst, bits) ||
         TryExtractLDUMINLB_32_MEMOP(inst, bits) || TryExtractLDSMINA_64_MEMOP(inst, bits) ||
         TryExtractLDSMINAL_64_MEMOP(inst, bits) || TryExtractLDSMIN_64_MEMOP(inst, bits) ||
         TryExtractLSRV_32_DP_2SRC(inst, bits) || TryExtractLDCLR_64_MEMOP(inst, bits) ||
         TryExtractLDSMAXH_32_MEMOP(inst, bits) || TryExtractLDSMAXAH_32_MEMOP(inst, bits) ||
         TryExtractASRV_64_DP_2SRC(inst, bits) || TryExtractLDSMINL_64_MEMOP(inst, bits) ||
         TryExtractSBCS_64_ADDSUB_CARRY(inst, bits) || TryExtractLDSMAXLH_32_MEMOP(inst, bits) ||
         TryExtractSBCS_32_ADDSUB_CARRY(inst, bits) || TryExtractSMULH_64_DP_3SRC(inst, bits) ||
         TryExtractADCS_64_ADDSUB_CARRY(inst, bits) || TryExtractCRC32CB_32C_DP_2SRC(inst, bits) ||
         TryExtractLDCLRLB_32_MEMOP(inst, bits) || TryExtractCRC32CW_32C_DP_2SRC(inst, bits) ||
         TryExtractCRC32CX_64C_DP_2SRC(inst, bits) || TryExtractLDSMINAB_32_MEMOP(inst, bits) ||
         TryExtractLDADD_64_MEMOP(inst, bits) || TryExtractSDIV_32_DP_2SRC(inst, bits) ||
         TryExtractLDSETA_32_MEMOP(inst, bits) || TryExtractSWPH_32_MEMOP(inst, bits) ||
         TryExtractLDSETH_32_MEMOP(inst, bits) || TryExtractSWPLH_32_MEMOP(inst, bits) ||
         TryExtractSWPAL_32_MEMOP(inst, bits) || TryExtractSWPAH_32_MEMOP(inst, bits) ||
         TryExtractLDUMINALH_32_MEMOP(inst, bits) || TryExtractLDADDLH_32_MEMOP(inst, bits) ||
         TryExtractLDADDB_32_MEMOP(inst, bits) || TryExtractLDADDH_32_MEMOP(inst, bits) ||
         TryExtractADCS_32_ADDSUB_CARRY(inst, bits) || TryExtractLDSETLH_32_MEMOP(inst, bits) ||
         TryExtractLDADDALH_32_MEMOP(inst, bits) || TryExtractSWPA_32_MEMOP(inst, bits) ||
         TryExtractLDADDAH_32_MEMOP(inst, bits) || TryExtractLDSETAH_32_MEMOP(inst, bits) ||
         TryExtractLDSETALH_32_MEMOP(inst, bits) || TryExtractLDUMINAL_32_MEMOP(inst, bits) ||
         TryExtractLDUMINL_32_MEMOP(inst, bits) || TryExtractCRC32H_32C_DP_2SRC(inst, bits) ||
         TryExtractLDSMINAH_32_MEMOP(inst, bits) || TryExtractLDUMINA_32_MEMOP(inst, bits) ||
         TryExtractLDUMIN_32_MEMOP(inst, bits) || TryExtractLDUMINAL_64_MEMOP(inst, bits) ||
         TryExtractCRC32W_32C_DP_2SRC(inst, bits) || TryExtractLDSMINALH_32_MEMOP(inst, bits) ||
         TryExtractLDCLRAB_32_MEMOP(inst, bits) || TryExtractLDSETAB_32_MEMOP(inst, bits) ||
         TryExtractLDCLRAH_32_MEMOP(inst, bits) || TryExtractLDCLRALH_32_MEMOP(inst, bits) ||
         TryExtractLDUMINLH_32_MEMOP(inst, bits) || TryExtractLDCLRH_32_MEMOP(inst, bits) ||
         TryExtractLDCLRB_32_MEMOP(inst, bits) || TryExtractLDUMINA_64_MEMOP(inst, bits) ||
         TryExtractUDIV_64_DP_2SRC(inst, bits) || TryExtractLDCLRALB_32_MEMOP(inst, bits) ||
         TryExtractLDSMINH_32_MEMOP(inst, bits) || TryExtractCRC32X_64C_DP_2SRC(inst, bits) ||
         TryExtractCRC32B_32C_DP_2SRC(inst, bits) || TryExtractLDUMINL_64_MEMOP(inst, bits) ||
         TryExtractLDEORALH_32_MEMOP(inst, bits) || TryExtractSWPB_32_MEMOP(inst, bits) ||
         TryExtractLDUMIN_64_MEMOP(inst, bits) || TryExtractLDSMINLH_32_MEMOP(inst, bits) ||
         TryExtractLDSMINLB_32_MEMOP(inst, bits) || TryExtractLDSMINB_32_MEMOP(inst, bits) ||
         TryExtractLDEORAH_32_MEMOP(inst, bits) || TryExtractLDCLRLH_32_MEMOP(inst, bits) ||
         TryExtractCRC32CH_32C_DP_2SRC(inst, bits) || TryExtractLDSMAXA_32_MEMOP(inst, bits) ||
         TryExtractLDSETAL_32_MEMOP(inst, bits) || TryExtractLDSET_32_MEMOP(inst, bits) ||
         TryExtractLDSETL_32_MEMOP(inst, bits) || TryExtractLDSETA_64_MEMOP(inst, bits) ||
         TryExtractLDSETAL_64_MEMOP(inst, bits) || TryExtractLDSET_64_MEMOP(inst, bits) ||
         TryExtractLDSETL_64_MEMOP(inst, bits) || TryExtractLDSMAX_32_MEMOP(inst, bits) ||
         TryExtractLDADD_32_MEMOP(inst, bits) || TryExtractLDUMINAH_32_MEMOP(inst, bits) ||
         TryExtractLDADDL_32_MEMOP(inst, bits) || TryExtractLDUMINH_32_MEMOP(inst, bits) ||
         TryExtractLDSMAXL_32_MEMOP(inst, bits) || TryExtractLDUMAXAH_32_MEMOP(inst, bits) ||
         TryExtractLDUMAXLH_32_MEMOP(inst, bits) || TryExtractLDUMAXH_32_MEMOP(inst, bits) ||
         TryExtractLDADDL_64_MEMOP(inst, bits) || TryExtractLDADDA_64_MEMOP(inst, bits) ||
         TryExtractLDUMAXALH_32_MEMOP(inst, bits) || TryExtractLDADDAL_64_MEMOP(inst, bits) ||
         TryExtractLDADDAL_32_MEMOP(inst, bits) || TryExtractLDSMINALB_32_MEMOP(inst, bits) ||
         TryExtractLDRB_32BL_LDST_REGOFF(inst, bits) ||
         TryExtractLDRSB_64BL_LDST_REGOFF(inst, bits) ||
         TryExtractLDRSB_32BL_LDST_REGOFF(inst, bits) ||
         TryExtractSTRB_32BL_LDST_REGOFF(inst, bits) || TryExtractCCMN_32_CONDCMP_REG(inst, bits) ||
         TryExtractCCMN_64_CONDCMP_REG(inst, bits) || TryExtractCCMP_32_CONDCMP_REG(inst, bits) ||
         TryExtractCCMP_64_CONDCMP_IMM(inst, bits) || TryExtractCCMP_32_CONDCMP_IMM(inst, bits) ||
         TryExtractCCMP_64_CONDCMP_REG(inst, bits) || TryExtractCCMN_64_CONDCMP_IMM(inst, bits) ||
         TryExtractCCMN_32_CONDCMP_IMM(inst, bits) || TryExtractCSNEG_64_CONDSEL(inst, bits) ||
         TryExtractCSNEG_32_CONDSEL(inst, bits) || TryExtractLDUR_64_LDST_UNSCALED(inst, bits) ||
         TryExtractLDTRH_32_LDST_UNPRIV(inst, bits) ||
         TryExtractLDTRSH_64_LDST_UNPRIV(inst, bits) || TryExtractSTR_64_LDST_IMMPOST(inst, bits) ||
         TryExtractSTURB_32_LDST_UNSCALED(inst, bits) || TryExtractSTR_32_LDST_REGOFF(inst, bits) ||
         TryExtractLDTRSH_32_LDST_UNPRIV(inst, bits) ||
         TryExtractLDTRSW_64_LDST_UNPRIV(inst, bits) || TryExtractSTR_32_LDST_IMMPRE(inst, bits) ||
         TryExtractLDRB_32B_LDST_REGOFF(inst, bits) ||
         TryExtractLDUR_32_LDST_UNSCALED(inst, bits) ||
         TryExtractLDRSH_32_LDST_IMMPOST(inst, bits) ||
         TryExtractLDRSH_64_LDST_IMMPOST(inst, bits) ||
         TryExtractLDRSH_32_LDST_IMMPRE(inst, bits) ||
         TryExtractLDURSB_32_LDST_UNSCALED(inst, bits) ||
         TryExtractLDURSB_64_LDST_UNSCALED(inst, bits) ||
         TryExtractSTRH_32_LDST_IMMPOST(inst, bits) || TryExtractLDRH_32_LDST_IMMPOST(inst, bits) ||
         TryExtractLDURH_32_LDST_UNSCALED(inst, bits) ||
         TryExtractLDRH_32_LDST_IMMPRE(inst, bits) || TryExtractSTR_32_LDST_IMMPOST(inst, bits) ||
         TryExtractSTRB_32_LDST_IMMPOST(inst, bits) || TryExtractLDRSH_64_LDST_REGOFF(inst, bits) ||
         TryExtractCSEL_64_CONDSEL(inst, bits) || TryExtractSTTRH_32_LDST_UNPRIV(inst, bits) ||
         TryExtractCSEL_32_CONDSEL(inst, bits) || TryExtractLDURSW_64_LDST_UNSCALED(inst, bits) ||
         TryExtractLDURB_32_LDST_UNSCALED(inst, bits) ||
         TryExtractSTURH_32_LDST_UNSCALED(inst, bits) ||
         TryExtractLDRSB_32_LDST_IMMPOST(inst, bits) ||
         TryExtractLDRSB_32_LDST_IMMPRE(inst, bits) || TryExtractLDRSB_64_LDST_IMMPRE(inst, bits) ||
         TryExtractLDTRB_32_LDST_UNPRIV(inst, bits) ||
         TryExtractLDRSB_64_LDST_IMMPOST(inst, bits) ||
         TryExtractLDRSW_64_LDST_IMMPRE(inst, bits) || TryExtractLDR_64_LDST_IMMPRE(inst, bits) ||
         TryExtractLDRSW_64_LDST_IMMPOST(inst, bits) || TryExtractSTRH_32_LDST_IMMPRE(inst, bits) ||
         TryExtractLDTRSB_64_LDST_UNPRIV(inst, bits) ||
         TryExtractSTTRB_32_LDST_UNPRIV(inst, bits) || TryExtractSTR_64_LDST_IMMPRE(inst, bits) ||
         TryExtractSTRB_32_LDST_IMMPRE(inst, bits) || TryExtractLDRSH_32_LDST_REGOFF(inst, bits) ||
         TryExtractSTRB_32B_LDST_REGOFF(inst, bits) || TryExtractLDTR_32_LDST_UNPRIV(inst, bits) ||
         TryExtractLDRSW_64_LDST_REGOFF(inst, bits) || TryExtractSTTR_32_LDST_UNPRIV(inst, bits) ||
         TryExtractCSINC_64_CONDSEL(inst, bits) || TryExtractCSINC_32_CONDSEL(inst, bits) ||
         TryExtractLDTR_64_LDST_UNPRIV(inst, bits) || TryExtractPRFM_P_LDST_REGOFF(inst, bits) ||
         TryExtractSTUR_32_LDST_UNSCALED(inst, bits) || TryExtractLDRH_32_LDST_REGOFF(inst, bits) ||
         TryExtractLDR_32_LDST_IMMPOST(inst, bits) || TryExtractSTTR_64_LDST_UNPRIV(inst, bits) ||
         TryExtractLDR_64_LDST_IMMPOST(inst, bits) || TryExtractLDR_64_LDST_REGOFF(inst, bits) ||
         TryExtractLDR_32_LDST_IMMPRE(inst, bits) || TryExtractLDR_32_LDST_REGOFF(inst, bits) ||
         TryExtractPRFUM_P_LDST_UNSCALED(inst, bits) ||
         TryExtractSTUR_64_LDST_UNSCALED(inst, bits) || TryExtractLDRB_32_LDST_IMMPRE(inst, bits) ||
         TryExtractLDRSH_64_LDST_IMMPRE(inst, bits) || TryExtractLDRB_32_LDST_IMMPOST(inst, bits) ||
         TryExtractSTRH_32_LDST_REGOFF(inst, bits) || TryExtractCSINV_32_CONDSEL(inst, bits) ||
         TryExtractSTR_64_LDST_REGOFF(inst, bits) || TryExtractLDTRSB_32_LDST_UNPRIV(inst, bits) ||
         TryExtractCSINV_64_CONDSEL(inst, bits) || TryExtractLDRSB_32B_LDST_REGOFF(inst, bits) ||
         TryExtractLDRSB_64B_LDST_REGOFF(inst, bits) ||
         TryExtractLDURSH_64_LDST_UNSCALED(inst, bits) ||
         TryExtractLDURSH_32_LDST_UNSCALED(inst, bits) ||
         TryExtractUMADDL_64WA_DP_3SRC(inst, bits) || TryExtractMADD_32A_DP_3SRC(inst, bits) ||
         TryExtractMADD_64A_DP_3SRC(inst, bits) || TryExtractMSUB_32A_DP_3SRC(inst, bits) ||
         TryExtractUMSUBL_64WA_DP_3SRC(inst, bits) || TryExtractSMSUBL_64WA_DP_3SRC(inst, bits) ||
         TryExtractMSUB_64A_DP_3SRC(inst, bits) || TryExtractSMADDL_64WA_DP_3SRC(inst, bits) ||
         TryExtractLDRSB_32_LDST_POS(inst, bits) || TryExtractLDRSH_32_LDST_POS(inst, bits) ||
         TryExtractLDRH_32_LDST_POS(inst, bits) || TryExtractLDRSB_64_LDST_POS(inst, bits) ||
         TryExtractLDRSW_64_LDST_POS(inst, bits) || TryExtractLDR_64_LDST_POS(inst, bits) ||
         TryExtractPRFM_P_LDST_POS(inst, bits) || TryExtractSTR_32_LDST_POS(inst, bits) ||
         TryExtractSTR_64_LDST_POS(inst, bits) || TryExtractSTRB_32_LDST_POS(inst, bits) ||
         TryExtractSTRH_32_LDST_POS(inst, bits) || TryExtractLDRSH_64_LDST_POS(inst, bits) ||
         TryExtractLDR_32_LDST_POS(inst, bits) || TryExtractLDRB_32_LDST_POS(inst, bits) ||
         TryExtractLDR_32_LOADLIT(inst, bits) || TryExtractPRFM_P_LOADLIT(inst, bits) ||
         TryExtractLDR_64_LOADLIT(inst, bits) || TryExtractLDRSW_64_LOADLIT(inst, bits);
}

// 00011100000000000000000000000000
static bool TryExtract7(InstData &inst, uint32_t bits) {
  return false || TryExtractFRINTM_S_FLOATDP1(inst, bits) ||
         TryExtractFCMP_DZ_FLOATCMP(inst, bits) || TryExtractFCVTAS_64D_FLOAT2INT(inst, bits) ||
         TryExtractFCMP_SZ_FLOATCMP(inst, bits) || TryExtractFRECPX_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFCVTPU_ASISDMISCFP16_R(inst, bits) || TryExtractFABS_S_FLOATDP1(inst, bits) ||
         TryExtractFCVTPS_32S_FLOAT2INT(inst, bits) || TryExtractFCVTPS_64S_FLOAT2INT(inst, bits) ||
         TryExtractFCVTPS_32D_FLOAT2INT(inst, bits) || TryExtractFCVTPS_64D_FLOAT2INT(inst, bits) ||
         TryExtractFCVTMU_32D_FLOAT2INT(inst, bits) || TryExtractFCVTMU_64D_FLOAT2INT(inst, bits) ||
         TryExtractFSQRT_D_FLOATDP1(inst, bits) || TryExtractFCMGE_ASISDMISCFP16_FZ(inst, bits) ||
         TryExtractFRINTN_S_FLOATDP1(inst, bits) || TryExtractFCMP_D_FLOATCMP(inst, bits) ||
         TryExtractFSQRT_S_FLOATDP1(inst, bits) || TryExtractSHA1H_SS_CRYPTOSHA2(inst, bits) ||
         TryExtractFCVTNS_32S_FLOAT2INT(inst, bits) || TryExtractFMOV_64D_FLOAT2INT(inst, bits) ||
         TryExtractFRINTM_D_FLOATDP1(inst, bits) || TryExtractFRINTM_H_FLOATDP1(inst, bits) ||
         TryExtractFCVTZU_64H_FLOAT2INT(inst, bits) || TryExtractFCVTZS_32H_FLOAT2INT(inst, bits) ||
         TryExtractFNEG_S_FLOATDP1(inst, bits) || TryExtractFRINTN_H_FLOATDP1(inst, bits) ||
         TryExtractFRINTX_D_FLOATDP1(inst, bits) || TryExtractFCMLE_ASISDMISCFP16_FZ(inst, bits) ||
         TryExtractFMINP_ASISDPAIR_ONLY_H(inst, bits) || TryExtractFCVT_SD_FLOATDP1(inst, bits) ||
         TryExtractFCVTNS_64S_FLOAT2INT(inst, bits) || TryExtractFNEG_H_FLOATDP1(inst, bits) ||
         TryExtractFRINTP_S_FLOATDP1(inst, bits) || TryExtractFRINTP_D_FLOATDP1(inst, bits) ||
         TryExtractFCVTPS_32H_FLOAT2INT(inst, bits) || TryExtractFRINTP_H_FLOATDP1(inst, bits) ||
         TryExtractFCVTMS_64H_FLOAT2INT(inst, bits) || TryExtractFCVTMS_32D_FLOAT2INT(inst, bits) ||
         TryExtractFCVTMS_32H_FLOAT2INT(inst, bits) || TryExtractFCVTMS_32S_FLOAT2INT(inst, bits) ||
         TryExtractFCVTPS_64H_FLOAT2INT(inst, bits) ||
         TryExtractSHA1SU1_VV_CRYPTOSHA2(inst, bits) ||
         TryExtractFCVTNS_32H_FLOAT2INT(inst, bits) ||
         TryExtractFCVTZU_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFCVTMU_32H_FLOAT2INT(inst, bits) || TryExtractSCVTF_D64_FLOAT2INT(inst, bits) ||
         TryExtractFCVTMU_64H_FLOAT2INT(inst, bits) ||
         TryExtractUCVTF_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFCVTMU_32S_FLOAT2INT(inst, bits) || TryExtractFCVTMU_64S_FLOAT2INT(inst, bits) ||
         TryExtractFCVTMS_64D_FLOAT2INT(inst, bits) || TryExtractSCVTF_S64_FLOAT2INT(inst, bits) ||
         TryExtractSCVTF_H64_FLOAT2INT(inst, bits) ||
         TryExtractFRSQRTE_ASISDMISCFP16_R(inst, bits) ||
         TryExtractSCVTF_D32_FLOAT2INT(inst, bits) || TryExtractFRINTX_S_FLOATDP1(inst, bits) ||
         TryExtractFCVTAS_64H_FLOAT2INT(inst, bits) || TryExtractFNEG_D_FLOATDP1(inst, bits) ||
         TryExtractSCVTF_S32_FLOAT2INT(inst, bits) || TryExtractFRINTX_H_FLOATDP1(inst, bits) ||
         TryExtractFCVTZU_64D_FLOAT2INT(inst, bits) || TryExtractFCVTZU_32D_FLOAT2INT(inst, bits) ||
         TryExtractSCVTF_H32_FLOAT2INT(inst, bits) ||
         TryExtractFMAXP_ASISDPAIR_ONLY_H(inst, bits) ||
         TryExtractFCVTNS_64H_FLOAT2INT(inst, bits) || TryExtractFCVTNU_32S_FLOAT2INT(inst, bits) ||
         TryExtractUCVTF_H64_FLOAT2INT(inst, bits) || TryExtractFCVTNU_64H_FLOAT2INT(inst, bits) ||
         TryExtractFCVTZS_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFCVTAS_64S_FLOAT2INT(inst, bits) || TryExtractFCMP_H_FLOATCMP(inst, bits) ||
         TryExtractUCVTF_S64_FLOAT2INT(inst, bits) || TryExtractUCVTF_S32_FLOAT2INT(inst, bits) ||
         TryExtractUCVTF_D32_FLOAT2INT(inst, bits) || TryExtractUCVTF_D64_FLOAT2INT(inst, bits) ||
         TryExtractFCMLT_ASISDMISCFP16_FZ(inst, bits) ||
         TryExtractFCVTNU_32H_FLOAT2INT(inst, bits) || TryExtractFCMP_S_FLOATCMP(inst, bits) ||
         TryExtractFCMP_HZ_FLOATCMP(inst, bits) || TryExtractSCVTF_ASISDMISCFP16_R(inst, bits) ||
         TryExtractSHA256SU0_VV_CRYPTOSHA2(inst, bits) || TryExtractFCVT_HD_FLOATDP1(inst, bits) ||
         TryExtractFRINTI_D_FLOATDP1(inst, bits) || TryExtractFSQRT_H_FLOATDP1(inst, bits) ||
         TryExtractFCVTZU_32H_FLOAT2INT(inst, bits) || TryExtractFMOV_H_FLOATDP1(inst, bits) ||
         TryExtractFCVTAS_32H_FLOAT2INT(inst, bits) || TryExtractFCVTAS_32D_FLOAT2INT(inst, bits) ||
         TryExtractFMAXNMP_ASISDPAIR_ONLY_H(inst, bits) ||
         TryExtractFCVTMS_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFMOV_V64I_FLOAT2INT(inst, bits) ||
         TryExtractFCVTPS_ASISDMISCFP16_R(inst, bits) || TryExtractFCVT_SH_FLOATDP1(inst, bits) ||
         TryExtractFCVT_DS_FLOATDP1(inst, bits) || TryExtractFCVT_HS_FLOATDP1(inst, bits) ||
         TryExtractFRINTI_H_FLOATDP1(inst, bits) || TryExtractFCVT_DH_FLOATDP1(inst, bits) ||
         TryExtractFCVTZS_64H_FLOAT2INT(inst, bits) || TryExtractUCVTF_H32_FLOAT2INT(inst, bits) ||
         TryExtractFCVTAS_32S_FLOAT2INT(inst, bits) || TryExtractFCMPE_HZ_FLOATCMP(inst, bits) ||
         TryExtractFCVTZU_64S_FLOAT2INT(inst, bits) || TryExtractFRINTA_D_FLOATDP1(inst, bits) ||
         TryExtractFRINTA_S_FLOATDP1(inst, bits) || TryExtractFRINTA_H_FLOATDP1(inst, bits) ||
         TryExtractFMOV_D_FLOATDP1(inst, bits) || TryExtractFCVTAS_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFCVTNS_32D_FLOAT2INT(inst, bits) || TryExtractFRINTZ_H_FLOATDP1(inst, bits) ||
         TryExtractFRINTZ_D_FLOATDP1(inst, bits) || TryExtractFMOV_S_FLOATDP1(inst, bits) ||
         TryExtractFRINTZ_S_FLOATDP1(inst, bits) || TryExtractFCVTZS_32D_FLOAT2INT(inst, bits) ||
         TryExtractFCVTZS_64S_FLOAT2INT(inst, bits) || TryExtractFCVTZS_32S_FLOAT2INT(inst, bits) ||
         TryExtractFADDP_ASISDPAIR_ONLY_H(inst, bits) || TryExtractFRINTN_D_FLOATDP1(inst, bits) ||
         TryExtractFCMPE_D_FLOATCMP(inst, bits) || TryExtractFCMPE_H_FLOATCMP(inst, bits) ||
         TryExtractFCMPE_DZ_FLOATCMP(inst, bits) || TryExtractFCVTNS_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFRECPE_ASISDMISCFP16_R(inst, bits) || TryExtractFABS_H_FLOATDP1(inst, bits) ||
         TryExtractFCMPE_S_FLOATCMP(inst, bits) || TryExtractFCVTAU_32D_FLOAT2INT(inst, bits) ||
         TryExtractFCMPE_SZ_FLOATCMP(inst, bits) || TryExtractFCVTAU_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFCVTNU_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFMINNMP_ASISDPAIR_ONLY_H(inst, bits) ||
         TryExtractFCVTNU_64D_FLOAT2INT(inst, bits) || TryExtractFABS_D_FLOATDP1(inst, bits) ||
         TryExtractFCVTMS_64S_FLOAT2INT(inst, bits) || TryExtractFRINTI_S_FLOATDP1(inst, bits) ||
         TryExtractFCVTNU_64S_FLOAT2INT(inst, bits) || TryExtractFMOV_32H_FLOAT2INT(inst, bits) ||
         TryExtractFCMEQ_ASISDMISCFP16_FZ(inst, bits) ||
         TryExtractFCVTAU_32H_FLOAT2INT(inst, bits) || TryExtractFCVTAU_64H_FLOAT2INT(inst, bits) ||
         TryExtractFCVTAU_64S_FLOAT2INT(inst, bits) || TryExtractFCVTZU_32S_FLOAT2INT(inst, bits) ||
         TryExtractFCVTPU_64H_FLOAT2INT(inst, bits) || TryExtractFCVTZS_64D_FLOAT2INT(inst, bits) ||
         TryExtractFMOV_64H_FLOAT2INT(inst, bits) || TryExtractFMOV_H32_FLOAT2INT(inst, bits) ||
         TryExtractFMOV_S32_FLOAT2INT(inst, bits) || TryExtractFCVTMU_ASISDMISCFP16_R(inst, bits) ||
         TryExtractFCVTNU_32D_FLOAT2INT(inst, bits) || TryExtractFMOV_32S_FLOAT2INT(inst, bits) ||
         TryExtractFMOV_H64_FLOAT2INT(inst, bits) || TryExtractFCVTNS_64D_FLOAT2INT(inst, bits) ||
         TryExtractFMOV_D64_FLOAT2INT(inst, bits) || TryExtractFCMGT_ASISDMISCFP16_FZ(inst, bits) ||
         TryExtractFMOV_64VX_FLOAT2INT(inst, bits) || TryExtractFCVTPU_32S_FLOAT2INT(inst, bits) ||
         TryExtractFCVTPU_32H_FLOAT2INT(inst, bits) || TryExtractFCVTPU_64S_FLOAT2INT(inst, bits) ||
         TryExtractFCVTPU_32D_FLOAT2INT(inst, bits) || TryExtractFCVTPU_64D_FLOAT2INT(inst, bits) ||
         TryExtractFCVTAU_32S_FLOAT2INT(inst, bits) || TryExtractFCVTAU_64D_FLOAT2INT(inst, bits) ||
         TryExtractFCVTPU_ASISDMISC_R(inst, bits) || TryExtractFRECPX_ASISDMISC_R(inst, bits) ||
         TryExtractFRSQRTE_ASISDMISC_R(inst, bits) || TryExtractFCMGE_ASISDMISC_FZ(inst, bits) ||
         TryExtractFCMLE_ASISDMISC_FZ(inst, bits) || TryExtractFCVTZU_ASISDMISC_R(inst, bits) ||
         TryExtractUCVTF_ASISDMISC_R(inst, bits) || TryExtractFCVTZS_ASISDMISC_R(inst, bits) ||
         TryExtractSCVTF_ASISDMISC_R(inst, bits) || TryExtractFCVTMS_ASISDMISC_R(inst, bits) ||
         TryExtractFCMLT_ASISDMISC_FZ(inst, bits) ||
         TryExtractFADDP_ASISDPAIR_ONLY_SD(inst, bits) ||
         TryExtractFMAXNMP_ASISDPAIR_ONLY_SD(inst, bits) ||
         TryExtractFCMGT_ASISDMISC_FZ(inst, bits) ||
         TryExtractFMINP_ASISDPAIR_ONLY_SD(inst, bits) ||
         TryExtractFCVTAS_ASISDMISC_R(inst, bits) || TryExtractFCVTPS_ASISDMISC_R(inst, bits) ||
         TryExtractFCVTNS_ASISDMISC_R(inst, bits) || TryExtractFCVTXN_ASISDMISC_N(inst, bits) ||
         TryExtractFCMEQ_ASISDMISC_FZ(inst, bits) || TryExtractFRECPE_ASISDMISC_R(inst, bits) ||
         TryExtractFMINNMP_ASISDPAIR_ONLY_SD(inst, bits) ||
         TryExtractFCVTAU_ASISDMISC_R(inst, bits) || TryExtractFCVTNU_ASISDMISC_R(inst, bits) ||
         TryExtractFMAXP_ASISDPAIR_ONLY_SD(inst, bits) ||
         TryExtractFCVTMU_ASISDMISC_R(inst, bits) || TryExtractCMLT_ASISDMISC_Z(inst, bits) ||
         TryExtractSQXTUN_ASISDMISC_N(inst, bits) || TryExtractSQNEG_ASISDMISC_R(inst, bits) ||
         TryExtractCMLE_ASISDMISC_Z(inst, bits) || TryExtractSUQADD_ASISDMISC_R(inst, bits) ||
         TryExtractCMGT_ASISDMISC_Z(inst, bits) || TryExtractSQABS_ASISDMISC_R(inst, bits) ||
         TryExtractUSQADD_ASISDMISC_R(inst, bits) || TryExtractUQXTN_ASISDMISC_N(inst, bits) ||
         TryExtractNEG_ASISDMISC_R(inst, bits) || TryExtractABS_ASISDMISC_R(inst, bits) ||
         TryExtractSQXTN_ASISDMISC_N(inst, bits) || TryExtractADDP_ASISDPAIR_ONLY(inst, bits) ||
         TryExtractCMEQ_ASISDMISC_Z(inst, bits) || TryExtractCMGE_ASISDMISC_Z(inst, bits) ||
         TryExtractFMOV_H_FLOATIMM(inst, bits) || TryExtractFMOV_S_FLOATIMM(inst, bits) ||
         TryExtractFMOV_D_FLOATIMM(inst, bits) || TryExtractFSUB_S_FLOATDP2(inst, bits) ||
         TryExtractFSUB_H_FLOATDP2(inst, bits) || TryExtractFABD_ASISDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFMUL_D_FLOATDP2(inst, bits) || TryExtractFMINNM_H_FLOATDP2(inst, bits) ||
         TryExtractFCMEQ_ASISDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFMINNM_D_FLOATDP2(inst, bits) ||
         TryExtractSHA256SU1_VVV_CRYPTOSHA3(inst, bits) || TryExtractFSUB_D_FLOATDP2(inst, bits) ||
         TryExtractFNMUL_S_FLOATDP2(inst, bits) || TryExtractFDIV_H_FLOATDP2(inst, bits) ||
         TryExtractFRECPS_ASISDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFCMGE_ASISDSAMEFP16_ONLY(inst, bits) || TryExtractFNMUL_H_FLOATDP2(inst, bits) ||
         TryExtractFMAXNM_S_FLOATDP2(inst, bits) || TryExtractFMAXNM_H_FLOATDP2(inst, bits) ||
         TryExtractSHA256H_QQV_CRYPTOSHA3(inst, bits) || TryExtractFMUL_S_FLOATDP2(inst, bits) ||
         TryExtractFMULX_ASISDSAMEFP16_ONLY(inst, bits) || TryExtractFMUL_H_FLOATDP2(inst, bits) ||
         TryExtractFMAX_D_FLOATDP2(inst, bits) || TryExtractFDIV_S_FLOATDP2(inst, bits) ||
         TryExtractSHA1SU0_VVV_CRYPTOSHA3(inst, bits) || TryExtractFDIV_D_FLOATDP2(inst, bits) ||
         TryExtractSHA1M_QSV_CRYPTOSHA3(inst, bits) || TryExtractFMIN_D_FLOATDP2(inst, bits) ||
         TryExtractFADD_S_FLOATDP2(inst, bits) || TryExtractFMIN_S_FLOATDP2(inst, bits) ||
         TryExtractSHA1P_QSV_CRYPTOSHA3(inst, bits) || TryExtractFADD_D_FLOATDP2(inst, bits) ||
         TryExtractFMINNM_S_FLOATDP2(inst, bits) || TryExtractDUP_ASISDONE_ONLY(inst, bits) ||
         TryExtractFMIN_H_FLOATDP2(inst, bits) || TryExtractSHA1C_QSV_CRYPTOSHA3(inst, bits) ||
         TryExtractFNMUL_D_FLOATDP2(inst, bits) ||
         TryExtractFRSQRTS_ASISDSAMEFP16_ONLY(inst, bits) ||
         TryExtractFMAXNM_D_FLOATDP2(inst, bits) || TryExtractFMAX_S_FLOATDP2(inst, bits) ||
         TryExtractFCMGT_ASISDSAMEFP16_ONLY(inst, bits) || TryExtractFADD_H_FLOATDP2(inst, bits) ||
         TryExtractFACGT_ASISDSAMEFP16_ONLY(inst, bits) || TryExtractFMAX_H_FLOATDP2(inst, bits) ||
         TryExtractFACGE_ASISDSAMEFP16_ONLY(inst, bits) ||
         TryExtractSHA256H2_QQV_CRYPTOSHA3(inst, bits) ||
         TryExtractUCVTF_D64_FLOAT2FIX(inst, bits) || TryExtractFRECPS_ASISDSAME_ONLY(inst, bits) ||
         TryExtractUCVTF_S32_FLOAT2FIX(inst, bits) || TryExtractUCVTF_D32_FLOAT2FIX(inst, bits) ||
         TryExtractFCVTZS_32S_FLOAT2FIX(inst, bits) || TryExtractFABD_ASISDSAME_ONLY(inst, bits) ||
         TryExtractFCMEQ_ASISDSAME_ONLY(inst, bits) || TryExtractLDR_BL_LDST_REGOFF(inst, bits) ||
         TryExtractUCVTF_S64_FLOAT2FIX(inst, bits) || TryExtractFCVTZU_32D_FLOAT2FIX(inst, bits) ||
         TryExtractFCMGE_ASISDSAME_ONLY(inst, bits) || TryExtractSTR_BL_LDST_REGOFF(inst, bits) ||
         TryExtractFRSQRTS_ASISDSAME_ONLY(inst, bits) ||
         TryExtractFMULX_ASISDSAME_ONLY(inst, bits) || TryExtractSCVTF_H32_FLOAT2FIX(inst, bits) ||
         TryExtractSCVTF_S32_FLOAT2FIX(inst, bits) || TryExtractSCVTF_D32_FLOAT2FIX(inst, bits) ||
         TryExtractSCVTF_H64_FLOAT2FIX(inst, bits) || TryExtractSCVTF_S64_FLOAT2FIX(inst, bits) ||
         TryExtractSCVTF_D64_FLOAT2FIX(inst, bits) || TryExtractFCVTZS_64D_FLOAT2FIX(inst, bits) ||
         TryExtractFCVTZS_32D_FLOAT2FIX(inst, bits) || TryExtractFCVTZS_64S_FLOAT2FIX(inst, bits) ||
         TryExtractFCVTZS_64H_FLOAT2FIX(inst, bits) || TryExtractFCVTZS_32H_FLOAT2FIX(inst, bits) ||
         TryExtractUCVTF_H32_FLOAT2FIX(inst, bits) || TryExtractFCVTZU_32H_FLOAT2FIX(inst, bits) ||
         TryExtractFCVTZU_64H_FLOAT2FIX(inst, bits) || TryExtractFCVTZU_32S_FLOAT2FIX(inst, bits) ||
         TryExtractFCVTZU_64S_FLOAT2FIX(inst, bits) || TryExtractFCVTZU_64D_FLOAT2FIX(inst, bits) ||
         TryExtractFACGE_ASISDSAME_ONLY(inst, bits) || TryExtractFACGT_ASISDSAME_ONLY(inst, bits) ||
         TryExtractFCMGT_ASISDSAME_ONLY(inst, bits) || TryExtractUCVTF_H64_FLOAT2FIX(inst, bits) ||
         TryExtractSQSUB_ASISDSAME_ONLY(inst, bits) || TryExtractUQSHL_ASISDSHF_R(inst, bits) ||
         TryExtractSQRSHRUN_ASISDSHF_N(inst, bits) || TryExtractADD_ASISDSAME_ONLY(inst, bits) ||
         TryExtractUQSHL_ASISDSAME_ONLY(inst, bits) || TryExtractURSHL_ASISDSAME_ONLY(inst, bits) ||
         TryExtractSQDMULH_ASISDSAME_ONLY(inst, bits) || TryExtractSQSHRN_ASISDSHF_N(inst, bits) ||
         TryExtractSQSHLU_ASISDSHF_R(inst, bits) || TryExtractSRSRA_ASISDSHF_R(inst, bits) ||
         TryExtractCMEQ_ASISDSAME_ONLY(inst, bits) || TryExtractUSRA_ASISDSHF_R(inst, bits) ||
         TryExtractUSHL_ASISDSAME_ONLY(inst, bits) || TryExtractSQSHL_ASISDSAME_ONLY(inst, bits) ||
         TryExtractFCVTZU_ASISDSHF_C(inst, bits) || TryExtractSQSHL_ASISDSHF_R(inst, bits) ||
         TryExtractSQSHRUN_ASISDSHF_N(inst, bits) || TryExtractSQDMULL_ASISDDIFF_ONLY(inst, bits) ||
         TryExtractUQSUB_ASISDSAME_ONLY(inst, bits) || TryExtractCMGT_ASISDSAME_ONLY(inst, bits) ||
         TryExtractSQRSHRN_ASISDSHF_N(inst, bits) || TryExtractUQADD_ASISDSAME_ONLY(inst, bits) ||
         TryExtractSSHR_ASISDSHF_R(inst, bits) || TryExtractSQRDMLSH_ASISDSAME2_ONLY(inst, bits) ||
         TryExtractSRI_ASISDSHF_R(inst, bits) || TryExtractUQRSHRN_ASISDSHF_N(inst, bits) ||
         TryExtractCMHI_ASISDSAME_ONLY(inst, bits) || TryExtractFMUL_ASISDELEM_RH_H(inst, bits) ||
         TryExtractSSRA_ASISDSHF_R(inst, bits) || TryExtractSCVTF_ASISDSHF_C(inst, bits) ||
         TryExtractSSHL_ASISDSAME_ONLY(inst, bits) || TryExtractUSHR_ASISDSHF_R(inst, bits) ||
         TryExtractSQDMLAL_ASISDDIFF_ONLY(inst, bits) ||
         TryExtractFMLA_ASISDELEM_RH_H(inst, bits) || TryExtractUCVTF_ASISDSHF_C(inst, bits) ||
         TryExtractSQADD_ASISDSAME_ONLY(inst, bits) || TryExtractFMULX_ASISDELEM_RH_H(inst, bits) ||
         TryExtractUQSHRN_ASISDSHF_N(inst, bits) || TryExtractSQRDMULH_ASISDSAME_ONLY(inst, bits) ||
         TryExtractCMGE_ASISDSAME_ONLY(inst, bits) || TryExtractURSHR_ASISDSHF_R(inst, bits) ||
         TryExtractFMLS_ASISDELEM_RH_H(inst, bits) || TryExtractSRSHL_ASISDSAME_ONLY(inst, bits) ||
         TryExtractSQRDMLAH_ASISDSAME2_ONLY(inst, bits) ||
         TryExtractFCVTZS_ASISDSHF_C(inst, bits) || TryExtractCMHS_ASISDSAME_ONLY(inst, bits) ||
         TryExtractUQRSHL_ASISDSAME_ONLY(inst, bits) || TryExtractSRSHR_ASISDSHF_R(inst, bits) ||
         TryExtractCMTST_ASISDSAME_ONLY(inst, bits) ||
         TryExtractSQDMLSL_ASISDDIFF_ONLY(inst, bits) || TryExtractSLI_ASISDSHF_R(inst, bits) ||
         TryExtractSUB_ASISDSAME_ONLY(inst, bits) || TryExtractSHL_ASISDSHF_R(inst, bits) ||
         TryExtractSQRSHL_ASISDSAME_ONLY(inst, bits) || TryExtractURSRA_ASISDSHF_R(inst, bits) ||
         TryExtractFCCMP_H_FLOATCCMP(inst, bits) || TryExtractFCCMPE_S_FLOATCCMP(inst, bits) ||
         TryExtractFMUL_ASISDELEM_R_SD(inst, bits) || TryExtractFCCMP_D_FLOATCCMP(inst, bits) ||
         TryExtractFCCMPE_H_FLOATCCMP(inst, bits) || TryExtractFCCMPE_D_FLOATCCMP(inst, bits) ||
         TryExtractFMLA_ASISDELEM_R_SD(inst, bits) || TryExtractFMULX_ASISDELEM_R_SD(inst, bits) ||
         TryExtractFMLS_ASISDELEM_R_SD(inst, bits) || TryExtractFCCMP_S_FLOATCCMP(inst, bits) ||
         TryExtractFCSEL_D_FLOATSEL(inst, bits) || TryExtractSTR_S_LDST_REGOFF(inst, bits) ||
         TryExtractLDR_S_LDST_REGOFF(inst, bits) || TryExtractLDR_H_LDST_REGOFF(inst, bits) ||
         TryExtractLDR_B_LDST_REGOFF(inst, bits) || TryExtractSTR_B_LDST_IMMPOST(inst, bits) ||
         TryExtractSTR_H_LDST_IMMPOST(inst, bits) || TryExtractSTR_S_LDST_IMMPOST(inst, bits) ||
         TryExtractSTR_D_LDST_IMMPOST(inst, bits) || TryExtractSTR_Q_LDST_IMMPOST(inst, bits) ||
         TryExtractSTR_B_LDST_IMMPRE(inst, bits) || TryExtractSTR_H_LDST_IMMPRE(inst, bits) ||
         TryExtractSTR_S_LDST_IMMPRE(inst, bits) || TryExtractSTR_D_LDST_IMMPRE(inst, bits) ||
         TryExtractSTR_Q_LDST_IMMPRE(inst, bits) || TryExtractSTR_D_LDST_REGOFF(inst, bits) ||
         TryExtractSQDMULL_ASISDELEM_L(inst, bits) || TryExtractLDR_Q_LDST_REGOFF(inst, bits) ||
         TryExtractLDR_D_LDST_REGOFF(inst, bits) || TryExtractSTR_B_LDST_REGOFF(inst, bits) ||
         TryExtractSTR_Q_LDST_REGOFF(inst, bits) || TryExtractSQRDMULH_ASISDELEM_R(inst, bits) ||
         TryExtractSTUR_D_LDST_UNSCALED(inst, bits) || TryExtractSTUR_Q_LDST_UNSCALED(inst, bits) ||
         TryExtractSQRDMLSH_ASISDELEM_R(inst, bits) || TryExtractSTUR_H_LDST_UNSCALED(inst, bits) ||
         TryExtractSTR_H_LDST_REGOFF(inst, bits) || TryExtractSTUR_S_LDST_UNSCALED(inst, bits) ||
         TryExtractSQRDMLAH_ASISDELEM_R(inst, bits) || TryExtractLDR_B_LDST_IMMPOST(inst, bits) ||
         TryExtractLDUR_D_LDST_UNSCALED(inst, bits) || TryExtractLDUR_B_LDST_UNSCALED(inst, bits) ||
         TryExtractLDUR_S_LDST_UNSCALED(inst, bits) || TryExtractLDUR_Q_LDST_UNSCALED(inst, bits) ||
         TryExtractFCSEL_S_FLOATSEL(inst, bits) || TryExtractFCSEL_H_FLOATSEL(inst, bits) ||
         TryExtractSQDMLSL_ASISDELEM_L(inst, bits) || TryExtractLDR_H_LDST_IMMPOST(inst, bits) ||
         TryExtractLDR_D_LDST_IMMPOST(inst, bits) || TryExtractLDR_Q_LDST_IMMPOST(inst, bits) ||
         TryExtractLDR_S_LDST_IMMPOST(inst, bits) || TryExtractLDR_Q_LDST_IMMPRE(inst, bits) ||
         TryExtractLDR_H_LDST_IMMPRE(inst, bits) || TryExtractLDR_D_LDST_IMMPRE(inst, bits) ||
         TryExtractLDR_S_LDST_IMMPRE(inst, bits) || TryExtractLDR_B_LDST_IMMPRE(inst, bits) ||
         TryExtractLDUR_H_LDST_UNSCALED(inst, bits) || TryExtractSQDMLAL_ASISDELEM_L(inst, bits) ||
         TryExtractSQDMULH_ASISDELEM_R(inst, bits) || TryExtractSTUR_B_LDST_UNSCALED(inst, bits) ||
         TryExtractFNMSUB_D_FLOATDP3(inst, bits) || TryExtractFNMSUB_H_FLOATDP3(inst, bits) ||
         TryExtractFNMSUB_S_FLOATDP3(inst, bits) || TryExtractFNMADD_S_FLOATDP3(inst, bits) ||
         TryExtractFNMADD_D_FLOATDP3(inst, bits) || TryExtractFNMADD_H_FLOATDP3(inst, bits) ||
         TryExtractFMSUB_S_FLOATDP3(inst, bits) || TryExtractFMSUB_H_FLOATDP3(inst, bits) ||
         TryExtractFMSUB_D_FLOATDP3(inst, bits) || TryExtractFMADD_H_FLOATDP3(inst, bits) ||
         TryExtractFMADD_S_FLOATDP3(inst, bits) || TryExtractFMADD_D_FLOATDP3(inst, bits) ||
         TryExtractSTR_S_LDST_POS(inst, bits) || TryExtractSTR_Q_LDST_POS(inst, bits) ||
         TryExtractSTR_B_LDST_POS(inst, bits) || TryExtractSTR_H_LDST_POS(inst, bits) ||
         TryExtractSTR_D_LDST_POS(inst, bits) || TryExtractLDR_B_LDST_POS(inst, bits) ||
         TryExtractLDR_Q_LDST_POS(inst, bits) || TryExtractLDR_H_LDST_POS(inst, bits) ||
         TryExtractLDR_S_LDST_POS(inst, bits) || TryExtractLDR_D_LDST_POS(inst, bits) ||
         TryExtractLDR_S_LOADLIT(inst, bits) || TryExtractLDR_Q_LOADLIT(inst, bits) ||
         TryExtractLDR_D_LOADLIT(inst, bits);
}

static bool (*const kFirstLevel[])(InstData &, uint32_t) = {
    TryExtract0,  // ---000--------------------------
    TryExtract1,  // ---100--------------------------
    TryExtract2,  // ---010--------------------------
    TryExtract3,  // ---110--------------------------
    TryExtract4,  // ---001--------------------------
    TryExtract5,  // ---101--------------------------
    TryExtract6,  // ---011--------------------------
    TryExtract7,  // ---111--------------------------
};

}  // namespace

const char *InstNameToString(InstName iclass) {
  auto num = static_cast<uint16_t>(iclass);
  if (iclass == InstName::INVALID) {
    return nullptr;
  } else if (static_cast<uint16_t>(InstName::WHILE) < num) {
    return nullptr;
  } else {
    return kIClassName[num];
  }
}

const char *InstFormToString(InstForm iform) {
  auto num = static_cast<uint16_t>(iform);
  if (iform == InstForm::INVALID) {
    return nullptr;
  } else if (static_cast<uint16_t>(InstForm::WHILELO_PREDICATE) < num) {
#if defined(WARNING_OUTPUT)
    printf("[WARNING] failed to convert iform \"%d\" to InstForm value.\n", num);
#endif
    return nullptr;
  } else {
    return kIFormName[num];
  }
}

bool TryExtract(const uint8_t *bytes, InstData &inst) {
  uint32_t bits = 0;
  bits = (bits << 8) | static_cast<uint32_t>(bytes[3]);
  bits = (bits << 8) | static_cast<uint32_t>(bytes[2]);
  bits = (bits << 8) | static_cast<uint32_t>(bytes[1]);
  bits = (bits << 8) | static_cast<uint32_t>(bytes[0]);
  uint32_t index = 0;
  index |= ((bits >> 28U) & 1U) << 2U;
  index |= ((bits >> 27U) & 1U) << 1U;
  index |= ((bits >> 26U) & 1U) << 0U;
  return kFirstLevel[index](inst, bits);
}

}  // namespace aarch64
}  // namespace remill
