# Overview
> [!WARNING]
> This document is used for the contributors to elfconv, but it is not enough.
> If you have any questions or if you’d like to discuss contributions, please feel free to open an issue!

The three main modules are `remill`, `elfconv/lifter`, and `elfconv/runtime`.  
<img width="1020" alt="スクリーンショット 2025-04-14 12 48 47" src="https://github.com/user-attachments/assets/f310b03f-9000-4cc3-81c7-cd748cb08945" />


### **Process to convert ELF to LLVM IR**
  - Two programs are involved: [`lifter/`](https://github.com/yomaytk/elfconv/tree/main/lifter) and [`remill`](https://github.com/yomaytk/elfconv/tree/main/backend/remill).
  - `lifter`: Parses the ELF binary, retrieves the functions, and feeds them into `remill`.
  - `remill`: A library that converts machine code into a sequence of LLVM IR instructions that perform equivalent operations. It converts each sequence of machine code instructions received from `lifter` into a function comprising equivalent LLVM IR instructions. Additionally, `lifter` uses the converted functions generated by `remill` to generate the LLVM bitcode.
  - The source code is as follows.
    - [`lifter/Lift.cpp`](https://github.com/yomaytk/elfconv/blob/main/lifter/Lift.cpp): Corresponds to the main function of the conversion process. It handles everything from ***binary loading***(`manager.SetELFData`), ***converting each instruction in each function***(`for (const auto &[addr, dasm_func] : manager.disasm_funcs){...}`), to ***generating the LLVM bitcode***(`remill::StoreModuleToFile`).
    - [`lifter/MainLifter.cpp`](https://github.com/yomaytk/elfconv/blob/main/lifter/MainLifter.cpp): The main class that actually performs the conversion. It inherits from the base instruction conversion class `remill::TraceLifter`. While it mainly adds functions such as copying the ELF data section into the generated LLVM bitcode, the definition from `TraceLifter` is almost entirely used for machine code conversion.
    - [`lifter/TraceManager.cpp`](https://github.com/yomaytk/elfconv/blob/main/lifter/TraceManager.cpp): Defines several helper functions.

### **Program that links the generated LLVM IR to create an executable**
  - Performs various initialization processes such as register initialization, setting up the stack and heap, and jumping to the entry point. Source code: [`runtime/Entry.cpp`](https://github.com/yomaytk/elfconv/blob/main/runtime/Entry.cpp)
  - Linux system call implementation  
    - Since the original ELF is a program that can execute arbitrary Linux system calls, it is necessary to allow them to work in the environment of the target binary. However, as many standard library functions corresponding to system calls are defined, in many cases it is sufficient to simply align the arguments and call them. The implementation is still a work in progress. Source code: [`runtime/syscalls`](https://github.com/yomaytk/elfconv/tree/main/runtime/syscalls).
  - Runtime memory management  
    - In elfconv, multiple data sections (e.g., the .data section) contained in the ELF are copied into the generated LLVM bitcode. Since the original ELF machine code uses calculated virtual addresses to access these data sections, it is necessary to convert those addresses into the addresses of the copied areas in the LLVM bitcode. Moreover, by defining virtual addresses for the stack and heap, all memory accesses can be unified through address translation. Source code: [`runtime/Memory.cpp`](https://github.com/yomaytk/elfconv/tree/main/runtime/Memory.cpp), [`runtime/Runtime.cpp`](https://github.com/yomaytk/elfconv/tree/main/runtime/Runtime.cpp), [`runtime/VmIntrinsics.cpp`](https://github.com/yomaytk/elfconv/tree/main/runtime/VmIntrinsics.cpp).

## remill

### What Kind of LLVM IR Does It Convert Machine Code Into?
remill takes an array of machine code bytes and converts each machine instruction into LLVM IR that exhibits equivalent behavior. Since machine code is executed not only on memory but also using CPU registers, remill represents CPU registers as a struct (see the [AArch64 definition](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/include/remill/Arch/AArch64/Runtime/State.h#L304-L329)). Based on that, here is an illustration of the conversion process. In this example, the following three AArch64 instruction sequences are used:

```asm
add     x29, sp, #0x30
stp     x21, x22, [sp, #80]
adrp    x22, 490000 <tunable_list+0x528>
```

remill converts these into LLVM IR (referred to here as `remill LLVM IR sample`) as follows.

In the LLVM IR below, three basic blocks are generated, with remill converting one machine instruction into one basic block.

The operations performed within a basic block are as follows:
- Retrieve the necessary CPU register values.
- Execute a ***semantics function*** that performs an operation equivalent to the machine instruction, using the retrieved values.
- Jump to the basic block corresponding to the next machine instruction.

For the second instruction, `stp     x21, x22, [sp, #80]` is a store instruction that writes the values of registers x21 and x22 to the address sp + 80. As shown in basic block `20:`, it loads the values `%X21`, `%X22`, and `%SP`. Next, the semantics function for the instruction is executed, as seen in `call void @_ZN12_GLOBAL__N_111StorePair64EP14RuntimeManagermm3MVIIDv1_oE(ptr %runtime_manager, i64 %21, i64 %22, i64 %24)`. As demonstrated below, this performs the operation of writing two 64-bit registers for the STP instruction to an address (functions such as `__remill_write_memory_64` are explained later). Finally, a `br` instruction is used to jump to the next instruction.

```llvm
; remill LLVM IR sample
17:                                               ; preds = %L_indirectbr, %12
  %18 = load i64, ptr %SP, align 8
  %19 = call i64 @_ZN12_GLOBAL__N_13ADDImmEEDaT_T0_(i64 %18, i64 48)
  store i64 %19, ptr %X29, align 8
  br label %20

20:                                               ; preds = %L_indirectbr, %17
  %21 = load i64, ptr %X21, align 8
  %22 = load i64, ptr %X22, align 8
  %23 = load i64, ptr %SP, align 8
  %24 = add i64 %23, 80
  call void @_ZN12_GLOBAL__N_111StorePair64EP14RuntimeManagermm3MVIIDv1_oE(ptr %runtime_manager, i64 %21, i64 %22, i64 %24)
  br label %25

25:                                               ; preds = %L_indirectbr, %20
  %26 = call i64 @_ZN12_GLOBAL__N_14ADRPEm(i64 4787788)
  store i64 %26, ptr %X22, align 8
  br label %27
```

```llvm
// semantics function for STP instruction
define internal void @_ZN12_GLOBAL__N_111StorePair64EP14RuntimeManagermm3MVIIDv1_oE(ptr noundef %runtime_manager, i64 noundef %src1, i64 noundef %src2, i64 %dst.coerce) #0 !remill.function.type !5 {
entry:
  tail call void @__remill_write_memory_64(ptr noundef %runtime_manager, i64 noundef %dst.coerce, i64 noundef %src1) #27
  %add.1.i = add i64 %dst.coerce, 8
  tail call void @__remill_write_memory_64(ptr noundef %runtime_manager, i64 noundef %add.1.i, i64 noundef %src2) #27
  ret void
}
```

## Source Code Explanation

The main directory structure of remill is as follows (omitting non-essential parts):

```plaintext
backend/remill/
          ├─ docs         # The original remill documentation. It may be useful as a reference, though it is quite old.
          ├─ include/remill      # Header files for various remill definition classes
                       ├─ Arch       # Header files for CPU architecture-dependent code       
                       ├─ BC         # Header files for CPU architecture-independent code
          ├─ lib          # Implementation files for various remill definition classes
              ├─ Arch          # CPU architecture-dependent code
              ├─ BC            # CPU architecture-independent code
```
### lib/Arch/X86

This directory defines the parsing of x86 instructions and the specific helper functions for each instruction.

```plaintext
lib/Arch/X86
          ├─ Runtime       
                ├─ Instructions.cpp       # A single .cpp file that consolidates the .cpp files defining helper functions for instructions. Currently, many of the #includes in this file are commented out.
          ├─ Semantics       # .cpp files that define the helper functions for instructions.
                ├─ AVX.cpp
                ├─ BINARY.cpp
                ├─ ...
          ├─ Arch.cpp      # The code that parses the actual input instruction stream.
```

- For x86 parsing, [Intel XED](https://intelxed.github.io/ref-manual/) is used.

### lib/BC

Based on the information parsed by lib/Arch, this directory defines the process of actually generating LLVM IR functions.

```plaintext
lib/BC
     ├─ InstructionLifter.cpp        # Defines the process that converts one machine instruction into one basic block. The main function is InstructionLifter::LiftIntoBlock.
     ├─ TraceLifter.cpp              # Defines the process of converting a parsed function into an LLVM IR function. The main function is TraceLifter::Impl::Lift.
```

- `InstructionLifter::LiftIntoBlock`
- `TraceLifter::Impl::Lift`

### Flow of Machine Code Conversion

Below is the flow describing how a single input machine instruction is converted into LLVM IR:
1. **The conversion of the function gotten from ELF binary**
- In elfconv (remill), each function obtained by analyzing an ELF file is translated by [`main_lifter.Lift`](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/lifter/Lift.cpp#L102), which receives the starting address of the function to be translated. Since remill has an internal mechanism for computing control flow, it identifies the machine code executed sequentially from the starting address and ultimately translates the entire function.
    - Overview of `main_lifter.Lift`: In [`TraceLifter::Lift`](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/TraceLifter.cpp#L299) (the actual content of main_lifter.Lift), the [`while (!inst_work_list.empty())`](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/TraceLifter.cpp#L401) loop serves to translate each machine code instruction (`inst_work_list` is a list of addresses of the machine code to be translated, and the machine code instructions to be translated are added to this list). When `inst_work_list` becomes empty, the translation of the target function is complete. (Note: `TraceLifter::Lift` also defines another list called `trace_work_list`, which is a list of the starting addresses of the *functions* to be translated. For example, while translating the machine code of a function named `func1`, if a function call such as call `func2` is encountered, the address of `func2` is added to this list, and after the translation of `func1` is complete, the translation of `func2` begins.)
2. **Translation of each machine code instruction within the function** <br>
Next, we follow the process of translating a single machine code instruction.
    1. **Parsing Process of the Target Machine Code**
        - Within the loop driven by `inst_work_list` in step 1, [`arch->DecodeInstruction`](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/TraceLifter.cpp#L440-L441) processes the target machine code by parsing it and storing information such as the machine code’s opcode and operands (e.g., the relevant CPU registers, memory addresses, etc.) into the `inst` argument of type `remill::Instruction`. Additionally, although the inheritance hierarchy is somewhat complex, in the case of x86, the actual implementation of `arch->DecodeInstruction` is the previously mentioned `X86Arch::ArchDecodeInstruction`.
    2. **Generation Process of LLVM IR Corresponding to Machine Code**
        - Based on the `inst` variable obtained after machine code parsing, the corresponding LLVM IR is actually generated. The function responsible for this is [`inst.GetLifter()->LiftIntoBlock`](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/TraceLifter.cpp#L444).
            1. **Obtaining the Corresponding Intrinsic Function** <br>
It is necessary to [`obtain the intrinsic function`](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/InstructionLifter.cpp#L503-L510) corresponding to the target machine code. The field `arch_inst.function` contains the machine code’s name as a string, and this string is used to look up the registered intrinsic function (tips: the definition via the `DEF_ISEL` macro on the intrinsic function side is utilized in this search). If the intrinsic function for the target machine code is not implemented, a warning such as `[Bug] Unsupported instruction ...` is issued ([this](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/InstructionLifter.cpp#L516) is the warning code). Also, [here](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/InstructionLifter.cpp#L677) is the code for calling this intrinsic function.

            2. **Conversion of Operands** <br>
Each operand must be converted into LLVM IR, and the entry point for that code is [here](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/InstructionLifter.cpp#L597). The `arch_inst.operands` is a list of operands (for example, in the instruction `mov rbx, 50`, `arch_inst.operands` would be \[`remill::Operand(rbx), remill::Operand(50)`\]). Within this list, the function [`LiftOperand`](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/InstructionLifter.cpp#L654) generates the LLVM IR corresponding to the operand. For instance, in the case of `rbx`, it generates code `like %21 = load i64, ptr %rax, align 8`.

            3. **Adding a Jump Instruction to the Next Basic Block** <br>
At this point, the LLVM IR corresponding to the processing of the target machine code has been generated (i.e., `LiftIntoBlock` is finished). Finally, it is necessary to add a `br` instruction to jump to the basic block corresponding to the next instruction, which is defined via a [switch](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/BC/TraceLifter.cpp#L498) statement. For example, if the next machine code instruction is executed sequentially, it falls under `case Instruction::kCategoryNormal:`, whereas if it jumps to a different machine code instruction, it falls under something like `case Instruction::kCategoryDirectJump:`. In this way, the br instruction is added and the translation of the target machine code is completed.
### Memory Management

In the original ELF, besides the code section where machine code is stored, there are several data sections (such as .data, .bss, etc.), and the machine code frequently accesses these. For example, in the case of AArch64, the following instruction sequence accesses the address 0x490000 + 3056 in the data section:

```asm
adrp    x22, 490000 <tunable_list+0x528>
ldr     x0, [x22, #3056]
```

elfconv sets up a large memory area called the `ARENA` for the data in these data sections, as well as for the stack and heap (defined [here](https://github.com/yomaytk/elfconv/blob/73540a0c6fe2a18288bd179434d19b100712e8d5/runtime/Entry.cpp#L22)). When accessing the memory, the access is performed by converting to an address in that copied region. However, even in the LLVM IR generated from the machine code above, a virtual address such as `0x490000 + 3056` is still used in computations. Therefore, it is necessary to convert the virtual address to an address on the `ARENA`. To accommodate this, remill declares a number of function macros for accessing virtual addresses, such as `void __remill_write_memory_macro64(uint64_t vma);`. These macros perform the address conversion (for example, to `memory_arena_ptr + vma`) and allow access to the `ARENA`.

### Adding Machine Code
Adding new machine code primarily requires addressing the following two aspects.
1. **Implementing the Intrinsic Function for the Instruction**
    - The intrinsic functions for each x86 machine code instruction are defined in [`Arch/X86/Semantics`](https://github.com/yomaytk/elfconv/tree/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/lib/Arch/X86/Semantics) When supporting new machine code, you need to add the corresponding intrinsic function here.
    - remill defines helper functions used by the intrinsic functions in [`include/remill/Arch/Runtime/Operators.h`](https://github.com/yomaytk/elfconv/blob/main/backend/remill/include/remill/Arch/Runtime/Operators.h) (these may seem complex due to the heavy use of macros and templates, but the processing itself is straightforward). In the implementation of the intrinsic functions, you implement behavior equivalent to the instruction by using the functions defined in `Operators.h`. Moreover, although machine code differs significantly across CPU architectures, many processes are common, so these helper functions are independent of the CPU architecture. This allows for similar implementations on both X86 and AArch64. A code-level explanation will be provided later.
2. **Parsing the Input Machine Code**
    - For x86, since parsing is performed by Intel XED, little additional implementation is required; only the function void SetSemaFuncArgType() {} requires extra implementation.

## Machine Code Testing

## Debugging
