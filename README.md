# elfconv
elfconv is a binary translator that translates a Linux ELF binary to the executable binary for other platforms. elfconv mainly supports converting Linux/ELF binaries into WebAssembly or ELF for different CPU architectures.
elfconv converts an original ELF binary to the LLVM bitcode using [Remill](https://github.com/lifting-bits/remill) (However, many parts have been modified to improve functionality and performance)
and elfconv uses [Emscripten](https://github.com/emscripten-core/emscripten) (for browser) or [WASI-SDK](https://github.com/WebAssembly/wasi-sdk) (for WASI runtimes) to generate the Wasm binary from the LLVM bitcode file.

## Status
> [!WARNING]
> "**elfconv is WORK IN PROGRESS**" and the test is insufficient, so you may fail to compile your ELF binary or execute the generated Wasm binary. Current limitations are as follows. However, we will resolve these issues in the future.
- Only support for aarch64 ELF binary as an input binary (the support for x86-64 is a work in progress)
    - Furthermore, the implementation of the conversion for aarch64 is not enough. If your ELF binary's instruction is not supported, elfconv outputs the message (\[WARNING\] Unsupported instruction at 0x...) when you build with [`#define WARNING_OUTPUT 1`](https://github.com/yomaytk/elfconv/blob/deb2a42e1e3f155128f48010bac7c55a0b60b51f/backend/remill/include/remill/BC/HelperMacro.h#L8) being commented out.
- No support for shared objects
- Only a part of the Linux system calls are implemented (ref: [`runtime/syscalls/`](https://github.com/yomaytk/elfconv/blob/main/runtime/syscalls))

## Benchmark
For several test programs, we measured the performance of the WebAssembly (both for browser and WASI runtimes) generated by elfconv. The comparison target was the Wasm program compiled directly by Emscripten or WASI-SDK from the source code. elfconv converts the ELF/aarch64 produced by an existing compiler (gcc or clang) from the same source code into a Wasm program. In this performance test, we compared the performance of both Wasm programs.
### To Wasm (Emscripten)
| Target Program      | from source code   | elfconv    |
|----------|----------|----------|
| [`eratosthenes_sieve`](https://github.com/yomaytk/elfconv/tree/main/examples/benchmarks/eratosthenes_sieve) (↓ better) | 0.567 (s) (100%) | 0.692 (s) (**82%**)  |
| [`LINPACK benchmark`](https://www.netlib.org/linpack/) (↑ better) | 1617 (MFLOPS) (100%) | 1256 (MFLOPS) (**78%**) |
| [`mnist-neural-network-plain-c (during 30 steps)`](https://github.com/AndrewCarterUK/mnist-neural-network-plain-c) (↑ better) | 2.138 (s) (100%) | 2.255 (s) (**96%**) |

### To WASI
| Target Program      | from source code   | elfconv    |
|----------|----------|----------|
| [`eratosthenes_sieve`](https://github.com/yomaytk/elfconv/tree/main/examples/benchmarks/eratosthenes_sieve) (↓ better) | 0.362 (s) (100%) | 0.608 (s) (**60%**)  |
| [`LINPACK benchmark`](https://www.netlib.org/linpack/) (↑ better) | 4821 (MFLOPS) (100%) | 2720 (MFLOPS) (**56%**) |
| [`mnist-neural-network-plain-c (during 30 steps)`](https://github.com/AndrewCarterUK/mnist-neural-network-plain-c) (↑ better) | 2.271 (s) (100%) | 2.302 (s) (**96%**) |

As this table shows, Wasm on both Browser and WASI runtimes can be executed with less performance degradation than when Wasm is generated from the source code.

## Quick Start
You can try elfconv using the Docker container (x86-64 and ARM64) by executing the commands as follows, and you can execute the Wasm application in both browser and host environment (WASI runtimes).

### Browser
```bash
$ git clone --recursive https://github.com/yomaytk/elfconv
$ cd elfconv
elfconv/$ docker build . -t <image-name>
elfconv/$ docker run -it --rm -p 8080:8080 --name <container-name> <image-name>
### running build and test ...
# You can test elfconv using `bin/elfconv.sh`
~/elfconv# cd bin
~/elfconv/bin# TARGET=aarch64-wasm ./elfconv.sh /path/to/ELF # e.g., ../examples/hello/c/a.aarch64
# exe.js and exe.wasm should be generated.
~/elfconv/bin# emrun --no_browser --port 8080 exe.html
Web server root directory: /root/elfconv/bin
Now listening at http://0.0.0.0:8080/
```
Now, the Wasm application server has started, so that you can access it (e.g., http://localhost:8080/exe.wasm.html) from outside the container.
### Host (WASI runtimes)
```bash
$ git clone --recursive https://github.com/yomaytk/elfconv
$ cd elfconv
$ docker build . -t <image-name>
$ docker run -it --name <container-name> <image-name>
### running build and test ...
# You can test elfconv using `bin/elfconv.sh`
~/elfconv# cd bin
~/elfconv/bin# TARGET=aarch64-wasi32 ./elfconv.sh /path/to/ELF # e.g. ../examples/hello/c/a.aarch64
~/elfconv/bin# wasmedge exe.wasm # wasmedge is preinstalled
```
## Source code build
### 1. Dev Container
elfconv provides the Dev Container environment using the root [`Dockerfile`](https://github.com/yomaytk/elfconv/blob/main/Dockerfile) and [`.devcontainer.json`](https://github.com/yomaytk/elfconv/blob/main/.devcontainer.json), so you can develop without making the build environment if you can use Dev Container on your vscode (Please refer to the official website of vscode for basically using Dev Container).
### 2. Local Environment
#### Dependencies
The libraries required for the build are almost the same as those for Remill, and the main libraries are as follows. The other required libraries are automatically installed using [cxx-common](https://github.com/lifting-bits/cxx-common).

| Name | Version |
| ---- | ------- |
| [CMake](https://cmake.org/) | 3.14+ |
| [Google Flags](https://github.com/google/glog) | Latest |
| [Google Log](https://github.com/google/glog) | Latest |
| [Google Test](https://github.com/google/googletest) | Latest |
| [LLVM](http://llvm.org/) | 16+ |
| [Clang](http://clang.llvm.org/) | 16+ |
| [Intel XED](https://software.intel.com/en-us/articles/xed-x86-encoder-decoder-software-library) | Latest |
| [Unzip](https://packages.debian.org/en/sid/unzip) | Latest |
| [ccache](https://ccache.dev/) | Latest |
| [libelf](https://packages.debian.org/en/sid/libelf-dev) | Latest |
| [libbfd](https://packages.debian.org/en/sid/hppa/binutils-dev) | Latest |
| [libdwarf](https://packages.debian.org/en/sid/libdwarf-dev) | Latest |

#### Build
If you prepare these libraries, you can easily build elfconv by executing [`scripts/build.sh`](https://github.com/yomaytk/elfconv/blob/main/scripts/build.sh) as follows.
```bash
$ git clone --recursive https://github.com/yomaytk/elfconv
$ cd elfconv
/elfconv$ ./scripts/build.sh
```
> [!NOTE]
> If you fail to build elfconv, please feel free to submit an issue!
### Develop
After finishing the build, you can find the directory `elfconv/build/`, and you can build the *'lifter'* (*'lifter'* is the module that converts the ELF binary to LLVM bitcode and those source codes are mainly located in the [`backend/remill/`](https://github.com/yomaytk/elfconv/tree/main/backend/remill) and [`lifter/`](https://github.com/yomaytk/elfconv/tree/main/lifter)) by *ninja* after modifying the *'lifter'* codes.

You can compile the ELF binary to the Wasm binary using [`scripts/dev.sh`](https://github.com/yomaytk/elfconv/blob/main/scripts/dev.sh) as follows. `dev.sh` execute the translation (ELF -> LLVM bitcode by *'lifter'*) and compiles the [`runtime/`](https://github.com/yomaytk/elfconv/tree/main/runtime) (statically linked with generated LLVM bitcode) and generate the Wasm binary. When you execute the script, you should explicitly specify the path of the elfconv directory (`/root/elfconv` on the container) with `NEW_ROOT` or rewrite the `ROOT_DIR` in `dev.sh`. 
```bash
# TARGET=<elf_arch>-<target_arch> (e.g., ELF/aarch64 -> Wasm for wasi32: aarch64-wasi32)

### Native
~/elfconv/build# NEW_ROOT=/path/to/elfconv TARGET=aarch64-native ../scripts/dev.sh path/to/ELF # generate the Native binary (Host architecture) under the elfconv/build/lifter
~/elfconv/build# ./exe.${HOST_CPU}
------------------------
### Browser (use xterm-pty (https://github.com/mame/xterm-pty))
~/elfconv/build# NEW_ROOT=/path/to/elfconv TARGET=aarch64-wasm ../scripts/dev.sh path/to/ELF # generate the Wasm binary under the elfconv/build/lifter
~/elfconv/build# emrun --no_browser --port 8080 ../examples/browser/exe.html # execute the generated Wasm binary with emscripten
------------------------
### Host (WASI Runtimes)
~/elfconv/build# NEW_ROOT=/path/to/elfconv TARGET=aarch64-wasi32 ../scripts/dev.sh path/to/ELF
~/elfconv/build# wasmedge ./exe.wasm # or wasmedge ./exe_o3.wasm
```
## Acknowledgement
elfconv uses or references some projects as follows. Great thanks to all its developers!
- Remill ([Apache Lisence 2.0](https://github.com/lifting-bits/remill/blob/master/LICENSE))
    - Original Source: https://github.com/lifting-bits/remill
    - elfconv uses Remill to convert machine codes to LLVM IR instructions. The source code is contained in [`./backend/remill`](https://github.com/yomaytk/elfconv/tree/main/backend/remill) and is modified for using from front-end and supporting additional instructions.
- MyAOT ([Apache Lisence 2.0](https://github.com/AkihiroSuda/myaot/blob/master/LICENSE))
    - Original Source: https://github.com/AkihiroSuda/myaot
    - An experimental AOT-ish compiler (Linux/riscv32 ELF → Linux/x86_64 ELF, Mach-O, Wasm, ...)
    - elfconv has started as the successor project of MyAOT.
