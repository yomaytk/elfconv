
<p align="center">
  <img src="images/elfconv-official.png" width="300" alt="elfconv-logo2" />
</p>


# elfconv
[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/yomaytk/elfconv)

An ahead-of-time (AOT) binary translator that converts Linux applications to WebAssembly (Wasm) for both browser and WASI runtimes.

[[üåé**Try Demo**]](https://yomaytk.github.io/elfconv-demo/)

## Why elfconv?
### 1. Easy Porting to Wasm
- **No source code needed** ‚Äî Port pre-built binaries directly to Wasm, even when source code is unavailable
- **Linux syscall emulation** ‚Äî Emulates Linux syscalls missing in Wasm environments (e.g., `fork/execve`), enabling unmodified Linux apps to run
- **Language-agnostic** ‚Äî No per-language compiler support needed; works with any language that compiles to Linux/ELF

**Use cases:**
- Legacy applications where source code is unavailable or difficult to rebuild
- Porting Linux libraries to Wasm for use in developing web applications
- Porting powerful softwares (e.g., compiler, build systems, etc.) in browsers

### 2. Process Management
- **`fork/execve` support**
  - elfconv experimentally supports `fork()` and `execve()` system calls in Wasm in browsers. This enables running more complex Linux applications that rely on multi-process architectures, such as shells, build systems, and server applications that spawn child processes (e.g., [**GNU Bash + BusyBox**](https://yomaytk.github.io/elfconv-demo/bash-busybox.html) on the demo page).

### 3. Low Performance Overhead
- **AOT Compilation**
  - Existing projects use CPU emulators (e.g., [v86](https://github.com/copy/v86), [container2wasm](https://github.com/container2wasm/container2wasm)) to port Linux applications to Wasm, but **incur severe slowdowns of 10√ó or more**. In contrast, elfconv applies AOT compilation to translate machine code directly to LLVM IR, achieving much smaller performance degradation (ref.  [Performance](#performance) section).

## Current Limitations
> [!WARNING]
> **elfconv is WORK IN PROGRESS**. Testing is insufficient, so you may encounter failures when compiling ELF binaries or executing generated Wasm binaries.

- **Architecture Support**: Only AArch64 ELF binaries are currently supported
  - x86-64 support is under development
- **Linking**: No support for shared objects (`.so` files)
  - Only statically-linked binaries are supported
- **System Calls**: Partial Linux syscall implementation
  - See [`runtime/syscalls/`](https://github.com/yomaytk/elfconv/blob/main/runtime/syscalls) for currently supported syscalls
  - More syscalls are being added continuously

## Performance
We measured the performance of Wasm generated by elfconv against Wasm compiled directly from source using Emscripten or WASI-SDK. The workflow is:
1. Compile source code ‚Üí AArch64 ELF binary (using gcc/clang)
2. Convert ELF binary ‚Üí Wasm using elfconv
3. Compare with: Source code ‚Üí Wasm directly (using Emscripten/WASI-SDK)

**Blog**: [elfconv: Linux Apps to High-Performance Wasm Binary Translator](https://medium.com/nttlabs/some-performance-improvements-in-the-binary-translator-that-converts-linux-applications-c6b26945cf39)
### To Wasm (Emscripten)
| Target Program      | from source code   | elfconv    |
|----------|----------|----------|
| [`eratosthenes_sieve`](https://github.com/yomaytk/elfconv/tree/main/examples/benchmarks/eratosthenes_sieve) (‚Üì better) | 0.567 (s) (100%) | 0.692 (s) (**82%**)  |
| [`LINPACK benchmark`](https://www.netlib.org/linpack/) (‚Üë better) | 1617 (MFLOPS) (100%) | 1256 (MFLOPS) (**78%**) |
| [`mnist-neural-network-plain-c (during 30 steps)`](https://github.com/AndrewCarterUK/mnist-neural-network-plain-c) (‚Üë better) | 2.138 (s) (100%) | 2.255 (s) (**96%**) |

### To WASI
| Target Program      | from source code   | elfconv    |
|----------|----------|----------|
| [`eratosthenes_sieve`](https://github.com/yomaytk/elfconv/tree/main/examples/benchmarks/eratosthenes_sieve) (‚Üì better) | 0.362 (s) (100%) | 0.608 (s) (**60%**)  |
| [`LINPACK benchmark`](https://www.netlib.org/linpack/) (‚Üë better) | 4821 (MFLOPS) (100%) | 2720 (MFLOPS) (**56%**) |
| [`mnist-neural-network-plain-c (during 30 steps)`](https://github.com/AndrewCarterUK/mnist-neural-network-plain-c) (‚Üë better) | 2.271 (s) (100%) | 2.302 (s) (**96%**) |

**Key Takeaway**: elfconv achieves **56-96%** of native source-to-Wasm performance, significantly better than CPU emulation approaches which typically have 10x or more slowdown.

## Quick Start
The easiest way to try elfconv is using Linux container, which supports both x86-64 and ARM64 hosts.

Choose your execution environment:
- **Option 1 - Browser**: Run Wasm in a web browser with terminal emulation
- **Option 2 - WASI Runtime**: Run Wasm on the host using WasmEdge or other WASI-compatible runtimes

### Option 1: Browser Execution
```bash
# 1. Build container
$ git clone --recursive https://github.com/yomaytk/elfconv
$ cd elfconv
$ docker build . --build-arg ECV_AARCH64=1 -t elfconv-image
# Note: ECV_AARCH64=1 for AArch64 ELF, ECV_X86=1 for x86-64 ELF

# 2. Run container with port forwarding
$ docker run -it --rm -p 8080:8080 --name elfconv-container elfconv-image

# 3. Convert ELF to Wasm
~/elfconv# cd bin
~/elfconv/bin# TARGET=aarch64-wasm INITWASM=1 ./exe.sh /path/to/ELF
# Example: TARGET=aarch64-wasm INITWASM=1 ./exe.sh ../examples/hello/c/a.aarch64

# 4. Start web server
~/elfconv/bin# emrun --no_browser --port 8080 <ELFNAME>.html
```

Access the Wasm application from your browser at `http://localhost:8080/<ELFNAME>.html`

### Option 2: WASI Runtime Execution
```bash
# 1. Build and run container
$ git clone --recursive https://github.com/yomaytk/elfconv
$ cd elfconv
$ docker build . --build-arg ECV_AARCH64=1 -t elfconv-image
$ docker run -it --name elfconv-container elfconv-image

# 2. Convert ELF to Wasm
~/elfconv# cd bin
~/elfconv/bin# TARGET=aarch64-wasi32 ./exe.sh /path/to/ELF
# Example: TARGET=aarch64-wasi32 ./exe.sh ../examples/hello/c/a.aarch64

# 3. Execute with WasmEdge (preinstalled)
~/elfconv/bin# wasmedge <ELFNAME>.wasm
```

## Contributing

**We welcome contributions!** we'd love your help making it better.

### Ways to Contribute
For example, the following contributions are expected:
- üîß **Instruction Support** ‚Äî Implement missing AArch64 instructions or advance x86-64 instruction support.
- ‚öôÔ∏è **System Call Implementation** ‚Äî Add Linux syscall support in [`runtime/syscalls/`](https://github.com/yomaytk/elfconv/tree/main/runtime/syscalls)
- üß™ **Testing** ‚Äî Test with various Linux applications and report issues
- üìö **Documentation** ‚Äî Improve documentation, add examples

For questions or discussions, feel free to [open an issue](https://github.com/yomaytk/elfconv/issues/new) or start a discussion.

## Acknowledgement
elfconv uses or references some projects as follows. Great thanks to all its developers!
- Remill ([Apache Lisence 2.0](https://github.com/lifting-bits/remill/blob/master/LICENSE))
    - Original Source: https://github.com/lifting-bits/remill
    - elfconv uses Remill to convert machine codes to LLVM IR instructions. The source code is contained in [`./backend/remill`](https://github.com/yomaytk/elfconv/tree/main/backend/remill) and is modified for using from front-end and supporting additional instructions.
- MyAOT ([Apache Lisence 2.0](https://github.com/AkihiroSuda/myaot/blob/master/LICENSE))
    - Original Source: https://github.com/AkihiroSuda/myaot
    - An experimental AOT-ish compiler (Linux/riscv32 ELF ‚Üí Linux/x86_64 ELF, Mach-O, Wasm, ...)
    - elfconv has started as the successor project of MyAOT.
