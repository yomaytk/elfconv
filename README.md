
<p align="center">
  <img src="https://github.com/user-attachments/assets/7638341e-1871-4e15-b366-31c39ae01d81" width="300" alt="elfconv-logo2" />
</p>


# elfconv
[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/yomaytk/elfconv)

An AOT (ahead-of-time) binary translator that converts Linux applications to executable binaries for other environments, primarily targeting WebAssembly (Wasm) for both browser and WASI runtimes.

[[üåé**Try Demo**]](https://yomaytk.github.io/elfconv-demo/)

## Why elfconv?
elfconv focuses primarily on WebAssembly (Wasm) conversion, offering many benefits over traditional approaches.

### 1. Easy Porting to Wasm
- **No source code needed** ‚Äî Port pre-built binaries directly to Wasm, even when source code is unavailable
- **Linux syscall emulation** ‚Äî Emulates Linux syscalls missing in Wasm environments (e.g., `fork/execve`), enabling unmodified Linux apps to run
- **Language-agnostic** ‚Äî No per-language compiler support needed; works with any language that compiles to Linux/ELF

**Use cases:**
- Legacy applications where source code is unavailable or difficult to rebuild
- Porting Linux libraries to Wasm for use in developing web applications
- Quick prototyping without modifying build systems
- Educational demos of operating systems and compilers in browsers

### 2. Advanced Process Management (Experimental)
- **fork/execve support in Browser Wasm**
  - elfconv experimentally supports `fork()` and `execve()` system calls in browser-based WebAssembly environments. This is not possible with Emscripten, which lacks proper support for these fundamental process management primitives. This capability enables running more complex Linux applications that rely on multi-process architectures, such as shells, build systems, and server applications that spawn child processes (e.g., [**GNU Bash in your browser**](https://yomaytk.github.io/elfconv-demo/) on the demo page).

### 3. Low Performance Overhead
- **AOT Compilation**
  - There are existing projects that port Linux applications to Wasm by using CPU emulators such as [v86](https://github.com/copy/v86) and [container2wasm](https://github.com/container2wasm/container2wasm). However, these suffer from very poor performance‚Äîoften slowing execution by 10x or more. In contrast, elfconv uses ahead-of-time (AOT) compilation to translate machine code directly to LLVM IR, resulting in much smaller performance degradation (see [Benchmark](#benchmark) section for details).
## Current Status & Limitations
> [!WARNING]
> **elfconv is WORK IN PROGRESS**. Testing is insufficient, so you may encounter failures when compiling ELF binaries or executing generated Wasm binaries.

### Current Limitations
- **Architecture Support**: Only AArch64 ELF binaries are currently supported
  - x86-64 support is under development
- **Linking**: No support for shared objects (`.so` files)
  - Only statically-linked binaries are supported
- **System Calls**: Partial Linux syscall implementation
  - See [`runtime/syscalls/`](https://github.com/yomaytk/elfconv/blob/main/runtime/syscalls) for currently supported syscalls
  - More syscalls are being added continuously

We are actively working to resolve these limitations.

## Contributing

**We welcome contributions!** elfconv is an open-source project and we'd love your help making it better.

### Ways to Contribute

- üîß **Instruction Support** ‚Äî Implement missing AArch64 instructions in [`backend/remill/lib/Arch/AArch64/`](https://github.com/yomaytk/elfconv/tree/main/backend/remill/lib/Arch/AArch64)
- üèóÔ∏è **x86-64 Architecture** ‚Äî Help develop x86-64 support (currently under development)
- ‚öôÔ∏è **System Call Implementation** ‚Äî Add Linux syscall support in [`runtime/syscalls/`](https://github.com/yomaytk/elfconv/tree/main/runtime/syscalls)
- üß™ **Testing** ‚Äî Test with various Linux applications and report issues
- üìö **Documentation** ‚Äî Improve documentation, add examples, or write tutorials

For questions or discussions, feel free to [open an issue](https://github.com/yomaytk/elfconv/issues/new) or start a discussion.

## Benchmark
We measured the performance of WebAssembly generated by elfconv (both browser and WASI runtimes) against Wasm compiled directly from source using Emscripten or WASI-SDK. The workflow is:
1. Compile source code ‚Üí AArch64 ELF binary (using gcc/clang)
2. Convert ELF binary ‚Üí Wasm using elfconv
3. Compare with: Source code ‚Üí Wasm directly (using Emscripten/WASI-SDK)

**Blog**: [elfconv: Linux Apps to High-Performance Wasm Binary Translator](https://medium.com/nttlabs/some-performance-improvements-in-the-binary-translator-that-converts-linux-applications-c6b26945cf39)
### To Wasm (Emscripten)
| Target Program      | from source code   | elfconv    |
|----------|----------|----------|
| [`eratosthenes_sieve`](https://github.com/yomaytk/elfconv/tree/main/examples/benchmarks/eratosthenes_sieve) (‚Üì better) | 0.567 (s) (100%) | 0.692 (s) (**82%**)  |
| [`LINPACK benchmark`](https://www.netlib.org/linpack/) (‚Üë better) | 1617 (MFLOPS) (100%) | 1256 (MFLOPS) (**78%**) |
| [`mnist-neural-network-plain-c (during 30 steps)`](https://github.com/AndrewCarterUK/mnist-neural-network-plain-c) (‚Üë better) | 2.138 (s) (100%) | 2.255 (s) (**96%**) |

### To WASI
| Target Program      | from source code   | elfconv    |
|----------|----------|----------|
| [`eratosthenes_sieve`](https://github.com/yomaytk/elfconv/tree/main/examples/benchmarks/eratosthenes_sieve) (‚Üì better) | 0.362 (s) (100%) | 0.608 (s) (**60%**)  |
| [`LINPACK benchmark`](https://www.netlib.org/linpack/) (‚Üë better) | 4821 (MFLOPS) (100%) | 2720 (MFLOPS) (**56%**) |
| [`mnist-neural-network-plain-c (during 30 steps)`](https://github.com/AndrewCarterUK/mnist-neural-network-plain-c) (‚Üë better) | 2.271 (s) (100%) | 2.302 (s) (**96%**) |

**Key Takeaway**: elfconv achieves **56-96%** of native source-to-Wasm performance, significantly better than CPU emulation approaches which typically have 10x or more slowdown.

## Quick Start
The easiest way to try elfconv is using our pre-built Docker container, which supports both x86-64 and ARM64 hosts. No local dependencies needed!

Choose your execution environment:
- **Option 1 - Browser**: Run Wasm in a web browser with terminal emulation
- **Option 2 - WASI Runtime**: Run Wasm on the host using WasmEdge or other WASI-compatible runtimes

### Option 1: Browser Execution
```bash
# 1. Build container
$ git clone --recursive https://github.com/yomaytk/elfconv
$ cd elfconv
$ docker build . --build-arg ECV_AARCH64=1 -t elfconv-image
# Note: ECV_AARCH64=1 for AArch64 ELF, ECV_X86=1 for x86-64 ELF

# 2. Run container with port forwarding
$ docker run -it --rm -p 8080:8080 --name elfconv-container elfconv-image

# 3. Convert ELF to Wasm
~/elfconv# cd bin
~/elfconv/bin# TARGET=aarch64-wasm INITWASM=1 ./exe.sh /path/to/ELF
# Example: TARGET=aarch64-wasm INITWASM=1 ./exe.sh ../examples/hello/c/a.aarch64

# 4. Start web server
~/elfconv/bin# emrun --no_browser --port 8080 <ELFNAME>.html
```

Access the Wasm application from your browser at `http://localhost:8080/<ELFNAME>.html`

### Option 2: WASI Runtime Execution
```bash
# 1. Build and run container
$ git clone --recursive https://github.com/yomaytk/elfconv
$ cd elfconv
$ docker build . --build-arg ECV_AARCH64=1 -t elfconv-image
$ docker run -it --name elfconv-container elfconv-image

# 2. Convert ELF to Wasm
~/elfconv# cd bin
~/elfconv/bin# TARGET=aarch64-wasi32 ./exe.sh /path/to/ELF
# Example: TARGET=aarch64-wasi32 ./exe.sh ../examples/hello/c/a.aarch64

# 3. Execute with WasmEdge (preinstalled)
~/elfconv/bin# wasmedge <ELFNAME>.wasm
```
## Building from Source

### Option 1: Dev Container (Recommended)
The easiest way to get started with development is using VS Code's Dev Container feature:

1. Install [VS Code](https://code.visualstudio.com/) and [Docker](https://www.docker.com/)
2. Install the [Dev Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers)
3. Clone the repository and open in VS Code
4. Click "Reopen in Container" when prompted

The dev container includes all necessary dependencies and tools pre-configured.

### Option 2: Local Environment
#### Prerequisites
elfconv requires the following dependencies. Most are similar to [Remill](https://github.com/lifting-bits/remill) requirements. Additional dependencies are automatically installed via [cxx-common](https://github.com/lifting-bits/cxx-common).

| Name | Version |
| ---- | ------- |
| [CMake](https://cmake.org/) | 3.14+ |
| [Google Flags](https://github.com/google/glog) | Latest |
| [Google Log](https://github.com/google/glog) | Latest |
| [Google Test](https://github.com/google/googletest) | Latest |
| [LLVM](http://llvm.org/) | 16+ |
| [Clang](http://clang.llvm.org/) | 16+ |
| [Intel XED](https://software.intel.com/en-us/articles/xed-x86-encoder-decoder-software-library) | Latest |
| [Unzip](https://packages.debian.org/en/sid/unzip) | Latest |
| [ccache](https://ccache.dev/) | Latest |
| [libelf](https://packages.debian.org/en/sid/libelf-dev) | Latest |
| [libbfd](https://packages.debian.org/en/sid/hppa/binutils-dev) | Latest |
| [libdwarf](https://packages.debian.org/en/sid/libdwarf-dev) | Latest |

#### Build Steps
Once dependencies are installed, build elfconv using the provided build script:

```bash
# Clone repository (--recursive is important for submodules)
$ git clone --recursive https://github.com/yomaytk/elfconv
$ cd elfconv

# Run build script
$ ./scripts/build.sh
```

> [!NOTE]
> If you encounter build issues, please [submit an issue](https://github.com/yomaytk/elfconv/issues) with details about your environment and error messages.
## Development Workflow

### Building the Lifter
After building elfconv, you'll find the `elfconv/build/` directory. The **lifter** is the core module that converts ELF binaries to LLVM bitcode (source code in [`backend/remill/`](https://github.com/yomaytk/elfconv/tree/main/backend/remill) and [`lifter/`](https://github.com/yomaytk/elfconv/tree/main/lifter)).

To rebuild after modifying lifter code:
```bash
~/elfconv/build# ninja
```

### Converting Binaries with dev.sh
Use [`scripts/dev.sh`](https://github.com/yomaytk/elfconv/blob/main/scripts/dev.sh) for development workflow. This script:
1. Translates ELF ‚Üí LLVM bitcode (using lifter)
2. Compiles the [`runtime/`](https://github.com/yomaytk/elfconv/tree/main/runtime) statically linked with generated bitcode
3. Generates the final binary/Wasm

**Note**: Set `NEW_ROOT` environment variable or edit `ROOT_DIR` in `dev.sh` to point to your elfconv directory (e.g., `/root/elfconv` in container).

#### Target Native (for testing)
```bash
~/elfconv/build# TARGET=aarch64-native ../scripts/dev.sh path/to/ELF
~/elfconv/build# ./<ELFNAME>.${HOST_CPU}
```

#### Target Browser (Emscripten)
```bash
~/elfconv/build# TARGET=aarch64-wasm INITWASM=1 ../scripts/dev.sh path/to/ELF
~/elfconv/build# emrun --no_browser --port 8080 <ELFNAME>.html
```

#### Target WASI Runtime
```bash
~/elfconv/build# TARGET=aarch64-wasi32 ../scripts/dev.sh path/to/ELF
~/elfconv/build# wasmedge <ELFNAME>.wasm
# Or optimized version: wasmedge <ELFNAME>_o3.wasm
```

## Acknowledgement
elfconv uses or references some projects as follows. Great thanks to all its developers!
- Remill ([Apache Lisence 2.0](https://github.com/lifting-bits/remill/blob/master/LICENSE))
    - Original Source: https://github.com/lifting-bits/remill
    - elfconv uses Remill to convert machine codes to LLVM IR instructions. The source code is contained in [`./backend/remill`](https://github.com/yomaytk/elfconv/tree/main/backend/remill) and is modified for using from front-end and supporting additional instructions.
- MyAOT ([Apache Lisence 2.0](https://github.com/AkihiroSuda/myaot/blob/master/LICENSE))
    - Original Source: https://github.com/AkihiroSuda/myaot
    - An experimental AOT-ish compiler (Linux/riscv32 ELF ‚Üí Linux/x86_64 ELF, Mach-O, Wasm, ...)
    - elfconv has started as the successor project of MyAOT.
